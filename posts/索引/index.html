<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="索引" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="索引概述" /><meta property="og:description" content="索引概述" /><link rel="canonical" href="https://casflawed.github.io/posts/%E7%B4%A2%E5%BC%95/" /><meta property="og:url" content="https://casflawed.github.io/posts/%E7%B4%A2%E5%BC%95/" /><meta property="og:site_name" content="flameking" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-25T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="索引" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://casflawed.github.io/posts/%E7%B4%A2%E5%BC%95/"},"description":"索引概述","url":"https://casflawed.github.io/posts/%E7%B4%A2%E5%BC%95/","@type":"BlogPosting","headline":"索引","dateModified":"2022-10-15T21:58:22+08:00","datePublished":"2022-06-25T00:00:00+08:00","@context":"https://schema.org"}</script><title>索引 | flameking</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="flameking"><meta name="application-name" content="flameking"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202201120016998.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">flameking</a></div><div class="site-subtitle font-italic">Life is flawed,but we still love life</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Casflawed" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['2711554770','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>索引</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>索引</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/Casflawed">flameking</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" date="2022-06-25 00:00:00 +0800" data-toggle="tooltip" data-placement="bottom" title="2022-06-25, 00:00 +0800" >2022-06-25</em> </span> <span> 更新于 <em class="timeago" date="2022-10-15 21:58:22 +0800 " data-toggle="tooltip" data-placement="bottom" title="2022-10-15, 21:58 +0800" >2022-10-15</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5493 字"> <em>30 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="索引概述">索引概述</h1><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>有序的数据结构</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</ul><p>缺点：</p><ul><li>索引列也是要占用磁盘空间的<li>索引大大提高了查询效率，但降低了更新表的速度，比如 INSERT、UPDATE、DELETE</ul><p><strong>实际上索引的缺点可以忽略：<br /> 1.磁盘比较便宜<br /> 2.往往在使用索引的表中，查询操作频率高，增删改频率低</strong></p><h1 id="索引结构">索引结构</h1><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含一下几种：</p><div class="table-wrapper"><table><thead><tr><th>索引结构<th>描述<tbody><tr><td>B+Tree<td>最常见的索引类型，大部分引擎都支持B+树索引<tr><td>Hash<td>底层数据结构是用哈希表实现，性能高支持精确查询，但不支持范围查询<tr><td>R-Tree(空间索引)<td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少<tr><td>Full-Text(全文索引)<td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</table></div><div class="table-wrapper"><table><thead><tr><th>索引<th>InnoDB<th>MyISAM<th>Memory<tbody><tr><td>B+Tree索引<td>支持<td>支持<td>支持<tr><td>Hash索引<td>不支持<td>不支持<td>支持<tr><td>R-Tree索引<td>不支持<td>支持<td>不支持<tr><td>Full-text<td>5.6版本后支持<td>支持<td>不支持</table></div><p><strong>注意：<br /> 1.B+Tree索引不同的存储引擎基本都支持，Hash索引只有Memory支持<br /> 2.平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引</strong></p><h2 id="b-tree">B-Tree<a href="#b-tree" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>在讲解B树之前，我们首先看看二叉树：<br /> <img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271457973.png" alt="二叉树" title="二叉树" data-proofer-ignore></p><p>二叉树缺点：<br /> 1.数据本身有序，构建二叉树会退化成链表，这是性能大大降低，等于全表查询<br /> 2.由于二叉树只有两个分支，如果数据量比较大，层级会很深，检索速度也会很低</p><p>二叉树的缺点可以用红黑树来解决：<br /> <img data-src="https://dhc.pythonanywhere.com/media/editor/红黑树_20220316163142686602.png" alt="红黑树" title="红黑树" data-proofer-ignore></p><p>红黑树的缺点：红黑树本质也是二叉树，也存在上述二叉树的缺点2，为了解决这个问题，可以使用 B-Tree 结构。</p><p>以一棵最大度数为5（5阶）的 B-Tree(多路平衡查找树) 为例（每个节点最多存储4个key，5个指针）</p><p><img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271508116.png" alt="B-Tree结构" title="B-Tree结构" data-proofer-ignore></p><blockquote><p>须知：<br /> 1.多路：一个节点下可以有多颗子树，这样就可以解决二叉树在数据量大的情况下，层级较深的情况<br /> 2.度数：一个节点的子节点/子树的个数<br /> 3.指针数等于子节点数</p></blockquote><blockquote><p>动态构建B树演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html<br /> <strong>子树分裂原则:中间节点向上分裂</strong><br /> <img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271522010.png" alt="分裂效果图" title="分裂效果图" data-proofer-ignore></p></blockquote><p><strong>总结：对于B树来说，每个节点的每个key下都会挂着数据</strong></p><h2 id="btree">B+Tree<a href="#btree" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>结构图：<br /> <img data-src="https://dhc.pythonanywhere.com/media/editor/B+Tree结构图_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图" data-proofer-ignore></p><blockquote><p>演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271541450.png" alt="B+树分裂效果图" title="B+树分裂效果图" data-proofer-ignore></p><p>B+树与B树<br /> 1.区别：</p><ul><li>所有的key都会出现在叶子节点<br /><li>叶子节点形成一个单向链表<br /><li>数据只挂在叶子节点的key下<br /><li>非叶子节点只起到索引的作用<br /></ul><p>2.相同点：</p><ul><li>B+Tree本质是B树的变种，因此也遵循子树分裂原则</ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree（其实最终就形成了一个双向链表），提高区间访问的性能。<strong>另外一个节点是存储在一个页中的，在InnoDB中一个页大小默认是16KB</strong></p><p><img data-src="https://dhc.pythonanywhere.com/media/editor/结构图_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图" data-proofer-ignore></p><h2 id="hash">Hash<a href="#hash" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表（拉链法）来解决。</p><p><img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271550025.png" alt="Hash索引原理图" title="Hash索引原理图" data-proofer-ignore></p><p>特点：</p><ul><li>Hash索引只能用于等值查询（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）<li>无法利用索引完成排序操作<li>查询效率高，通常只需要一次检索（前提是不出现hash碰撞）就可以了，效率通常要高于 B+Tree 索引</ul><p>存储引擎支持：</p><ul><li>Memory<li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</ul><h2 id="面试题">面试题<a href="#面试题" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</ol><ul><li>在相同数据量的情况下，相对于二叉树/红黑树，B+树层级更少，搜索效率更高<li>相对于B树，非叶子节点不存储数据，一页中可以存储更多的指针，因此在相同数据量情况下，B+树的层级更浅，检索速度更快，另外由于B+树只在叶子节点存储数据，因此搜索效率稳定，而且叶子节点形成了一个双向链表，范围查询更加高效<li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</ul><h1 id="索引分类">索引分类</h1><div class="table-wrapper"><table><thead><tr><th>分类<th>含义<th>特点<th>关键字<tbody><tr><td>主键索引<td>针对于表中主键创建的索引<td>默认自动创建，只能有一个<td>PRIMARY<tr><td>唯一索引<td>避免同一个表中某数据列中的值重复<td>可以有多个<td>UNIQUE<tr><td>常规索引<td>快速定位特定数据<td>可以有多个<td> <tr><td>全文索引<td>全文索引查找的是文本中的关键词，而不是比较索引中的值<td>可以有多个<td>FULLTEXT</table></div><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><div class="table-wrapper"><table><thead><tr><th>分类<th>含义<th>特点<tbody><tr><td>聚集索引(Clustered Index)<td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据<td>必须有，而且只有一个<tr><td>二级索引(Secondary Index)<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键<td>可以存在多个</table></div><p>演示图：</p><p><img data-src="https://dhc.pythonanywhere.com/media/editor/原理图_20220318194454880073.png" alt="大致原理" title="大致原理" data-proofer-ignore> <img data-src="https://dhc.pythonanywhere.com/media/editor/演示图_20220319215403721066.png" alt="演示图" title="演示图" data-proofer-ignore></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引<li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</ul><h2 id="思考题">思考题<a href="#思考题" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Arm'</span><span class="p">;</span>
<span class="c1">-- 备注：id为主键，name字段创建的有索引</span>
</pre></table></code></div></div><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8. 可得公式：<code class="language-plaintext highlighter-rouge">n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code class="language-plaintext highlighter-rouge">1171 * 16 = 18736</code>； 如果树的高度为3，那么他能存储的数据量大概为：<code class="language-plaintext highlighter-rouge">1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h1 id="索引语法">索引语法</h1><p>创建索引：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">create</span> <span class="p">[</span> <span class="k">unique</span> <span class="o">|</span> <span class="n">fulltext</span> <span class="p">]</span> <span class="k">index</span> <span class="n">index_name</span> <span class="k">on</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">index_col_name</span><span class="p">,</span> <span class="p">...);</span>
</pre></table></code></div></div><p>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引，如果关联多个字段，建立的就是联合索引</p><p>查看索引： <code class="language-plaintext highlighter-rouge">SHOW INDEX FROM table_name;</code></p><p>删除索引： <code class="language-plaintext highlighter-rouge">DROP INDEX index_name ON table_name;</code></p><p>案例：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span>
<span class="k">create</span> <span class="k">index</span> <span class="n">idx_user_name</span> <span class="k">on</span> <span class="n">tb_user</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="c1">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span>
<span class="k">create</span> <span class="k">unique</span> <span class="k">index</span> <span class="n">idx_user_phone</span> <span class="k">on</span> <span class="n">tb_user</span> <span class="p">(</span><span class="n">phone</span><span class="p">);</span>
<span class="c1">-- 为profession, age, status创建联合索引</span>
<span class="k">create</span> <span class="k">index</span> <span class="n">idx_user_pro_age_stat</span> <span class="k">on</span> <span class="n">tb_user</span><span class="p">(</span><span class="n">profession</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="c1">-- 为email建立合适的索引来提升查询效率</span>
<span class="k">create</span> <span class="k">index</span> <span class="n">idx_user_email</span> <span class="k">on</span> <span class="n">tb_user</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>

<span class="c1">-- 删除索引</span>
<span class="k">drop</span> <span class="k">index</span> <span class="n">idx_user_email</span> <span class="k">on</span> <span class="n">tb_user</span><span class="p">;</span>
</pre></table></code></div></div><h1 id="sql性能分析">SQL性能分析</h1><h2 id="sql执行频次">SQL执行频次<a href="#sql执行频次" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p>为什么要查询SQL执行频次? SQL优化主要对查询语句进行优化，如果数据库的查询语句频次远小于增删改的频次，就没必要进行SQL优化了</p></blockquote><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br /> <code class="language-plaintext highlighter-rouge">SHOW GLOBAL STATUS LIKE 'Com_______';</code> 或者 <code class="language-plaintext highlighter-rouge">SHOW SESSION STATUS LIKE 'Com_______';</code></p><p><img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271631404.png" alt="查询效果图" title="查询效果图" data-proofer-ignore></p><h2 id="慢查询日志">慢查询日志<a href="#慢查询日志" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p>慢查询日志为我们定位出那些SQL查询语句效率比较低</p></blockquote><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。 MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf，这也是Linux系统位置）中配置如下信息：<br /></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre># 开启慢查询日志开关
slow_query_log=1
# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
</pre></table></code></div></div><p>更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log（Linux系统位置）</p><p>查看慢查询日志开关状态： <code class="language-plaintext highlighter-rouge">show variables like 'slow_query_log';</code></p><p><img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271647260.png" alt="慢查询效果图" title="慢查询效果图" data-proofer-ignore></p><h2 id="show-profiles">show profiles<a href="#show-profiles" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p>慢查询需要我们指定long_query_time，相对来说不太灵活，实际上有些sql虽然小于long_query_time，但也需要优化，于是通过show profiles我们可以查询任意一条SQL语句执行耗时的详细情况</p></blockquote><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。<br /> 1.通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<code class="language-plaintext highlighter-rouge">SELECT @@have_profiling;</code><br /> 2.profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：<code class="language-plaintext highlighter-rouge">SET [session/global] profiling = 1;</code><br /> 3.查看所有语句的耗时：<code class="language-plaintext highlighter-rouge">show profiles;</code><br /> 4.查看指定query_id的SQL语句各个阶段的耗时：<code class="language-plaintext highlighter-rouge">show profile for query query_id;</code><br /> 5.查看指定query_id的SQL语句CPU的使用情况：<code class="language-plaintext highlighter-rouge">show profile cpu for query query_id;</code></p><p><img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202206271655525.png" alt="show profiles效果图" title="show profiles效果图" data-proofer-ignore></p><h2 id="explain">explain<a href="#explain" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p>前面介绍的慢查询和show profiles都是单纯从时间判断一条SQL是否需要优化，而实际上不仅仅是执行时间，语句是否使用索引，多表查询中表的连接顺序等等也是判断的标准，而explain就能获取到这些信息</p></blockquote><p>EXPLAIN或者DESC命令获取select语句的执行计划</p><p>语法：<br /></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre># 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;
</pre></table></code></div></div><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）<li>select_type：表示 SELECT 的类型，常见取值有SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等（<strong>参考意义不大</strong>）<li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all（<strong>比较重要，根据主键或唯一索引查询一般为const，如果是非唯一索引则一般是ref，all是全表扫描，index表示用了索引但扫描了所有索引</strong>）<li>possible_keys：可能应用在这张表上的索引，一个或多个<li>Key：实际使用的索引，如果为 NULL，则没有使用索引<li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好，也就是说索引字段尽量占用空间少<li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的<li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好<li>Extra：前面字段没有展示的信息会在Extra中展示</ul><p><strong>总结：开发人员进行SQL优化时最主要关注的就是explain，而在explain中我们主要关注type，possible_keys、key、key_len和Extra这几个字段</strong></p><h1 id="使用规则">使用规则</h1><h2 id="最左前缀法则主要针对联合索引">最左前缀法则(主要针对联合索引)<a href="#最左前缀法则主要针对联合索引" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>如果索引关联了多列（联合索引），要遵守最左前缀法则（即索引最左列必须存在），最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p><strong>注意：是最左边的列一定要存在，与其在查询中出现的位置并无关</strong>，例如：<br /></p><div class="language-sql highlighter-rouge"><div class="code-header"> <span label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">create</span> <span class="k">index</span> <span class="n">idx_user_pro_age_status</span> <span class="k">on</span> <span class="k">user</span><span class="p">(</span><span class="n">profession</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="c1">-- idx_user_pro_age_status在下面这条SQL查询中会生效的，因为在where中profession条件是存在的</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">age</span><span class="o">=</span><span class="mi">31</span> <span class="k">and</span> <span class="n">status</span><span class="o">=</span><span class="s1">'0'</span> <span class="k">and</span> <span class="n">profession</span> <span class="o">=</span> <span class="s1">'软件工程'</span><span class="p">;</span> 
</pre></table></code></div></div><h2 id="范围查询也是针对联合索引">范围查询(也是针对联合索引)<a href="#范围查询也是针对联合索引" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。例如下图：<br /> <img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202207032345358.png" alt="范围查询" title="范围查询" data-proofer-ignore></p><p><strong>这里我有个问题，要是把范围查询的索引部分放在最右，那么会有索引失效吗</strong></p><h2 id="索引失效情况">索引失效情况<a href="#索引失效情况" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="索引列进行运算操作">索引列进行运算操作<a href="#索引列进行运算操作" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>在索引列上进行运算操作，索引将失效。如下图示：<br /> <img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202207032351036.png" alt="索引列运算操作" title="索引列运算操作" data-proofer-ignore></p><h3 id="字符串不加引号">字符串不加引号<a href="#字符串不加引号" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>字符串类型字段使用时，不加引号，索引将失效。如：<code class="language-plaintext highlighter-rouge">explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号，phone字段上建立的索引会失效<br /> <strong>注意：对联合索引也是一样的，如果联合索引某个字段值是字符串，但未加引号，这个字段上的索引会失效</strong></p><h3 id="头部模糊匹配">头部模糊匹配<a href="#头部模糊匹配" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>模糊查询中，如果仅仅是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引失效。如：<code class="language-plaintext highlighter-rouge">explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。</p><h3 id="or连接的条件">or连接的条件<a href="#or连接的条件" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。<strong>就算其中一个列是主键，也会失效，这时会进行全表扫描，性能最差，当然如果索引失效，走的自然是全表扫描</strong>，如下图：<br /> <img data-src="https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202207040005703.png" alt="or连接的条件" title="or连接的条件" data-proofer-ignore></p><h3 id="数据分布影响">数据分布影响<a href="#数据分布影响" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>如果MySQL的优化器评估使用索引比全表更慢，则不使用索引。<strong>一般如果一条查询一定会走全表扫描，或者要扫描表的大部分，MySQL优化器会评估直接使用全表扫描，毕竟省去了翻目录的时间</strong></p><h2 id="sql-提示">SQL 提示<a href="#sql-提示" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如：<br /> 1.建议使用索引，use index：<br /> <code class="language-plaintext highlighter-rouge">explain select * from tb_user use index(idx_user_pro) where profession="软件工程";</code></p><p>2.不使用哪个索引，ignore index：<br /> <code class="language-plaintext highlighter-rouge">explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";</code></p><p>3.必须使用哪个索引，force index：<br /> <code class="language-plaintext highlighter-rouge">explain select * from tb_user force index(idx_user_pro) where profession="软件工程";</code></p><blockquote><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p></blockquote><h2 id="覆盖索引回表查询">覆盖索引&amp;回表查询<a href="#覆盖索引回表查询" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），尽量减少 select *。</p><p>通过Extra中展示的值，能够区分出查询是否回表查询（<strong>注意：Extra在不同的MySQL版本，展示的值会不一样</strong>）</p><blockquote><p>explain 中 Extra 字段含义：<br /></p><ol><li><code class="language-plaintext highlighter-rouge">using index condition</code>：查找使用了索引，但是需要回表查询数据<br /><li><code class="language-plaintext highlighter-rouge">using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</ol></blockquote><p>如何利用辅助索引（二级索引）优化SQL：<br /> 1.如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；<br /> 2.如果在辅助索引中找聚集索引，如<code class="language-plaintext highlighter-rouge">select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；<br /> 3.如果是通过辅助索引查找其他字段，则需要回表查询，如<code class="language-plaintext highlighter-rouge">select id, name, gender from xxx where name='xxx';</code><br /> <strong>所以尽量不要用<code class="language-plaintext highlighter-rouge">select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</strong></p><blockquote><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： <code class="language-plaintext highlighter-rouge">select id, username, password from tb_user where username='itcast';</code><br /> 解：<br />1. 给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引<br /></p><ol><li>或者击中缓存</ol></blockquote><h2 id="前缀索引">前缀索引<a href="#前缀索引" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code class="language-plaintext highlighter-rouge">create index idx_xxxx on table_name(columnn(n));</code> 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">email</span><span class="p">)</span> <span class="o">/</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">tb_user</span><span class="p">;</span>
<span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="k">substring</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">tb_user</span><span class="p">;</span>
</pre></table></code></div></div><p>show index 里面的sub_part可以看到接取的长度</p><h2 id="单列索引联合索引">单列索引&amp;联合索引<a href="#单列索引联合索引" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>单列索引：即一个索引只包含单个列<br /> 联合索引：即一个索引包含了多个列<br /> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况： <code class="language-plaintext highlighter-rouge">explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code> 这句只会用到phone索引字段，如果name字段也建立了索引，MySQL只会使用两者中的一个，MySQL会判断name和phone谁的索引查询效率高从而选择效率高的，</p><p><strong>注意：<br /> 1.多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询<br /> 2.单列索引和联合索引都属于二级索引</strong></p><h1 id="设计原则">设计原则</h1><ol><li>针对于数据量较大，且查询比较频繁的表建立索引<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高<li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</ol><h1 id="问题保留">问题保留</h1><p>1.索引是如何被加载进入内存的，按页？按区？还是按段？</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/'>数据库</a>, <a href='/categories/mysql/'>MySQL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=索引 - flameking&url=https://casflawed.github.io/posts/%E7%B4%A2%E5%BC%95/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=索引 - flameking&u=https://casflawed.github.io/posts/%E7%B4%A2%E5%BC%95/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=索引 - flameking&url=https://casflawed.github.io/posts/%E7%B4%A2%E5%BC%95/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E7%A7%AF%E5%88%86%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1/">积分体系设计</a><li><a href="/posts/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/">支付宝支付功能实践</a><li><a href="/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/">分布式定时任务功能实现</a><li><a href="/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a><li><a href="/posts/Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">Spring 事务管理</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%B3%A8%E8%A7%A3/">注解</a> <a class="post-tag" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a> <a class="post-tag" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/%E5%B0%81%E8%A3%85/">封装</a> <a class="post-tag" href="/tags/cglib/">CGLIB</a> <a class="post-tag" href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">lambda表达式</a> <a class="post-tag" href="/tags/litepal/">litepal</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E5%A6%82%E4%BD%95%E8%AE%A9MySQL%E6%94%AF%E6%8C%81emoji%E5%AD%97%E7%AC%A6/"><div class="card-body"> <em class="timeago small" date="2022-08-23 00:00:00 +0800" >2022-08-23</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>如何让MySQL支持emoji字符</h3><div class="text-muted small"><p> 以Windows系统，MySQL5.7.33版本为例 第一种方法：修改数据库配置文件（已经实践有效） 在MySQL文件目录下，找到mysql.ini配置文件，将其中的内容替换为下面的内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 [cl...</p></div></div></a></div><div class="card"> <a href="/posts/SQL%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"><div class="card-body"> <em class="timeago small" date="2022-09-09 00:00:00 +0800" >2022-09-09</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>SQL专项练习</h3><div class="text-muted small"><p> LeetCode-SQL入门专题 595. 大的国家 考点：简单的where条件筛选 1 2 select name, population, area from World where area &amp;gt;= 3000000 or population &amp;gt;= 25000000; 1757. 可回收且低脂的产品 考点：where的特殊语法：where (low_fats,...</p></div></div></a></div><div class="card"> <a href="/posts/SQL%E5%88%86%E7%B1%BB/"><div class="card-body"> <em class="timeago small" date="2022-03-05 00:00:00 +0800" >2022-03-05</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>SQL分类</h3><div class="text-muted small"><p> SQL SQL语句通用语法 1.SQL语句可单行也可多行书写，以分号结尾。 2.SQL关键词应该大写，统一规范 SQL分类 DDL 数据库操作 查询所有数据库 mysql&amp;gt; show databases; 创建数据库 mysql&amp;gt; create database [if not exists] test_db [default charset utf8mb4]; 注...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="btn btn-outline-primary" prompt="上一篇"><p>存储引擎</p></a> <a href="/posts/CSS%E5%88%9D%E5%A7%8B%E5%8C%96/" class="btn btn-outline-primary" prompt="下一篇"><p>CSS初始化</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Casflawed">flameking</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%B3%A8%E8%A7%A3/">注解</a> <a class="post-tag" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a> <a class="post-tag" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/%E5%B0%81%E8%A3%85/">封装</a> <a class="post-tag" href="/tags/cglib/">CGLIB</a> <a class="post-tag" href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">lambda表达式</a> <a class="post-tag" href="/tags/litepal/">litepal</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
