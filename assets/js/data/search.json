[ { "title": "线上优化经验", "url": "/posts/%E7%BA%BF%E4%B8%8A%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/", "categories": "项目, 商场停车", "tags": "", "date": "2023-05-05 00:00:00 +0800", "snippet": "从2s到0.1s！一次显著的商品分类树查询优化，够优雅！" }, { "title": "订单功能模块", "url": "/posts/%E8%AE%A2%E5%8D%95%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97-%E5%89%AF%E6%9C%AC/", "categories": "项目, 商场停车", "tags": "", "date": "2023-05-05 00:00:00 +0800", "snippet": "优惠券订单在多组织架构下加入优惠券系统的必要性在多组织架构下加入优惠券系统是非常必要的，因为优惠券系统可以帮助组织吸引并留住客户，提高销售额和同行竞争力。通常优惠券系统可以在下列方面提供显著帮助： 促进销售增长：优惠券可以激励客户购买更多的产品或服务，从而实现销售增长。通过在不同的组织之间进行优惠券的分享和兑换，可以进一步扩大销售范围并增加客户数量。 提高品牌忠诚度：优惠券系统可以使客户感到被重视，提高客户的满意度和忠诚度。这对于长期发展品牌和巩固市场地位非常重要。 精准定位客户：通过优惠券系统收集客户的消费习惯和兴趣爱好，可以更好地理解客户需求和购买意愿，实现更精准的客户定位和营销。 节约成本：通过优惠券系统，可以实现更精细的营销策略，同时减少广告和促销成本。另外，优惠券系统还可以帮助组织管理库存和销售数据，实现成本节约和效率提高。综合以上几点，可以看出在多组织架构下加入优惠券系统的必要性非常大，而智慧停车场管理系统作为平台为了提升自身的竞争力，加入优惠券系统也是非常必要的。如何设计优惠券作为一种经典的促销手段，有两种类型：平价券和秒杀券。它们的主要区别在于促销的形式和目的。平价券通常是一种固定金额或折扣幅度的优惠券，一般适用于所有商品或一定范围内的商品。客户可以在下单时输入优惠码或者点击相关链接进行领取，使订单金额直接减少优惠金额或折扣后的金额。平价券一般适用于需要推广的商品或需要促销的活动，它通过高折扣的方式吸引客户，达到促销的目的。秒杀券则是一种时间限制性的优惠券，主要目的是推动销售和清理库存。秒杀券会设定一个非常低的价格，并且限定一定时间内销售，一旦时间耗尽或者库存被抢购完毕，秒杀活动就会结束。客户可以通过在设定的时间范围内进入特定的页面或链接来抢购秒杀商品。秒杀券一般适用于滞销商品或过季商品，其目的在于通过低价促销的方式清除库存，同时也可以提升客户的购物满足感和留存热度。综上根据优惠券的概念和需求设计的表结构如下：有了表结构就可以设计我们的实体模型，然后就能完成基本的额增删改查业务了。停车场可以适时发布自己的优惠券吸引用户消费，而用户则需要针对平价券或者秒杀券进行抢购。而购买优惠券和购买普通的商品流程是一样的，首先需要下订单，然后去支付，再进行使用。因此应用中还应存在一张优惠券订单表：而针对秒杀券业务则较为复杂，需要重点解释。首先是秒杀券的下单业务流程，由于秒杀券往往是促销和减库存，因此优惠力度一般比较大，因此它不会像评价券一样无限制购买，一般会限定数量。同时会再限定时间段开始，并且售完即终止。因此下单时需要判断两点： 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单 库存是否充足，不足则无法下单下面是具体业务流程：按照业务流程实现时还需注意一些问题： 多线程并发下库存超卖的问题 乐观锁失败率高如何解决 如何保证一人一单 悲观锁实现一人一单但事务失效的问题库存超卖该如何解决什么是库存超卖问题：库存超卖是电子商务中常见的问题，它指的是在电商平台上卖家所提供的某一个商品的库存数量已经不足，但是，由于种种原因(比如系统数据更新延迟等)，仍在平台上继续销售并接受用户的下单，最终导致实际库存已经不足以满足所有订单的情况。这时，平台和卖家将面临未能交货或延迟交货的情况，给顾客带来极大的不便和巨大的损失，对于电商的品牌形象和信誉带来很大的打击。库存超卖是一个非常严重的问题，不仅会影响卖家和买家之间的交易，还会对电商平台的声誉产生负面影响，损害品牌形象。因此，对于电商平台和卖家来说，很有必要及时管理和更新库存数据，避免库存超卖的情况发生，促进在线交易的良性发展。秒杀券库存超卖出现的原因：秒杀是指在特定时间内对于特定商品进行特价销售的活动，其特点是时间短、价格优惠极大、商品数量有限等。在这种场景下，会出现较高的用户流量和系统并发量，因此需要具备一定的系统可靠性和稳定性。因此在这种情况下并发问题出现的非常频繁，而超卖问题就是一种典型并发问题。库存超卖是指销售平台上的商品库存数量与实际库存数量不一致，导致一些顾客购买的商品实际上已经售罄或不存在。从高并发的角度来看，库存超卖出现的原因可能是因为并发量过大，系统无法及时地将一个订单的状态及时更新到库存中，导致同一时间多个顾客都可以购买同一个已售罄的商品。从而出现库存超卖。当系统面对大量的并发请求时，需要处理大量的订单信息、库存信息、支付信息等，这需要消耗大量的计算资源和存储资源。如果系统无法及时地响应请求或处理数据，就容易出现数据不一致的情况，从而导致库存超卖的发生。因此，在系统设计和架构方面，应该考虑如何提高系统的性能和吞吐量，避免因高并发而导致的库存超卖等问题的发生。这种情况下有一种常见的解决方案，乐观锁方案乐观锁解决库存超卖问题什么是乐观锁：认为现场安全问题不一定会发生，因此不加锁，只是再更新数据时去判断有没有其他线程对数据做了修改。 如果没有修改则认为是安全的，自己才更新数据 如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常说到乐观锁就不得不说明一下悲观锁，两种解决方案是一种相反的设计理念，悲观锁认为：线程安全问题一定会发生，因此再操作数据之前先获取锁，确保线程串行执行，例如 Synchronized 和 Lock 都属于悲观锁乐观锁的常见实现方案有两种： 版本号法 CAS法CAS 是根据情景对版本号法做了简化。将乐观锁整合进应用确实能够解决超卖问题，但是却产生了新的问题，乐观锁解决方案会造成抢购失败率较高如何解决抢购失败率较高的问题以库存为例，乐观锁的关键是判断之前查到的库存数据是否被修改过，原来是保持一致，实际可以以 stock &amp;gt; 0 为条件，这样就能减少秒杀失败率低的问题。如何保证一人一单在实现秒杀业务时，这种一人一单的限制是非常关键的，因为秒杀业务具有高并发和短时间内大量交易的特点，如果没有这种限制，很容易导致库存被少数人大量占用，让更多的顾客失去机会，并引起品牌形象的损害。因此，针对秒杀业务的实现，需要在系统中引入一些限流措施，确保每个顾客只能购买一次，并且库存数量能够得到及时的更新。那么如何实现呢？一人一单业务逻辑如下：实现方式也是以先查询再修改的形式，不过这次是插入。因此依然会出现并发问题，即同一个用户可能下多个订单。不同于先查询再修改的形式，插入无法使用乐观锁，因此必须使用悲观锁的解决方案如何使用悲观锁保证一人一单 不能锁方法，锁方法就是锁 this，那么每个新用户都会被锁住，实际上只需让同一个用户多次访问时被锁住就行了，这里需要锁 userId.intern()，intern() 代表使用常量池 由于加了事务，事务是再方法返回时提交，而之前并没有锁整个方法，导致可能订单未插入同一个用户却已经多次查询并插入多条订单了，因此需要锁定整个方法调用 锁方法调用事务没有生效，this.method 的 this 并不是代理对象，而事务使用 aop 实现的，因此实际应该用 proxy.method 调用，才能触发 @trasactional 事务回滚这样一个人只能创建一个订单就完成了。停车缴费订单每次根据计费规则查询费用时自动生成缴费订单。如果用户充值了钱包就自动扣费。" }, { "title": "分布式定时任务功能实现", "url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/", "categories": "项目, 商场停车", "tags": "", "date": "2023-05-05 00:00:00 +0800", "snippet": "定时任务在智慧停车业务中的必要性定时任务可以在指定的时间或间隔内周期性地执行一些任务，可以实现很多有用的功能。在智慧停车业务中，定时任务可以用来： 停车场车位信息的更新：定时任务可以周期性地从停车场管理系统获取车位信息，然后更新到智慧停车系统中，确保智慧停车系统中的车位信息与实际情况一致。 费用结算：定时任务可以根据停车场收费标准，结算停车费用，并将费用信息存入数据库。（这块的功能就很像滴滴打车订单完成后自动完成扣费） 数据统计分析：定时任务可以定期对停车场数据进行分析和统计，生成各种报表，帮助停车场管理者更好地了解停车场的使用情况。 车辆预约和通知：定时任务可以在预约时间到达时自动发送预约通知，以提醒用户前来停车，并保证车位的预留。因此在我的系统中，将其独立为一个模块，便于后期将各种功能集成进来。定时任务的选型方案常见的定时任务的解决方案有以下几种：右半部分基于 Java 或 Spring 框架即可支持定时任务的开发运行，左侧部分需要引入第三方框架支持。不同的方案有不同的要求和特点： XXL-JOB 是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。任务调度与任务执行分离，功能很丰富，在多家公司商业产品中已有应用。 Elastic-Job 是一个分布式调度解决方案，由两个相互独立的子项目 Elastic-Job-Lite 和 Elastic-Job-Cloud 组成。Elastic-Job-Lite 定位为轻量级无中心化解决方案，依赖 Zookeeper ，使用 jar 包的形式提供分布式任务的协调服务，之前是当当网 Java 应用框架 ddframe 框架中的一部分，后分离出来独立发展。 Quartz 算是定时任务领域的老牌框架了，出自 OpenSymphony 开源组织，完全由 Java 编写，提供内存作业存储和数据库作业存储两种方式。在分布式任务调度时，数据库作业存储在服务器关闭或重启时，任务信息都不会丢失，在集群环境有很好的可用性。 淘宝出品的 TBSchedule 是一个简洁的分布式任务调度引擎，基于 Zookeeper 纯 Java 实现，调度与执行同样是分离的，调度端可以控制、监控任务执行状态，可以让任务能够被动态的分配到多个主机的 JVM 中的不同线程组中并行执行，保证任务能够不重复、不遗漏的执行。 Timer 和 TimerTask 是 Java 基础组件库的两个类，简单的任务尚可应用，但涉及到的复杂任务时，建议选择其它方案。 ScheduledExecutorService 在 ExecutorService 提供的功能之上再增加了延迟和定期执行任务的功能。虽然有定时执行的功能，但往往大家不选择它作为定时任务的选型方案。 [@EnableScheduling] 以注解的形式开启定时任务，依赖 Spring 框架，使用简单，无须 xml 配置。特别是使用 Spring Boot 框架时，更加方便。引入第三方分布式框架会增加项目复杂度，Timer、TimerTask 比较简单无法符合复杂的分布式定时任务，而基于注解的 @EnableScheduling 定时任务方案操作简单使用方面，功能方面也能完全胜任应用的需求。综上智慧停车场管理系统将采用基于注解的 @EnableScheduling 定时任务方案微服务架构环境下定时任务存在的问题一个简单的定时任务项目实现起来非常简单，但我们创建一个模块拥有一个启动类，在启动类加上 @EnableScheduling 注解就代表定时任务功能已经启用：@SpringBootApplication@EnableSchedulingpublic class ParkingScheduleJobApplication { public static void main(String[] args) { SpringApplication.run(ParkingScheduleJobApplication.class, args); }}然后专注设计自己的定时任务执行类就可以了，只需要用 @Scheduled 加上 cron 表达式就能定制自己的定时任务，并被系统自动识别，并按要求执行：@Component@Slf4jpublic class UserBirthdayBasedPushTask { //每隔 5s 输出一次日志 @Scheduled(cron = &quot; 0/5 * * * * ?&quot;) public void scheduledTask() { log.info(&quot;Task running at = &quot; + LocalDateTime.now()); }}比如每隔 5s 输出一次日志。但是这会存在一种情况，我我们的应用进行了多实例部署，那么这样一段定时任务执行代码就会被重复执行，而重复执行会导致数据的混乱或糟糕的用户体验，比如本次基于会员生日推送营销短信/邮件时，用户会被短信/邮件轰炸，这肯定不是我们想看到的。即使部署了多代码实例，任务在同一时刻应当执行一次才是符合正常逻辑的，而不能因为实例的增多，导致执行次数增多。那么该如何解决呢？分布式定时任务保证任务在同一时刻只有执行，就需要每个实例执行前拿到一个令牌，谁拥有令牌谁有执行任务，其它没有令牌的不能执行任务，通过数据库记录就可以达到这个目的。上面两种方案是一个演化的关系，A 相比于 B 方案存在漏洞：当 select 指定记录后，再去 update 时，存在时间间隙，因为 select 操作并不会加行锁，因此会导致多个实例同时执行任务，而 B 方案通过 update 更新操作的返回值 1 或者 0 能避免多个实例同时执行任务。返回 1 则当前任务执行，而其他实例的定时任务则不会执行。实际上这套实现逻辑并不需要自己实现，有现成的方案可以使用：ShedLock，可以使我们的定时任务在同一时刻，最多执行一次。ShedLock 使用方法： 引入 ShedLock 的 jar 包：&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.javacrumbs.shedlock&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shedlock-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.javacrumbs.shedlock&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shedlock-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.javacrumbs.shedlock&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shedlock-provider-jdbc-template&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt; 启动类新增 @EnableSchedulerLock 注解，以及打开 ShedLock 获取锁的支持。这里需要引入 spring-jdbc 的 jar 包。@SpringBootApplication@EnableScheduling@EnableSchedulerLock(defaultLockAtMostFor = &quot;30s&quot;)public class ParkingScheduleJobApplication { public static void main(String[] args) { SpringApplication.run(ParkingScheduleJobApplication.class, args); } @Bean //基于 Jdbc 的方式提供的锁机制 public LockProvider lockProvider(DataSource dataSource) { return new JdbcTemplateLockProvider(dataSource); }} 任务执行类的方法上，同样增加 @SchedulerLock 注解，并声明定时任务锁的名称，如果有多个定时任务，要确保名称的唯一性。@Component@Slf4jpublic class UserBirthdayBasedPushTask { //每隔 5s 输出一次日志 @Scheduled(cron = &quot; 0/5 * * * * ?&quot;) @SchedulerLock(name = &quot;scheduledTask&quot;) public void scheduledTask() { log.info(&quot;Task running at = &quot; + LocalDateTime.now()); }} 新增名为 shedlock 的数据库，并新建 shedlock 数据表，表结构如下：做完这些步骤，定时任务的初步框架构建完成。定时任务实现根据用户的生日推送营销短信/邮件的功能考虑到发送短信的实现方案较为复杂，在应用中用发送邮件代替。首先需要获取用户的生日信息，而它们放在 parking-member 模块当中，因此需要采用 Feign 的方式远程调用对应的方法，编写对应的 MemberClient 接口：@FeignClient(&quot;parking-member&quot;)public interface MemberClient { /** * 获取会员信息列表 */ @GetMapping(&quot;/api/member/list&quot;) CommonResult&amp;lt;List&amp;lt;MemberDTO&amp;gt;&amp;gt; getList();}在对应的执行任务类中编写需要的业务逻辑，这将会用到会员信息，因为需要根据用户在注册账号时填写的出生年月判断当天是否会员的生日。@Scheduled(cron = &quot; 0/5 * * * * ?&quot;)@SchedulerLock(name = &quot;UserBirthdayBasedPushTask&quot;)public void scheduledTask() { CommonResult&amp;lt;List&amp;lt;MemberDTO&amp;gt;&amp;gt; res = memberClient.getList(); if (res.getCode() == 200) { List&amp;lt;MemberDTO&amp;gt; members = res.getData(); for (MemberDTO m : members) { //已认证邮箱 if (!StringUtils.isEmpty(m.getEmail())) { //获取当前日期 DateTimeFormatter df = DateTimeFormatter.ofPattern(&quot;MM-dd&quot;); String curDate = df.format(LocalDate.now()); //用户填写了生日信息，并且当天生日 if (!StringUtils.isEmpty(m.getBirth()) &amp;amp;&amp;amp; m.getBirth().substring(5).equals(curDate)){ //发送生日祝福邮箱 Context context = new Context(); context.setVariable(&quot;username&quot;, m.getFullName()); String content = templateEngine.process(&quot;/email/birth&quot;, context); mailUtil.sendMail(m.getEmail(), &quot;生日祝福&quot;, content); log.info(&quot;已向会员[{}]发送生日祝福邮箱&quot;, m.getFullName()); } } } }}这样功能即完成了。：" }, { "title": "停车计费功能实践", "url": "/posts/%E5%81%9C%E8%BD%A6%E8%AE%A1%E8%B4%B9%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/", "categories": "项目, 商场停车", "tags": "", "date": "2023-05-05 00:00:00 +0800", "snippet": "如何设计停车计费功能在智慧停车场管理系统中，同可用停车位一样计费规则几乎是每辆车进出停车场都会用到，而这种数据俗称称为热数据，读关系库显然不是最优解，引入缓存才是王道。分布式缓存缓存作为互联网分布式开发两大杀器之一（另一个是消息队列），应用场景相当广泛，遇到高并发、高性能的案例，几乎都能看到缓存的身影。从应用与缓存的结合角度来区分可以分为本地缓存和分布式缓存。我们经常用 Tomcat 作为应用服务，用户的 session 会话存储，其实就是缓存，只不过是本地缓存，如果需要实现跨 Tomcat 的会话应用，还需要其它组件的配合。Java 中我们应经用到的 HashMap 或者 ConcurrentHashMap 两个对象存储，也是本地缓存的一种形式。Ehcache 和 Google Guava Cache 这两个组件也都能实现本地缓存。单体应用中应用的比较多，优势很明显，访问速度极快；劣势也很明显，不能跨实例，容量有限制。分布式场景下，本地缓存的劣势表现的更为突出，与之对应的分布式缓存则更能胜任这个角色。软件应用与缓存分离，多个应用间可以共享缓存，容量扩充相对简便。有两个开源分布式缓存产品：memcached 和 Redis。其中 memcached 是出现比较早的缓存产品，只支持基础的 key-value 键值存储，数据结构类型比较单一，不提供持久化功能，发生故障重启后无法恢复，它本身没有成功的分布式解决方案，需要借助于其它组件来完成。Redis 的出现，直接碾压 memcached ，市场占有率节节攀升。Redis 在高效提供缓存的同时，也支持持久化，在故障恢复时数据得已保留恢复。支持的数据类型更为丰富，如 string , list , set , sorted set , hash 等，Redis 自身提供集群方案，也可以通过第三方组件实现，比如 Twemproxy 或者 Codis 等等，在实际的产品应用中占有很大的比重。另外 Redis 的客户端资源相当丰富，支持近 50 种开发语言。综上所述，我最终选择 Redis 应用到智慧停车场系统中。搭建线上 Redis 环境下载好 Redis 之后，文件目录如下所示：下载完成之后，首先需要对 Redis 进行配置，而 Redis 的配置是放在一个叫做 redis.conf 的文件里： 修改 bind 127.0.0.1 -::1 –&amp;gt; bind 0.0.0.0，这一步的作用是让 Redis 能够接收来自任何网络的请求。这就保证我们的应用能够正常访问 Redis 然后是修改 protected-mode yes –&amp;gt; protected-mode no，这一步的作用是关闭 Redis 的自我保护，Redis 的自我保护会拒绝一些匿名的访问。 再然后是修改 daemonize no –&amp;gt; daemonize yes，这能让我们的 Redis 在服务器后台运行，不至于关闭控制台就被停止运行。然后是比较关键的两步，上面的操作都是对 Redis 本身的配置进行修改，现在需要修改我的服务器配置：首先是防火墙设置，允许对应端口号的开放，而 Redis 设置的端口号是 6379：然后是第二步，也是最容易忽视的一步，在 shell 上开启防火墙端口：命令：firewall-cmd –zone=public –add-port=6379/tcp –permanent，意思是永久开启防火墙 6379 端口。然后执行命令：firewall-cmd –list-ports 能够查看到下面的效果：这表明 6379 端口已被放行，接下来我们的应用访问 Redis 线上服务就没有问题了。在程序中连接 Redis 服务首先引入 Redis 对应的包：&amp;lt;!-- 集成 redis --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;&amp;lt;/dependency&amp;gt;然后进行 Redis 连接配置：spring: redis: database: 0 host: 175.178.236.7 port: 6379 password: 123456 timeout: 60000 jedis: pool: max-active: 1000 max-wait: -1 max-idle: 10 min-idle: 5其中： database 配置应用模块使用 Redis 的哪个库 host 是 Redis 线上服务的地址 port 是 Redis 的端口号 password 是 Redis 的访问密码 timeout 是访问 Redis 的超时时间 jedis 是 Redis 客户端，pool 是连接池的一些配置除了配置文件，还需要在代码中读入配置，连接线上 Redis 服务，而 Redis 的默认序列化方式往往满足不了生产的需要，所以通常需要自定义 Redis 的序列化方式。/** * 自定义 Redis 序列化方式 */public RedisCacheAutoConfiguration() { ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); JavaTimeModule timeModule = new JavaTimeModule(); timeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))); timeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))); timeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))); timeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))); objectMapper.registerModule(timeModule); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer(objectMapper);}然后是执行连接 Redis 服务的代码：/** * 注入 RedisTemplate */@Primary@Beanpublic RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate() { // 指定序列化方式 RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate = new RedisTemplate&amp;lt;&amp;gt;(); redisTemplate.setKeySerializer(RedisSerializer.string()); redisTemplate.setHashKeySerializer(RedisSerializer.string()); redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer); redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer); redisTemplate.setConnectionFactory(redisConnectionFactory()); return redisTemplate;}设计停车计费数据表里面的核心字段就只有三个，分别是 stay_time_start、stay_time_end 和 fee，其两个是用来比较车主停车的时间从而判断停车费用，而对应的费用就是用 fee 标注好的。下面是预插入的数据： 30分钟内免费 2小时内，5元 2小时以上12小时以内，10元 12小时以上24小时以内，20元然后是最核心的一步，将上面的数据读入 Redis 当中，而且是要在项目第一次使用时就加载到 Redis 当中去。项目启动后就加载，Spring Boot 提供了两种方式在项目启动时就加载的方式供大家使用：ApplicationRunner 与 CommandLineRunner，都是在 Spring 容器初始化完毕之后执行起 run 方法，两者最明显的区别就是入参不同。我采用的是 ApplicationRunner 方式：import static com.flameking.parking.charging.constants.ChargingConstant.CHARGING_RULE;@Component@Order(value = 1)//order 是加载顺序，越小加载越早，若有依赖关于，建议按顺序排列即可public class StartUpApplicationRunner implements ApplicationRunner { @Autowired private RedisClient redisClient; @Autowired IChargingRuleService ruleService; @Override public void run(ApplicationArguments args) throws Exception { List&amp;lt;ChargingRule&amp;gt; rules = ruleService.list(); if (!redisClient.exists(CHARGING_RULE)) { redisClient.set(CHARGING_RULE, JSONObject.toJSONString(rules)); } }}然后就可以在需要对停车时间进行计费的时候，随时查询 Redis 缓存了。public float calculateFee(Long stayMinutes) { String ruleStr = redisClient.get(CHARGING_RULE); JSONArray array = JSONObject.parseArray(ruleStr); List&amp;lt;ChargingRule&amp;gt; rules = JSONObject.parseArray(array.toJSONString(), ChargingRule.class); float fee = 0; for (ChargingRule chargingRule : rules) { //遍历计费规则，寻找当前停车时间对应的计费区间，以及收费 if (chargingRule.getStayTimeStart() &amp;lt;= stayMinutes &amp;amp;&amp;amp; chargingRule.getStayTimeEnd() &amp;gt; stayMinutes) { fee = chargingRule.getFee(); break; } } return fee;}那么每次调用计算停车费用接口，就只需要传递停车的时间，格式是分钟。然后就能返回具体收费了。下面是存在 Redis 中的计费数据：" }, { "title": "支付宝支付功能实践", "url": "/posts/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/", "categories": "项目, 商场停车", "tags": "", "date": "2023-05-03 00:00:00 +0800", "snippet": "目标为了使应用拥有初步的支付功能，我决定引入微信/支付宝的支付功能，后来因为微信的资格审查较为严格，因此决定使用支付宝支付功能，且由于学生个体用户申请商家身份较为麻烦，因此使用支付宝提供的沙箱环境来实现和测试支付功能。使用支付宝支付产品功能支付宝专门为个体和组织提供方便好用的支付功能开发工具包，按照支付宝的开发文档就能非常方便和简单的实现自己的支付功能。下面是具体的使用步骤： 使用开发者账号登录 开放平台控制台 &amp;gt; 开发工具推荐，点击 沙箱 即可进入沙箱环境。创建沙箱应用后默认会提供给我们应用的 APPID、应用名称和绑定的商家账号（PID） 创建好应用之后，需要设置接口加签方式，因为支付功能是及其敏感，涉及到个人财产安全的功能开发，所以在信息安全这方面上必须做足准备，因为对应接口调用信息的传递必须进行加密，而一般采用的加密方式属于非对称加密，其中的RSA256加密方式目前足够支撑支付安全。然后使用支付宝密钥生成器就能自动生成属于应用的密钥和私钥了，其中应用密钥和支付宝公钥需填写到代码中供签名时使用，应用公钥需上传到支付宝开放平台。如下所示：引入 jar 包为了在程序中使用支付宝支付功能，需要引入开发工具包：&amp;lt;!-- 支付宝支付SDK --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alipay.sdk&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;alipay-sdk-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.35.101.ALL&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;引入 Demo 代码支付宝提供了简单的支付功能 demo 代码，经过简单改造就能在程序中使用：public class PaymentTemplate { // 商户appid private String appId; // 私钥 pkcs8格式的 private String rsaPrivateKey; // 服务器异步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 private String notifyUrl; // 页面跳转同步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 商户可以自定义同步跳转地址 private String returnUrl; // 请求网关地址 private String url; // 编码 private String charset; // 返回格式 private String format; // 支付宝公钥 private String alipayPublicKey; // 日志记录目录 private String logPath; // RSA2 private String signType; public String pay(String outTradeNo){ AlipayClient client = new DefaultAlipayClient(url, appId, rsaPrivateKey, format, charset, alipayPublicKey, signType); AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest(); //异步接收地址，仅支持http/https，公网可访问 request.setNotifyUrl(&quot;notifyUrl&quot;); //同步跳转地址，仅支持http/https request.setReturnUrl(returnUrl); /******必传参数******/ JSONObject bizContent = new JSONObject(); //商户订单号，商家自定义，保持唯一性 bizContent.put(&quot;out_trade_no&quot;, &quot;20210817010101004&quot;); //支付金额，最小值0.01元 bizContent.put(&quot;total_amount&quot;, 0.01); //订单标题，不可使用特殊符号 bizContent.put(&quot;subject&quot;, &quot;测试商品&quot;); /******可选参数******/ //手机网站支付默认传值FAST_INSTANT_TRADE_PAY bizContent.put(&quot;product_code&quot;, &quot;FAST_INSTANT_TRADE_PAY&quot;); //bizContent.put(&quot;time_expire&quot;, &quot;2022-08-01 22:00:00&quot;); //// 商品明细信息，按需传入 //JSONArray goodsDetail = new JSONArray(); //JSONObject goods1 = new JSONObject(); //goods1.put(&quot;goods_id&quot;, &quot;goodsNo1&quot;); //goods1.put(&quot;goods_name&quot;, &quot;子商品1&quot;); //goods1.put(&quot;quantity&quot;, 1); //goods1.put(&quot;price&quot;, 0.01); //goodsDetail.add(goods1); //bizContent.put(&quot;goods_detail&quot;, goodsDetail); //// 扩展信息，按需传入 //JSONObject extendParams = new JSONObject(); //extendParams.put(&quot;sys_service_provider_id&quot;, &quot;2088511833207846&quot;); //bizContent.put(&quot;extend_params&quot;, extendParams); request.setBizContent(bizContent.toString()); AlipayTradeWapPayResponse response = null; try { response = client.pageExecute(request); } catch (AlipayApiException e) { throw new RuntimeException(e); } return response.getBody(); }}下面的时序图展示了代码的执行流程： 首先由用户选择商品，在我的智慧停车场管理系统中需要进行支付的模块包括：自动停车消费，充值会员消费，抽优惠券/洗车券消费。这些统一会生成一个应用唯一的订单号。 支付宝开发工具客户端则主要需要：商户appid、请求网关地址、应用私钥、支付宝公钥和加解密类型等主要信息，另外还需要订单的相关信息，比如订单的支付金额、购买商品的基本信息和订单标题等信息，然后就会向支付宝后台请求执行支付功能。如何在程序中使用在页面进行支付的时候会调用下面的接口：/** * 统一支付接口 * * @param outTradeNo 商户唯一订单号 */@GetMapping(&quot;/pay&quot;)public CommonResult&amp;lt;String&amp;gt; pay(String outTradeNo) {return CommonResult.success(paymentTemplate.pay(outTradeNo));}然后执行上面改造后的支付逻辑，最后会返回给前端一段 html 代码，可与页面进行展示，效果如下：这样简单的支付功能就完成了。" }, { "title": "MySQL为什么有时候会选错索引？", "url": "/posts/MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95/", "categories": "MySQL", "tags": "", "date": "2023-04-10 00:00:00 +0800", "snippet": "索引统计的更新机制选择索引是优化器的工作，优化器选择索引的目的是为了寻找一个最优的执行方案，并用最小的代价去执行语句。在数据库里，扫描行数、是否使用临时表和是否排序等是印象执行代价的因素之一。其中扫描行数越小意味着访问磁盘数据的次数越少，消耗的 CPU 资源就会越少；而如果用到的索引正好是排序字段，由于索引是排好序的，因而能够减少因排序产生的消耗。而扫描行数是被基数影响， MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。使用 show index from your_table_name; 能看到这个表上索引的区分度，对应的字段是 Cardinality：使用 explain “查询语句”; 能看到执行语句的预估扫描行数：其中 rows 对应的就是扫描行数，如果发现预估的扫描行数与实际选中对应的索引会扫描的行数相差过大，这时候可以使用 analyze table your_table_name; 用来重新统计索引信息。索引选择异常和处理对于其他优化器误判的情况，可以在应用端用 force index 来强行指定索引，也可以通过修改语句来引导优化器选择我们想让它选择的索引，还可以通过增加或者删除索引来绕过这个问题。" }, { "title": "普通索引和唯一索引，应该怎么选择？", "url": "/posts/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9/", "categories": "MySQL", "tags": "", "date": "2023-04-03 00:00:00 +0800", "snippet": "查询、更新和插入性能比较以下面的索引树举例：查询执行查询的语句是 select id from T where k=5： 普通索引：从树根一直到叶子节点，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。 唯一索引：由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。在查询方面，两者性能差距微乎其微，普通索引只是多了一次判断，而 InnoDB 的数据是按数据页为单位来读写的，两条数据一般同一个数据页，而要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算更新和插入对于唯一索引来说，每次在更新/插入时都需要判断数据是否唯一，所以仅仅只是在 change buffer 中记录下操作可不行，必须将对应的数据页读入到内存中进行判断数据是否存在才行。所以唯一索引没有必要使用 change buffer。因此如果在更新和查询操作较多的数据库中使用唯一索引就容易造成系统阻塞。change buffer 的使用场景使用原理当需要更新一个数据页时： 如果数据页在内存中就直接更新 不在内存中，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，等到下次查询该数据页时执行 change buffer 中与这个页有关的操作。虽然名字叫作 change buffer，实际上它是可以持久化的数据，在磁盘也保存着它的内容。而将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。什么时候被使用实际上只有在普通索引这种情况下，change buffer 会生效。change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。最适合的情况对于写多读少的业务来说，change buffer 的使用效果最好。多次的写操作都不会马上取读数据页了，对于业务系统来说响应会更快。这种业务系统比如：账单系统、日志类系统。相反如果写了之后会立马查询，那就没必要使用 change buffer，反而还增加了 change buffer 的维护代价buffer poolBuffer Pool 是什么？从字面上看是缓存池的意思。它是 MySQL 当中至关重要的一个组件，可以这么说，MySQL的所有的增删改的操作都是在 Buffer Pool 中执行的。是否使用唯一索引 如果业务代码保证不会写入重复数据，可以使用普通索引替换唯一索引。 在一些“归档库”的场景，你是可以考虑使用普通索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。" }, { "title": "事务到底是隔离的还是不隔离的？", "url": "/posts/%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/", "categories": "MySQL", "tags": "", "date": "2023-03-26 00:00:00 +0800", "snippet": "事务隔离与行锁与更新操作之前有提到事务启动时会创建一个视图，即使有其他事务修改了事务，在这个事务中看到的和启动时仍然是一样。但是当事务 A 和事务 B 更新用一条记录时会发生冲突，先者会阻塞后者，后者会陷入等待状态。那么在这种情况下事务 B 先修改了记录 R，那么事务 A 看到的记录 A 还是它刚开启事务的时候的值吗？此视图非彼视图我们讲的事务的多并发控制中，事务每次启动时创建的视图并不是通常说的视图 view，view 是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。这个视图指的是InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。作用是事务执行期间用来定义“我能看到什么数据”。一致性视图的组成在不可重复度的隔离级别下，事务每次启动会创建一致性视图，那么在创建期间事务具体做了什么呢？或者说一致性视图是怎么组成的呢？首先事务在启动的时候就“拍了个快照”，而这个快照是基于整个库的。在解释快照的实现之前必须知道： InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。 而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。（这个信息就是回滚日志 undo log）图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。而图中的三个虚线箭头就是 undo log。快照的实现如下：在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。这个视图数组把所有的 row trx_id 分成了几种不同的情况。这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能： 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的； 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的； 如果落在黄色部分，那就包括两种情况 a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见（b 的意思应该是快照的时候事务 A 还没提交，但在当前事务提交之前，事务 A 提交了）。我们前面说过快照是整个库级别的，那么一个库那么大，它是怎么做到的呢？现在就有答案了：InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。现在为了验证上面的结论，做如下假设： 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99； 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务； 三个事务开始前，(id=1,k=1) 这一行数据的 row trx_id 是 90。当事务 A 执行 get k 时会有下面的流程： 找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；再往前找，终于找到了（1,1），它的 row trx_id=90，比低水位小，处于绿色区域，可见。这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。这也验证了可重复读隔离级别为什么能避免脏读（A 读不到 B 更新过后的数据，因为 A 在执行 get k 的时候事务 B 还未提交）但是现在还有一个问题：事务 C 执行完更新语句就提交了，为什么事务 B 在更新后 k = 3 呢？（按道理事务 B 在创建的时候，事务 C 还没开始，所以事务 B 的一致性视图里数组不包含事务 C，可在更新时却还是读到了事务 C 更新后的数据）。 注意在数据的多版本中，不管事务有无提交数据更新都会被记录为一个版本。之所以如此是因为更新是另一条规则：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。所以事务 B 读到的是事务 C 提交的最新值。而在事务 B 更新后，事务 B 继续执行 get k，k = 3，是因为这个时候的最新值是事务 B 更新后的，row trx_id 就等于事务 B 的 transaction id。而除了更新语句是当前读外，select 语句如果加锁也是当前读，也就是说加了锁就是当前读（因为更新会加行锁）下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。所以它们都可以读到版本号是 101 的数据。mysql&amp;gt; select k from t where id=1 lock in share mode;mysql&amp;gt; select k from t where id=1 for update;而当出现下面的情况：事务 C’ 修改 k 后并没有提交，这时候事务 B 修改 k 会发生什么呢？这个时候两阶段锁就发挥作用了：由于事务 C’ 没提交，所以行锁不会释放，那么事务 B 就会被锁住进入等待状态。到这里，我们把一致性读、当前读和行锁就串起来了。可重复读的能力是怎么实现的？可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。读提交的能力是怎么实现的？读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是： 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图； 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。也就是说区别在与快照的时机，读提交是在语句每次执行的时候，不可重复读是事务创建的时候。所以事务 A 执行 get k 时，因为 101 未提交所以不可见，而 102 属于已提交可见。所以最终返回 k = 2。" }, { "title": "行锁功过：怎么减少行锁对性能的影响？", "url": "/posts/%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87-%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/", "categories": "MySQL", "tags": "", "date": "2023-03-19 00:00:00 +0800", "snippet": "什么是两阶段锁两阶段锁协议（Two-Phase Locking Protocol）是一种并发控制机制，旨在保证事务的隔离性和原子性。这样可以避免死锁的发生，提高数据库的性能和并发度。该协议分为两个阶段： 增长阶段（Growing Phase）：事务在执行过程中，需要获取需要的所有锁。在这个阶段中，事务可以获取锁，但是不能释放锁。 缩减阶段（Shrinking Phase）：当事务执行完毕后，需要释放所有锁。在这个阶段中，事务可以释放锁，但是不能获取锁。即行锁在事务结束时才释放。比如对于下面的事务 A 和事务 B：只有在事务 A 执行 commit 之后，事务 B 才能继续执行。怎么利用好两阶段锁假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作： 从顾客 A 账户余额中扣除电影票价； 给影院 B 的账户余额增加这张电影票价； 记录一条交易日志。也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，那么该如何安排这三个语句在事务中的顺序呢？假设另外一个顾客 C 也在影院 B 买票，那么事务冲突的部分就是语句 2。因为它们要更新同一个影院账户的余额，需要修改同一行数据。这样如果我们把容易冲突的语句 2 放在最后，这就能最大程度地减少了事务之间的锁等待，提升了并发度。但是有一天影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？这里，就要说到死锁和死锁检测了。死锁和死锁检测当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。比如：这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。如何处理死锁状态 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。一般我们会选择策略 2 因为在第一种策略下，如果设置的时间过长，那么意味着其他事务也要等待较长的时间，对于一个在线服务来说这是难以接受的。而如果设置时常过短，则容易出现等待超时正常的锁等待。策略 2：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。因为不管是否发生死锁，当一个事务被锁住就要进行死锁监测。而当出现上述影院做活动时，由于流量太多，就算我们把冲突的语句放在最后依然会存在大量事务等待的情况，而在这种情况下死锁监测这个操作的时间复杂度高达 O(n^2)，即假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。因此会出现 CPU 直接干到 100% 的情况，事务却没有执行几个的情况。如何热点行更新导致的性能问题对于上述影院做活动出现的情况，我们称其为热点行更新导致的性能问题，那么对于这种问题有哪些解决方案呢？ 如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。 控制并发度，但建议从服务端限制，因为如果从客户端限制，由于一个服务端可能有多个客户端，就算限制客户端的并发线程最多 5 个，但如果客户端有上百个，还是容易出现高并发的情况。 将冲突行的逻辑改成多个语句。比如上述的更新影院账户，可以把账户余额分配到十个记录中，但进行执行更新影院账户的操作时随机选择一个记录进行更新，而影院账户的总余额就是十条记录相加的结果。" }, { "title": "全局锁和表锁 ：给表加个字段怎么有这么多阻碍？", "url": "/posts/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81-%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D/", "categories": "MySQL", "tags": "", "date": "2023-03-19 00:00:00 +0800", "snippet": "MySQL 为什么需要锁数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。全局锁即对整个数据库实例加锁。MySQL 中提供了一个加全局读锁的命令：Flush tables with read lock (在这里就简称 FTWRL)因为全局锁的常见应用场景就是对整个库做备份，所以一般可以执行这条命令。使用这个命令之后其他线程的以下语句会被阻塞： 数据更新语句（数据的增删改） 数据定义语句（包括建表、修改表结构等） 更新类事务的提交语句。简单来说，在备份期间，所有的业务都得停摆。那么备份为什么要加锁呢举个简单的例子，小红在某 APP 上充值了会员，所以账户余额就减少了。但如果备份的次序是这样的：备份会员数据 –&amp;gt; 用户充值会员 —&amp;gt; 备份账户余额数据。显然在备份结果里小红明明充值了但却不是会员。即不加锁的话，系统备份的库不是一个逻辑时间点，这个视图是逻辑不一致的。MySQL 的逻辑备份工具 mysqldump实际上 MySQL 自带备份工具 mysqldump，当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。既然有 mysqldump，为什么还需要 FTWRL 呢？因为除了 InnoDB，还有很多存储引擎压根不支持事务，比如 MyISAM，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，但还是建议用 FTWRL 方式，主要有两个原因： 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。业务的更新不只是增删改数据（DML），还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。表级锁表锁限制其他线程的同时限制自身语法：lock tables ... read/write，与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。注意lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。当然线程 A 对其他表的操作不受影响，因为 MySQL 的表级锁是针对指定的表而非整个数据库的。一般不用表锁，除非存储引擎不支持行锁在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，直到出现 InnoDB 这种支持行锁的引擎。毕竟表锁对业务的影响也不次于全局锁。元数据锁（metadata lock，MDL）MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。比如：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此在 MySQL 5.5 版本中引入了 MDLMDL 的使用当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。MDL 是 MySQL 的一个自动机制，但请不要忽视它事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。假设你正在修改一个小表，如下图所示：可以看到 session A 先启动时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。如何安全地给小表加字段？解决长事务，事务不提交就会一直占着 MDL 锁，在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，怎么办呢？这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。" }, { "title": "深入浅出索引", "url": "/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/", "categories": "MySQL", "tags": "", "date": "2023-03-12 00:00:00 +0800", "snippet": "索引的实现模型哈希表模型结构如下：本哈希表以数组和链表为数据结构，哈希表通过哈希函数计算出索引可能的下标，并将值存在数组当中，如果不同的索引值命中相同的下标，那么会作为节点链接在数组元素后面；以Java的hashMap为例，数据以key-value键值对存在底层哈希表中，正如hashMap不会维护key值有序性，当我们针对一个区间查找数据的时候就会很麻烦，比如我的hashMap结构是一个Integer，User的键值对，存的是身份证id《—》居民信息由于数据存入时并没有保证有序性，当我们查找（101，201）这个区间的用户时，就要遍历所有的记录，直至查出所有的在这个区间的用户，所以说：哈希表这种结构适用于只有等值查询的场景，不适用范围查询，示意图如下：有序数组如果是有序数组，那么既可以保证身份证id的有序性，又能通过索引等值查询到需要的数据，这样看来有序数组完美适应等值查询和范围查询，但是如果向数组插入数据，就必须将后面的数据向后移动一段距离，时间复杂度可想而知，因此它适合静态数据的存储，如每年城市人口的数据二叉搜索树先来看看如果以身份证，用户信息作为案例：二叉树每个节点会分配一个权值，整好可以作为索引，为了保证二叉搜索树插入和查询的时间复杂度都是O(logn)，应该保证它是平衡二叉树（AVL树），二分查找树其实很像数组的二分查找，因而二叉树是一个查询效率很高的数据结构，不过它作为索引的底层数据结构却并不待见，原因是数据高度过高，每层固定是两个节点，那么对于一次搜索，很可能需要深入到树的底层，如果说每个节点存在磁盘，那么一次查找可能触发很多次IO操作，存储效率和查询效率都非常低因而出现了多叉树，即尽量让一个数据块存更多的数据，这样就能有效降低树的高度，减少IO操作的次数，N叉树目前已经广泛应用于数据库引擎；二叉树其实是特殊的N叉树，N叉树的基本结构和代码表示：由于N叉树的根节点子数不确定，所以应该使用动态数组存储，在Java中我们就用ArrayList（当然实际上用的是接口List，毕竟LinkedList也不是不可以）class Node { public int val; public List&amp;lt;Node&amp;gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&amp;lt;Node&amp;gt; _children) { val = _val; children = _children; }};InnoDB的索引模型InnoDB底层使用B+树作为索引的数据结构，B+树是更加复杂的多叉树，一个索引将会对应一棵B+树，索引—N叉树，1对1的关系；B+树在数据库表上的表现：从图中可见，存储的数据类型有行记录，以及目录项，也就是索引，而叶子节点存储的都是行记录，非叶子节点也称为内节点索引类型分为主键索引（聚簇索引）和非主键索引，主键索引叶子节点存的是一行的数据，而非主键索引存的是主键的值，因此，非主键索引也称为二级索引；显然使用非主键索引会多查一次树，因此主键索引的查询效率更高索引维护页分裂现象下图是之前的身份证id-user的索引结构，以身份证Id作为索引：这个图该怎么看：ID下面的第一条数据实际是磁盘中连续的一段空间，而300与它后面的小的框框是一个整体，小的框框存的是一个数据页的地址，而300其实就是这个数据页的最小记录为了保证索引的有序性，产生了所谓的页分裂，比如在R5之前插入数据，结果需要把R5的一部分数据往后挪，结果R5的数据分布在两个数据页，这就出现了页分裂采用自增主键在页分裂中我们看到，如果需要插入数据，B+树和有序数组一样，需要将后面的数据往后挪以腾出空间，但是如果是自增主键，每次只要追加就好了，因此推荐使用自增主键自增主键和业务逻辑做主键首先，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以用自增主键是不错的选择；而业务逻辑主键不容易保存有序插入（比较可能比较复杂吧），这样写入操作可能耗时较多什么时候适合用业务主键呢，K-V形式的场景，即：1.整张表只有一个索引2.索引必须是唯一索引由于没有其他索引，就不用考虑主键占用空间较大的问题，对于插入问题，如果是整型还好，不是也没办法，毕竟有一个索引，相对而言使用索引查询和添加速率都会较快" }, { "title": "日志系统：一条SQL更新语句是如何执行的？", "url": "/posts/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F-%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/", "categories": "MySQL", "tags": "", "date": "2023-03-12 00:00:00 +0800", "snippet": " MySQL 的数据以数据页为单位，按偏移量寻找记录的具体位置，所以每次IO操作都是一个个数据页加载到内存。但是我们需要查询或修改的数据也许就是一条记录，甚至对于更新操作，又会将数据页整个的刷新到磁盘，所以IO成本非常高，因而为了降低 IO 操作的成本，MySQL 做了大量的努力。更新操作牵涉两个重要的日志：redo log 和 binlogredo log 怎么起作用的redo log 可以简单分为两个部分 内存层面的 redo log buffer 持久化层面的 redo log fileredo log实现的具体逻辑：write pos 和 check pointwrite pos 是 redo log 追加日志的索引，check point 代表擦除记录的位置，write pos 代表当前写的位置，当 write pos = check point 时，代表剩余空间已经被写完了，需要将 write pos 向前推进，擦除 redo log 中的一部分，并将这部分操作刷新到磁盘中，这样就形成了一个循环队列的数据结构，具体的形象图如下：binlog和redo log的区别 redo log 是 InnoDB 独有的，而 binlog 是 server 层的，所有的引擎都可以使用 在更新事务期间，redo log 会循环不断记录，而 binlog 会在事务提交时一次性写入 binlog记录的是原始逻辑，也就是把 SQL 语句直接存入，redo log 则是物理日志 redo log 空间固定，binlog 可追加写，写完一个，会继续写另一个，这就说明 binlog 可以用来恢复临时库，因为里面记录任意时刻的原始操作binlog的工作逻辑通常备份库里会备份近半个月的 binlog，用于恢复临时库，当然如果想要数据库恢复更久之前的状态，也可以备份更长的甚至是一年的 binlog" }, { "title": "基础架构：一条SQL查询语句是如何执行的", "url": "/posts/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/", "categories": "MySQL", "tags": "", "date": "2023-03-12 00:00:00 +0800", "snippet": "架构流程图连接器长连接可能出现的问题当连接器使用长连接管理MySQL客户端和服务端的连接时，容易因为内存过大，导致MySQL服务重启；原因是因为：MySQL执行过程中连接对象是被管理在了内存中，连接断开，内存才会释放，所以当我们全部使用长连接时，内存就会涨的特别快，甚至导致服务被系统强制杀死，从现象看就是MySQL服务异常重启。如何解决：1.定期断开连接2.在MySQL5.7和更新版本，使用mysql_reset_connection命令重新初始化连接资源，该过程不需要重连或重新进行权限验证，但是会将连接重置为刚刚创建完成的状态查询缓存为什么不建议使用查询缓存弊大于利：1.一旦执行更新操作，缓存会全部清除，意思是辛辛苦苦维护缓存，结果还没来得及用就被删除了，白白浪费了资源；所以如果要使用缓存，尽量是更新操作比较少的数据库2.MySQL8.0之后完全割掉了查询缓存的功能按需使用查询缓存将参数query_cache_type参数设置成demand，这样默认对于SQL语句不使用查询缓存，如果要针对特定语句使用查询缓存，操作如下：mysql&amp;gt; select SQL_CACHE * from T where id=10;" }, { "title": "事务隔离：为什么你改了我还看不见？", "url": "/posts/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/", "categories": "MySQL", "tags": "", "date": "2023-03-12 00:00:00 +0800", "snippet": "事务隔离级别 读未提交（read uncommitted），事务未提交，它做的变更就可被其他事务看见 读已提交（read committed），事务提交后，它做的变更才可见 可重复读（repeatable read），事务在执行过程中看到的数据，与事务开启时看到的数据是一致的 串行化（serializable），顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。事务隔离级别的实现机理事务上的视图事实上，当一个事务访问一条记录时，数据库服务器会为这个这条记录生成一个视图，而事务访问时都会以这个视图的逻辑结果为准； 读未提交没有视图的概念，它总是读取一条记录的最新值 读已提交，视图是在每个SQL执行的时候生成的，因此如果是同一条SQL，每次执行的视图可能会不一样（也就是如果当前记录被已提交事务修改） 可重复读，视图是在事务开启的时候生成的，因而事务的整个存在期间（未提交前）都是以这个视图为准的 串行化，直接用加锁的方式避免事务的并行访问如何查看当前事务的隔离级别show variables like &#39;transaction_isolation&#39;;事务的多版本并发控制从日志系统那一章我们知道：在 InnoDB 中每次进行更新操作时都会在 redo log 中进行记录，而事务中的最新值可以通过 redo log 回滚到前几个状态的值。事实上事务的原子性就是通过 redo log 实现。假设在当前的事务中，一条数据经过了如下变化：其中 read-view 代表视图，而对于不同时刻启动的事务，会分别用不同的视图，使得同一条数据在不同的事务居然会有呈现不同的值，比如上图一共有 A、B、C 三个视图，数据的值分别是 1、2、4。这就是数据库的多版本并发控制（MVCC）。事务的启动方式手动操作事务：-- 关闭事务的自动提交set autocommit=0 -- 开启事务(或者 start transaction)begin -- 提交事务commit-- 回滚事务rollback-- 提交事务并自动开启下一个事务commit work and chain-- 查找持续时间超过60s的事务select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&amp;gt;60;" }, { "title": "字典项自动翻译器", "url": "/posts/%E5%AD%97%E5%85%B8%E9%A1%B9%E8%87%AA%E5%8A%A8%E7%BF%BB%E8%AF%91%E5%99%A8/", "categories": "项目", "tags": "", "date": "2023-03-10 00:00:00 +0800", "snippet": "需求 把注解标注在JavaBean上能很方便的标识出需要翻译的字段。这种方式在每个方法返回一个对应的 VO 这样的规范下是没有问题的。但如果开发者的开发不规范，也就是每个方法它可能都返回同一个 VO 对象，但是每个方法它需要翻译的字段又可能不一样，这样就容易多翻，造成性能损失。可不可以支持多种方式，比如我可以在类上面去标识需要翻译的字段，也可以在方法上去标识要翻译的字段。 字典项可能有子父类关系 或者某些字段可以拥有多个字典label，比如用分隔符分隔的dictValue，那么翻译的时候就有多个label，而且label是否需要也用分隔符串起来。 JavaBean 如果嵌套 javaBean，可能嵌套的 JavaBean 也有需要翻译的字段待办 压测 考虑一些并发的问题 某些需求很难遇上，可以不做设计原理翻译器使用了 Spring AOP 的相关技术，设计图如下：" }, { "title": "积分体系设计", "url": "/posts/%E7%A7%AF%E5%88%86%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1/", "categories": "项目, 商场停车", "tags": "", "date": "2023-03-01 00:00:00 +0800", "snippet": "积分体系设计的必要性互联网平台积分体系是一个独立、完整的系统模块。主要用于激励和回馈用户在平台的消费行为和活动行为，通过积分体系可以激发与引导用户在平台的活跃行为，逐步形成用户对平台的依赖性和习惯性，提升用户对平台的黏度，提高用户和平台的交易频率。积分体系在保持系统独立性的同时，又与平台会员系统、商品系统、订单系统等具有紧密的关联性，因此积分体系的规划设计需与平台其他系统模块同时设计开发。如何进行积分体系设计 已知积分体系在互联网的必要性，那么该如何设计积分体系呢？需求分析以我目前设计的智慧停车管理系统为例，有下列原始业务： 用户能查询到积分的赚取/消费明细，像下面这样： 用户可查询自己的可用积分。 用户每次会消费最快到期的积分。 用户能使用积分兑换优惠券、洗车券和活动商品，比如： 用户预约车位成功，系统奖励积分。 用户成功注册账户后，系统奖励积分。 用户充值成功付费会员后，系统奖励积分。 用户使用积分进行活动抽奖。 用户每日签到，系统奖励积分。基于这些原始业务，大致可以分为两类：赚取积分和消费积分。并且根据用户行为应该给予多少积分奖励、行为次数是否有上限、下单金额需要满多少、积分抵扣金额时需要满多少以及积分的有效期等等，这些一律称为积分规则。比如：用户成功注册账号，系统奖励积分 100，积分有效期 7 天。系统设计 已知积分体系与会员系统、商品系统、订单系统等其他系统具有紧密的关联性，那么该如何做积分体系的系统设计呢？所谓系统设计实际上就是将合适的功能放到合适的模块中，并确定合适的模块交互关系。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。以上面提出的原始需求为根据主要分为下列功能： 积分交易明细管理，包括赚取和消费。 用户行为管理，依据运营目标的不同，对不同的用户行为有不同的积分规则。 积分规则管理，包含赚取规则和消费规则。具体的划分和模块之间的关系如下：积分规则和用户行为的管理和维护不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，能够进行 CRUD 管理就够了。在这种方式下系统的架构大致如下：最终营销系统通过上层服务传入的参数： 行为ID用与获取积分规则 事件ID可用于获取交易额（有些可能仅仅起到追溯和记录的作用）然后计算出赚取/消费的积分交给积分系统进行管理。当然还有其他方式，但都不如这种方式优秀。数据库设计和面向对象设计实现下面给出整个积分体系的表设计：-- 库表通用字段`create_by` varchar(32) DEFAULT NULL COMMENT &#39;创建人&#39;,`create_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建日期&#39;,`update_by` varchar(32) DEFAULT NULL COMMENT &#39;更新人&#39;,`update_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;更新日期&#39;,`remark` varchar(500) DEFAULT NULL COMMENT &#39;备注&#39;,`version` int(4) DEFAULT &#39;0&#39; COMMENT &#39;版本&#39;,`state` int(4) DEFAULT &#39;1&#39; COMMENT &#39;状态&#39;-- ------------------------------ Table structure for cre_transaction-- ----------------------------DROP TABLE IF EXISTS `cre_transaction`;CREATE TABLE `cre_transaction` ( `id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `user_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;用户id&#39;, `channel_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;用户行为id&#39;, `event_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;事件id（如订单id、评论id、优惠券换购交易id）&#39;, `credit` decimal(7, 2) DEFAULT NULL COMMENT &#39;积分（赚取为正，消费为负）&#39;, `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(0) COMMENT &#39;积分赚取/消费时间&#39;, `create_by` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;创建人&#39;, `version` int(4) NOT NULL DEFAULT 1, `state` int(4) NOT NULL DEFAULT 1, `expired_time` timestamp(0) DEFAULT NULL COMMENT &#39;积分过期时间&#39;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;积分明细表&#39; ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for pro_points_rule-- ----------------------------DROP TABLE IF EXISTS `pro_points_rule`;CREATE TABLE `pro_points_rule` ( `id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT &#39;&#39;, `behavior_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;行为ID&#39;, `points` decimal(7, 2) DEFAULT NULL COMMENT &#39;积分面额&#39;, `exchange_ratio` decimal(4, 3) DEFAULT NULL COMMENT &#39;兑换比例（有正负）&#39;, `formula_mode` int(4) DEFAULT 1 COMMENT &#39;计算模式（1面额、2兑换比例，默认面额）&#39;, `spend_lower_limit` decimal(7, 2) DEFAULT NULL COMMENT &#39;消费金额下限（积分赚取规则）&#39;, `balance_lower_limit` decimal(7, 2) DEFAULT NULL COMMENT &#39;积分余额下限（积分消费规则）&#39;, `expired` int(4) DEFAULT NULL COMMENT &#39;约定过期时间&#39;, `time_upper_limit` int(4) DEFAULT NULL COMMENT &#39;每日行为次数上限&#39;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;积分规则表&#39; ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for pro_user_behavior-- ----------------------------DROP TABLE IF EXISTS `pro_user_behavior`;CREATE TABLE `pro_user_behavior` ( `id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT &#39;&#39;, `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;行为类别&#39;, `behavior` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;具体行为&#39;, `points_type` int(4) DEFAULT NULL COMMENT &#39;积分类型（1赚取，2消费，默认赚取）&#39;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;用户行为表&#39; ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for cre_available_points-- ----------------------------DROP TABLE IF EXISTS `cre_available_points`;CREATE TABLE `cre_available_points` ( `id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT &#39;&#39;, `user_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;用户ID&#39;, `add_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#39;赚取积分ID&#39;, `points` decimal(7, 2) DEFAULT NULL COMMENT &#39;积分&#39;, `expired_time` timestamp(0) DEFAULT NULL COMMENT &#39;过期时间&#39;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;可用积分表&#39; ROW_FORMAT = Dynamic;我为该积分体系总共设计了四张表： cre_transaction，积分交易明细表，用与记录和查询用户的积分交易流水。 cre_available，可用积分表，用于查询用户可用积分。 pro_user_behavior，用户行为表，该表主要用于穷举业务系统中用户可能存在的行为。 pro_points_rule，积分规则表，计入积分赚取/消费的规则。下面是我在设计以上四张表的经验：经验1 通过 cre_transaction，也可以计算用户的积分可用余额，那么为什么还要增加 cre_available 呢? 在实际的业务系统开发中仅有一张积分交易明细表是远远不够的，比如在没有可用积分表之前，查询用户可用积分是下面这样的：SELECT sum( credit )FROM cre_transactionWHERE user_id = #{userId} AND (expired_time &amp;gt; CURRENT_TIME or expired_time is null); expired_time &amp;gt; CURRENT_TIME 是查询未过期得赚取积分，而 expired_time 查询的是所有得消费的积分，照这种算法，过期的积分就相当于没被抵扣过，所以可用积分肯定被多扣了。实际上一张表本就很难模拟积分的增减情况。 所以新增一张可用积分表用于记录积分的增减情况是很有必要的，该表是如何操作的呢？ 每次赚取积分同时往 cre_transaction 和 cre_available 中添加一条记录，每次消费积分时除了记录交易明细，同时需要更新 cre_available 中的最快过期积分（最快过期积分 - 消费积分），直到消费积分被扣完。这样就能实现查询用户可用积分和每次消费最快过期积分两个功能。经验2 积分规则存在消费/赚取规则，实际上对于更加复杂的积分体系，每种商品，每种活动，每个用户都会有对应的个性化的积分规则，那么这样将所有规则记录在同一张表中合适吗？ 实际上最开始我是设计了两张表的：赚取规则和消费规则，但因为在编码实现当中比较冗余，实现起来有点麻烦，因为分为两张表后在进行积分操作时，营销系统需要调用两个不同的接口，entity 也是不同的。这就造成营销系统需要两套针对的实现。或多或少有些麻烦。同时因为我的业务系统本身没有那么复杂，所以更不会有个性化的积分规则。因此这样设计是最符合实际业务的。经验3 实际上只有一张积分规则表就可以进行积分的兑换操作了，为什么还要增加用户行为表进行辅助？ 假设只有 pro_points_rule 表，那么对于用户的不同操作（在代码中则是一个个接口），我们需要将规则ID硬编码在实现当中，但是与用户行为不同的是规则是会发生改变的，一旦规则改变就需要修改代码。而增加 user_behavior，由于用户行为对于业务系统是不变的，在用户行为中关联规则ID，能方便规则的维护，也方便规则发生改变。例如下面是我的营销系统入口代码实现： public String promoteEntryOfPoints(String userId, String channelId, String eventId) { //查询用户行为 ProUserBehavior userBehavior = findById(channelId); //查询用户行为对应的积分规则 ProPointsRule rule = pointsRuleService.getOneByBehaviorID(channelId); //添加积分记录 CreTransaction trade = new CreTransaction(); if (userBehavior.getPointsType() == POINTS_TYPE_EARN){ if (rule.getFormulaMode() == FORMULA_MODE_FACE_AMOUNT){ // TODO: 2023/3/1 赚取面额有次数上限，如果 timeUpperLimit != null，应该进行限制，其中用户行为次数可以用 Redis 进行统计 if (rule.getTimeUpperLimit() != null){ int times = 5; if (times &amp;gt; rule.getTimeUpperLimit()){ //不提供积分服务，返回空字符串 return &quot;&quot;; } } trade.setCredit(rule.getPoints()); }else if (rule.getFormulaMode() == FORMULA_MODE_RATIO){ // TODO: 2023/3/1 赚取比例=消费额度*比例，消费额度 &amp;gt;= spendLowerLimit BigDecimal spend = new BigDecimal(100); if (spend.compareTo(rule.getSpendLowerLimit()) &amp;lt; 0){ //不提供积分服务，返回空字符串 return &quot;&quot;; } trade.setCredit(rule.getExchangeRatio().multiply(spend)); } trade.setExpiredTime(LocalDateTime.now().plusDays(rule.getExpired())); }else { if (rule.getFormulaMode() == FORMULA_MODE_FACE_AMOUNT){ trade.setCredit(rule.getPoints()); }else if (rule.getFormulaMode() == FORMULA_MODE_RATIO){ BigDecimal available = availablePointsService.getAvailable(userId); if (available.compareTo(rule.getBalanceLowerLimit()) &amp;lt; 0){ //不提供积分服务，返回空字符串 return &quot;&quot;; } trade.setCredit(available.multiply(rule.getExchangeRatio())); } } trade.setUserId(userId); trade.setChannelId(channelId); trade.setEventId(eventId); transactionService.create(trade); return trade.getId(); }当上层服务调用营销系统时，由此函数进行处理： 首先判断是赚取行为/消费行为 在判断积分计算公式：面额相加/比例相乘 然后根据具体的规则计算产生的积分交易 由积分系统生成积分交易当然目前的实现不易扩展，如果存在业务变更代码绝对需要重构，甚至表结构也需要重新设计，但这是目前我能想出的最佳设计了。积分体系设计本身是非常复杂的，要设计出一个完整的有效的高大上的体系牵涉很多相关的考虑。但是就我当前的业务系统的体量，这样设计就够了。实际上真要说满足业务需求，我现在的设计已经算是过度设计了。参考链接 电商平台-会员积分系统的设计与架构 带过期时间的积分系统表设计" }, { "title": "职责链模式", "url": "/posts/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-02-20 00:00:00 +0800", "snippet": "定义将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。在这之上每个接收对象承担自己独有的处理职责（或者说每个接口对象能实现的功能应该不同）实现方式链表式/** * 接收对象抽象类 */public abstract class Handler { protected Handler successor = null; public void setSuccessor(Handler successor) { this.successor = successor; } public final void handle() { boolean handled = doHandle(); if (successor != null &amp;amp;&amp;amp; !handled) { successor.handle(); } } protected abstract boolean doHandle();}/** * 处理链 */public class HandlerChain { private Handler head = null; private Handler tail = null; public void addHandler(Handler handler) { handler.setSuccessor(null); if (head == null) { head = handler; tail = handler; return; } tail.setSuccessor(handler); tail = handler; } public void handle() { if (head != null) { head.handle(); } }}如何使用：调用 HandlerChain 对象的 handle() 方法，就会启动这条处理链运行，直到遇到一个能处理的接收对象，然后程序结束。数组式/** * 接收对象接口 */public interface IHandler { boolean handle();}public class HandlerChain { private List&amp;lt;IHandler&amp;gt; handlers = new ArrayList&amp;lt;&amp;gt;(); public void addHandler(IHandler handler) { this.handlers.add(handler); } public void handle() { for (IHandler handler : handlers) { boolean handled = handler.handle(); if (handled) { break; } } }}虽然数组的实现方式相比链表的实现方式粗糙些，但是足够简单，每次调用 HandlerChain 对象的 handle() 方法就去遍历所有的接收对象数组，直到遇到能处理的接收对象。职责链模式变体上面的几种实现方式是：遇到一个能处理的接受对象就马上停止执行链，实际上它还有一种变体，即每个接收对象都会取处理请求，反而这种变体的实现应用的更多，比较在一些常见的权限校验框架中就用的比较多。实现方式很简单，在执行链的执行过程中不对接收对象做条件限制，让它一直执行就可以了。不得不说，像模板模式、策略模式和职责链模式的这种，它们更多的被应用在框架中，毕竟它们的这种实现方式本身就是一种框架，比如职责链模式就是定义了一个执行方式，比如执行链，这样在定义新的接收对象类的时候我们压根不用去修改框架代码，正好符合变化的交给自定义，其余的所有工作由框架包揽。应用场景过滤器 和 Spring MVC 拦截器，这两算是职责链模式的经典应用了，它两的关系如下图：有一点需要提示的是：无论是过滤器还是拦截器，它两都可以对请求和响应进行拦截。具体源码不在这剖析。" }, { "title": "状态模式", "url": "/posts/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-02-20 00:00:00 +0800", "snippet": "定义状态模式一般用来实现状态机常用在游戏机，而状态、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。从状态模式的设计来看，它有点像组合模式。有限状态机简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。以超级马里奥为例：马里奥可以变身多种形态，比如比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分。其中游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。下面对这个场景的状态转移图：其中 E1（吃了蘑菇）、E2（获得斗篷） 代表事件，Small 代表状态，+200 代表状态转移后执行的动作。那么如何将上面的模型翻译成代码呢？这就是下面的重点有限状态机的实现方式/** * 状态枚举，在下面三种实现方式中都会用到 */public enum State { SMALL(0), SUPER(1), FIRE(2), CAPE(3); private int value; private State(int value) { this.value = value; } public int getValue() { return this.value; }}分支逻辑法public class MarioStateMachine { private int score; private State currentState; public MarioStateMachine() { this.score = 0; this.currentState = State.SMALL; } public void obtainMushRoom() { if (currentState.equals(State.SMALL)) { this.currentState = State.SUPER; this.score += 100; } } public void obtainCape() { if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) { this.currentState = State.CAPE; this.score += 200; } } public void obtainFireFlower() { if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) { this.currentState = State.FIRE; this.score += 300; } } public void meetMonster() { if (currentState.equals(State.SUPER)) { this.currentState = State.SMALL; this.score -= 100; return; } if (currentState.equals(State.CAPE)) { this.currentState = State.SMALL; this.score -= 200; return; } if (currentState.equals(State.FIRE)) { this.currentState = State.SMALL; this.score -= 300; return; } } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState; }}如上每个函数代表一种事件被触发，内部逻辑就是状态转移和动作执行，显然在这种情况下一旦业务复杂 MarioStateMachine 的可读性和可维护性将大大降低、查表法这是一种非常巧妙的方法，实际上状态机除了用状态转移图表示还能用二维表表示，如下：相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。具体的代码如下所示：public enum Event { GOT_MUSHROOM(0), GOT_CAPE(1), GOT_FIRE(2), MET_MONSTER(3); private int value; private Event(int value) { this.value = value; } public int getValue() { return this.value; }}public class MarioStateMachine { private int score; private State currentState; private static final State[][] transitionTable = { {SUPER, CAPE, FIRE, SMALL}, {SUPER, CAPE, FIRE, SMALL}, {CAPE, CAPE, CAPE, SMALL}, {FIRE, FIRE, FIRE, SMALL} }; private static final int[][] actionTable = { {+100, +200, +300, +0}, {+0, +200, +300, -100}, {+0, +0, +0, -200}, {+0, +0, +0, -300} }; public MarioStateMachine() { this.score = 0; this.currentState = State.SMALL; } public void obtainMushRoom() { executeEvent(Event.GOT_MUSHROOM); } public void obtainCape() { executeEvent(Event.GOT_CAPE); } public void obtainFireFlower() { executeEvent(Event.GOT_FIRE); } public void meetMonster() { executeEvent(Event.MET_MONSTER); } private void executeEvent(Event event) { int stateValue = currentState.getValue(); int eventValue = event.getValue(); this.currentState = transitionTable[stateValue][eventValue]; this.score += actionTable[stateValue][eventValue]; } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState; }}重点就在于 transitionTable 这个二维数组，它将当前状态在经过事件触发后的状态转移都记录在了行当中，一目了然。但它也有缺点：actionTable 能够记录的动作是有局限性的，如果动作较为复杂，那么将难以用数组进行记录。状态模式实际上状态模式就是对分支逻辑法的优化，在分支逻辑法中，所有的状态转移逻辑和动作都被放在同一个类当中，而状态模式就是将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。code 如下：/** * 状态类接口 */public interface IMario { State getName(); //以下是定义的事件 void obtainMushRoom(); void obtainCape(); void obtainFireFlower(); void meetMonster();}/** * SmallMario 状态 */public class SmallMario implements IMario { private MarioStateMachine stateMachine; public SmallMario(MarioStateMachine stateMachine) { this.stateMachine = stateMachine; } @Override public State getName() { return State.SMALL; } @Override public void obtainMushRoom() { stateMachine.setCurrentState(new SuperMario(stateMachine)); stateMachine.setScore(stateMachine.getScore() + 100); } @Override public void obtainCape() { stateMachine.setCurrentState(new SuperMario(stateMachine)); stateMachine.setScore(stateMachine.getScore() + 200); } @Override public void obtainFireFlower() { stateMachine.setCurrentState(new SuperMario(stateMachine)); stateMachine.setScore(stateMachine.getScore() + 300); } @Override public void meetMonster() { // do nothing... }}/** * SuperMario 状态 */public class SuperMario implements IMario { private MarioStateMachine stateMachine; public SuperMario(MarioStateMachine stateMachine) { this.stateMachine = stateMachine; } @Override public State getName() { return State.SUPER; } @Override public void obtainMushRoom() { // do nothing... } @Override public void obtainCape() { stateMachine.setCurrentState(new SmallMario(stateMachine)); stateMachine.setScore(stateMachine.getScore() + 200); } @Override public void obtainFireFlower() { stateMachine.setCurrentState(new SmallMario(stateMachine)); stateMachine.setScore(stateMachine.getScore() + 300); } @Override public void meetMonster() { stateMachine.setCurrentState(new SmallMario(stateMachine)); stateMachine.setScore(stateMachine.getScore() - 100); }}/** * 状态机 */public class MarioStateMachine { private int score; private IMario currentState; // 不再使用枚举来表示状态 public MarioStateMachine() { this.score = 0; this.currentState = new SmallMario(this); } public void obtainMushRoom() { this.currentState.obtainMushRoom(); } public void obtainCape() { this.currentState.obtainCape(); } public void obtainFireFlower() { this.currentState.obtainFireFlower(); } public void meetMonster() { this.currentState.meetMonster(); } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState.getName(); } public void setScore(int score) { this.score = score; } public void setCurrentState(IMario currentState) { this.currentState = currentState; }}在这种实现方式下，MarioStateMachine 的每次事件触发，最后会调用状态类自己的实现方式，但 MarioStateMachine 和 状态类是相互依赖的，之所以相互依赖是因为动作执行的结果最终记录在了 MarioStateMachine 中，而状态类本身代表状态，所以也被记录在了 MarioStateMachine 中。实际上上面的代码还不是最优，因为状态类并没有可变的成员变量，所以每种状态变量实际上可以设计成单例类，但是这样会导致它无法通过构造器传递 MarioStateMachine，解决办法很简单：在事件触发函数中通过参数进行传递即可。就像下面这样：" }, { "title": "观察者模式", "url": "/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-30 00:00:00 +0800", "snippet": "观察者模式原理和实现定义观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-SubscribeDesign Pattern）：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。一般来说依赖的对象被称为观察者（Observer）标准实现（模板代码）/** * 被观察者的上层接口 */public interface Subject { void registerObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(Message message);}/** * 观察者的上层接口 */public interface Observer { void update(Message message);}/** * 被观察者的实现类 */public class ConcreteSubject implements Subject { private List&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;Observer&amp;gt;(); @Override public void registerObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); } @Override public void notifyObservers(Message message) { for (Observer observer : observers) { observer.update(message); } }}/** * 观察者 1 号 */public class ConcreteObserverOne implements Observer { @Override public void update(Message message) { //TODO: 获取消息通知，执行自己的逻辑... System.out.println(&quot;ConcreteObserverOne is notified.&quot;); }}/** * 观察者 2 号 */public class ConcreteObserverTwo implements Observer { @Override public void update(Message message) { //TODO: 获取消息通知，执行自己的逻辑... System.out.println(&quot;ConcreteObserverTwo is notified.&quot;); }}/** * 启动类 */public class Demo { public static void main(String[] args) { ConcreteSubject subject = new ConcreteSubject(); subject.registerObserver(new ConcreteObserverOne()); subject.registerObserver(new ConcreteObserverTwo()); subject.notifyObservers(new Message()); }}截然不同的实现方式为什么需要观察者模式观察者是一种行为型设计模式，也就是定义中说的当对象的状态发生改变时，所有依赖的对象都应该接受通知，并作出一定的行为。以一个 P2P 投资理财系统为例，用户用户注册成功之后，我们会给用户发放投资体验金。代码大致如下：public class UserController { private UserService userService; // 依赖注入 private PromotionService promotionService; // 依赖注入 public Long register(String telephone, String password) { //省略输入参数的校验代码 //省略userService.register()异常的try-catch代码 long userId = userService.register(telephone, password); promotionService.issueNewUserExperienceCash(userId); return userId; }}显然注册接口做了两件事：注册用户和发放体验经，虽然职责并不单一，但如果不需要扩展需求，则当前代码是可以接受的。相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。这时候观察者模式就能被利用起来了，实际上观察者模式把不同的应对行为，如发放体验金、发放优惠券或者发送站内信抽象为了一个独立的观察者，这样就把经常变动的行为从被观察者中解耦出来了。这样新增或者删除观察者都不会影响到被观察者中的逻辑。同步阻塞的实现方式即观察者和被观察者代码在同一个线程内执行，如上面的模板代码。被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。异步非阻塞的实现方式还以 P2P 投资理财系统为例，如果注册接口是一个调用非常频繁的接口，对性能非常敏感，那么就可以采用异步非阻塞的实现方式： 让每个观察者的执行函数在新的线程中执行 以线程池的方式执行 基于 EventBus 来实现，比如 Google Guava EventBus// 第一种实现方式，频繁创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。public class RegPromotionObserver implements RegObserver { private PromotionService promotionService; // 依赖注入 @Override public void handleRegSuccess(Long userId) { Thread thread = new Thread(new Runnable() { @Override public void run() { promotionService.issueNewUserExperienceCash(userId); } }); thread.start(); }}// 第二种实现方式，线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分业务代码的维护成本。public class UserController { private UserService userService; // 依赖注入 private List&amp;lt;RegObserver&amp;gt; regObservers = new ArrayList&amp;lt;&amp;gt;(); private Executor executor; public UserController(Executor executor) { this.executor = executor; } public void setRegObservers(List&amp;lt;RegObserver&amp;gt; observers) { regObservers.addAll(observers); } public Long register(String telephone, String password) { //省略输入参数的校验代码 //省略userService.register()异常的try-catch代码 long userId = userService.register(telephone, password); for (RegObserver observer : regObservers) { executor.execute(new Runnable() { @Override public void run() { observer.handleRegSuccess(userId); } }); } return userId; }}这两种实现方式下缺点都挺严重，代码也很不优雅，并且如果我们的需求更加极端一点，需要在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。这样针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果，比如 Google Guava EventBus，当然你也可以实现自己的 EventBus（但尽量不要重复造轮子）跨进程的观察者模式上面描述的同步阻塞和异步非阻塞实现方式都是在同一个进程中进行的，那如何跨进程实现观察者模式呢？ 调用 RPC 接口发送数据 基于消息队列（如 ActiveMQ）实现基于消息队列的方式实现下，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。缺点是需要引入一个新的系统（消息队列），增加了维护成本。" }, { "title": "模板模式", "url": "/posts/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-30 00:00:00 +0800", "snippet": "原理与实现模板模式是我认为最简单的一种设计模式，因为学 java 的对继承一定再熟悉不过了吧，而模板模式就是基于继承，或者说就是继承的衍生用法。定义模板方法模式在一个方法中定义一个算法骨架（即模板），并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。简单实现/** * 模板父类 */public abstract class TemplateClass { //模板方法被 final 修饰，不允许子类重写 public final void templateMethod() { //... method1(); //... method2(); //... } //子类方法声明为 abstract 方法，由子类自定义实现 protected abstract void method1(); protected abstract void method2();}public class ConcreteClass1 extends AbstractClass { @Override protected void method1() { //... } @Override protected void method2() { //... }}public class ConcreteClass2 extends AbstractClass { @Override protected void method1() { //... } @Override protected void method2() { //... }}TemplateClass demo = ConcreteClass1();demo.templateMethod();当然这是模板模式最经典的写法，并不是说模板方法就一定非要使用 final 修饰，抽象方法也不是说非要用 abstract 给它修饰一下子类才能重写。实际上写法很灵活，重点能体现模板的复用效果即可。JDK 内部由很多类使用到了模板方法，比如 InputStream 的 read() 这就是一个应用了模板模式的方法。模板模式的另一个作用是扩展，其实再框架内部会经常使用到模板模式的，毕竟框架是业务当中不变的部分被抽出来单独成立，而变得部分就需要开发者自定义实现，这就正好是模板模式的拿手好戏。就比如 Java Servlet，学习 Java 的时候一定再 web 开发的初期接触过它，使用它分两步，①继承 HttpServlet 并分别实现 doGet &amp;amp;&amp;amp; doPost 方法。②在 xml 中配置 servlet &amp;lt;==&amp;gt; url 的映射。而 HttpServlet 中的 service() 方法它就是一个应用了模板模式的方法。它的内部骨架化 web 流程，只留下 doPost &amp;amp;&amp;amp; doGet 给开发者定制。这就相当于Servlet框架提供了一个扩展点（doGet()、doPost()方法），让框架用户在不用修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。模板模式与 Callback 回调函数实际上 Callback 的实现方式与模板模式完全不同，那么 Callback 是什么，还记得 Java 的函数式编程吗，虽然说函数式是一种编程方式，但其实它的实现形式就是 Callback 这种，如下：public interface ICallback { void methodToCallback();}public class BClass { public void process(ICallback callback) { //... callback.methodToCallback(); //... }}public class AClass { public static void main(String[] args) { BClass b = new BClass(); //回调函数传递给了对象 b，在 java 中就体现成了ICallback 匿名对象传递给了 b b.process(new ICallback() { //回调对象 @Override public void methodToCallback() { System.out.println(&quot;Call back me.&quot;); } }); }}像这样开发者可以自由实现回调函数并将它传递给其他对象，这样程序就具有了可扩展性和复用的功能，实际上不仅在代码设计上，在更高层次的架构设计上它也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。回调函数又分为同步回调 &amp;amp;&amp;amp; 异步回调，像上面的经典实现就是同步回调，因为调用者需要等到回调函数执行完毕，才能继续执行并返回执行结果。回调函数的应用举例 JdbcTemplate 的 query() 和 execute() 安卓客户端 setClickListener() Tomcat/JVM 的钩子函数（hook）模板模式 VS 回调 应用场景几乎相同，基本在框架中用的比较多。 实现上回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。前面也学过组合由于继承，这里也不例外：回调相对模板模式会更加灵活，主要体现在下面这几个方面： 像Java这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。 回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。 如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。" }, { "title": "享元模式", "url": "/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-30 00:00:00 +0800", "snippet": "享元模式原理与实现定义所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。 定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。实现以一个象棋游戏为例，一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。在不使用享元模式之前，代码是这样的：public class ChessPiece {//棋子 private int id; private String text; private Color color; private int positionX; private int positionY; public ChessPiece(int id, String text, Color color, int positionX, int positionY) { this.id = id; this.text = text; this.color = color; this.positionX = positionX; this.positionY = positionX; } public static enum Color { RED, BLACK } // ...省略其他属性和getter/setter方法...}public class ChessBoard {//棋局 private Map&amp;lt;Integer, ChessPiece&amp;gt; chessPieces = new HashMap&amp;lt;&amp;gt;(); public ChessBoard() { init(); } private void init() { chessPieces.put(1, new ChessPiece(1, &quot;車&quot;, ChessPiece.Color.BLACK, 0, 0)); chessPieces.put(2, new ChessPiece(2,&quot;馬&quot;, ChessPiece.Color.BLACK, 0, 1)); //...省略摆放其他棋子的代码... } public void move(int chessPieceId, int toPositionX, int toPositionY) { //...省略... }}由于我们需要给每个房间都创建一个 ChessBoard 棋局对象，但游戏大厅往往会有成千上万的房间，甚至于上百万，这样的实现将消耗大量的内存，那么如何节省内存实现对象的复用呢？享元模式就派上用场了，像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：// 享元类public class ChessPieceUnit { private int id; private String text; private Color color; public ChessPieceUnit(int id, String text, Color color) { this.id = id; this.text = text; this.color = color; } public static enum Color { RED, BLACK } // ...省略其他属性和getter方法...}public class ChessPieceUnitFactory { private static final Map&amp;lt;Integer, ChessPieceUnit&amp;gt; pieces = new HashMap&amp;lt;&amp;gt;(); static { pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK)); pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK)); //...省略摆放其他棋子的代码... } public static ChessPieceUnit getChessPiece(int chessPieceId) { return pieces.get(chessPieceId); }}public class ChessPiece { private ChessPieceUnit chessPieceUnit; private int positionX; private int positionY; public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) { this.chessPieceUnit = unit; this.positionX = positionX; this.positionY = positionY; } // 省略getter、setter方法}public class ChessBoard { private Map&amp;lt;Integer, ChessPiece&amp;gt; chessPieces = new HashMap&amp;lt;&amp;gt;(); public ChessBoard() { init(); } private void init() { chessPieces.put(1, new ChessPiece( ChessPieceUnitFactory.getChessPiece(1), 0,0)); chessPieces.put(1, new ChessPiece( ChessPieceUnitFactory.getChessPiece(2), 1,0)); //...省略摆放其他棋子的代码... } public void move(int chessPieceId, int toPositionX, int toPositionY) { //...省略... }}在这种实现下所有的 ChessBoard 对象将共享这 30 个 ChessPieceUnit 对象，从数据来看为了记录 1 万个棋局在使用享元模式之前我们需要创建 30 万个 ChessPieceUnit 对象，使用之后之创建了 30 个享元对象供所有棋局共享使用即可，大大节省了内存。享元模式 vs 单例、缓存、对象池享元模式与单例享元对象类似多例，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。享元模式与缓存 复用的意图是多个子系统共用一个/多个对象 缓存对于同一份数据会在不同的地方拷贝多份，以便快速获取享元模式与对象池 池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。 享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。 什么是对象池为了避免频繁地进行对象创建和释放导致内存碎片，我们预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。享元模式在 Integer 和 String 中的应用享元模式与 IntegerInteger 实际上就使用到了享元模式，它的工厂类是 IntegerCache，IntegerCache 缓存了 -128~127 的 Integer 对象，在这个范围内的 Integer 数据最终都指向同一个对象在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。Integer a = new Integer(123);Integer a = 123;Integer a = Integer.valueOf(123);在后两种情况下会使用到 IntegerCache，能达到节省内存的目的。享元模式与 String相对于工厂类，JVM 专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”String s1 = &quot;flameking&quot;;String s2 = &quot;flameking&quot;;String s3 = new String(&quot;flameking&quot;); // new 新开辟一块空间进行存放，而非放在字符串常量池当中System.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // false与 Integer 类的设计不同，String 类的享元设计并非一开始就集中创建好所有的字符串常量，事实上我们没法知道哪些字符串常量是需要共享的，所以只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。" }, { "title": "门面模式", "url": "/posts/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-29 00:00:00 +0800", "snippet": "平衡接口粒度接口粒度更细（职责单一） 接口具有更好的可复用性 接口的使用者开发一个业务功能时，需要调用 n 多细粒度的接口才能完成，调用者会抱怨接口不好用。接口粒度设计得太大 一个接口能做更多的事 可复用性不好。那针对不同的业务需求，就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。 那如何来解决接口的可复用性（通用性）和易用性之间的矛盾呢？门面模式！门面模式的原理和实现定义门面模式，也叫外观模式，英文全称是 Facade Design Pattern。它的定义如下：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。 门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。如何理解门面模式的定义假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。这就是门面模式的体现为什么要设计一个统一的接口，一个个调用更细粒度的接口不行吗有一个具体的应用场景：系统 A 是一个后端服务器，系统 B 是 APP 客户端。App客户端通过后端服务器提供的接口来获取数据。我们知道，App和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高App的响应速度，我们要尽量减少App与服务器之间的网络通信次数。假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接口，因自身业务的特点，不支持并发调用这三个接口。现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。常见应用场景解决易用性问题门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。解决性能问题比如通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高App客户端的响应速度。解决分布式事务问题在一个金融系统中，有两个业务领域模型，用户和钱包。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库User表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。显然用户注册需要支持事务，即创建用户和钱包的两个操作，要么都成功，要么都失败。然后两个不同服务的接口调用在同一个事务中执行比较难实现，这涉及到分布式事务问题，虽然可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。" }, { "title": "迁移Postgres的Sequence（序列）", "url": "/posts/%E8%BF%81%E7%A7%BBPostgres%E7%9A%84Sequence-%E5%BA%8F%E5%88%97/", "categories": "数据库, pgsql", "tags": "", "date": "2023-01-29 00:00:00 +0800", "snippet": "如何在迁移数据库时导出 SEQUENCEnavicat 转储数据和结构 sql 时无法生成自增序列的 sql，但 pgAdmin4 做到了，下面是 pgAdmin 导入和导出 sql 的操作演示：下面是导入操作：如何创建 SEQUENCE 创建序列：CREATE SEQUENCE my_sequence INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 99999999 CACHE 1; 为序列赋予操作权限：ALTER SEQUENCE my_sequence OWNER TO postgres; 关联到表主键：alter table my_table alter column my_id set default nextval(‘my_sequence’);如何正确修改 SEQUENCE 序列（Sequence）的当前值（Currval）无法通过 pg_dump导出，又不能对源实例做修改，得这么办才行。在结构导出时，序列（Sequence）的当前值无法通过pg_dump导出，只能通过事后查询该序列的当前值并写入目标库。查询序列的当前值，有两种办法： select currval(‘seqname’) 仅获得当前会话最后一次生成的值。实际执行中，必须先执行 nextval 后才能执行currval，这样会修改源数据库，不可取 select last_value from seqname 获得所有会话中最后一次生成的值修改目标库序列的当前值，也有两种办法： select setval(‘seqname’, val) 修改序列当前值（原子操作） alter sequence seqname restart with val 修改序列当前值（阻塞性事务，会阻塞其他会话的nextval操作）建议采用的方案既可以干净地获取源值，又能低成本地设置到目标。 select last_value from seqname 获得源库当前值 select setval(‘seqname’, val) 在目标库设置目标值" }, { "title": "组合模式", "url": "/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-29 00:00:00 +0800", "snippet": "组合模式的原理和实现定义组合模式跟之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，可以简单理解为一组对象集合，它的定义如下：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。光看定义不知所云，下面举个例子翻译一下：假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能： 动态地添加、删除某个目录下的子目录或文件； 统计指定目录下的文件个数； 统计指定目录下的文件总大小。下面是骨架代码：import java.io.File;import java.util.ArrayList;import java.util.List;/** * 目录/文件节点 */public class FileSystemNode { private String path; private boolean isFile; private List&amp;lt;FileSystemNode&amp;gt; subNodes = new ArrayList&amp;lt;&amp;gt;(); public FileSystemNode(String path, boolean isFile) { this.path = path; this.isFile = isFile; } public int countNumOfFiles() { if (isFile) { return 0; } return countNumOfFiles(0, this); } /** * 这才是递归，虽然放在这个类里面不合适(放在一个公共类里面会更合适，或者是作为静态方法)，毕竟这个方法除了计算当前节点还能计算其他节点 * @param num * @param node */ public int countNumOfFiles(int num, FileSystemNode node) { if (node.isFile) { return 1; } for (FileSystemNode systemNode : node.getSubNodes()) { num += countNumOfFiles(0, systemNode); } return num; } /** * 这个方法不叫递归哈 */ public long countSizeOfFiles() { if (isFile) { File file = new File(path); if (!file.exists()) return 0; return file.length(); } long sizeofFiles = 0; for (FileSystemNode fileOrDir : subNodes) { sizeofFiles += fileOrDir.countSizeOfFiles(); } return sizeofFiles; } public String getPath() { return path; } public List&amp;lt;FileSystemNode&amp;gt; getSubNodes() { return subNodes; } public void addSubNode(FileSystemNode fileOrDir) { subNodes.add(fileOrDir); } public void removeSubNode(FileSystemNode fileOrDir) { int size = subNodes.size(); int i = 0; for (; i &amp;lt; size; ++i) { if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) { break; } } if (i &amp;lt; size) { subNodes.remove(i); } }}在上面这段代码中，对于文件直接返回文件的个数/大小，对于目录就去遍历内部的子目录和文件，递归计算它们的个数/大小，然后求和。对照着定义：将一组对象（目录/文件构成的节点）组织成树形结构，以表示一种‘部分-整体’的层次结构（节点与子节点）。组合模式让客户端可以统一单个对象（目录/文件）和组合对象（节点）的处理逻辑（递归遍历）其实这里的组合对象从算法与数据结构的角度来看就是开发者自定义的新的数据结构（其满足树形结构的特点）。" }, { "title": "导入导出注解式解决方案", "url": "/posts/%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%B3%A8%E8%A7%A3%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/", "categories": "项目", "tags": "", "date": "2023-01-13 00:00:00 +0800", "snippet": "需求从何而来 减少导入导出 dto/vo 的新建，希望配合注解和 entity 解决（注解的 type 标识是否 import or import 这样能减少 dto/vo 类的数量），其中注解可用于标注语义转换（如 1 - &amp;gt; 男，0 -&amp;gt; 女） 相关值得校验耦合在了业务代码中，可以在 Service 定义自己的 importValid 方法，并用 StringBuilder 进行处理统一转 String 返回；RuoYi 的 ExcelUtil导入supported 支持标题行索引的设置 支持指定 sheetName 进行读取 支持默认导入第一个 sheet如下是导入方法的重载方法：unsupported 不支持多张表导入导出对导入的数据进行校验数据往往要经过哪些校验 字符串长度限制 单元格对应的字段值是否允许重复 是否可为空（必填项） 编号等编码自动生成规则（是否按照地域等要素生成） 某些值属于固定值（如字典项），避免用户填入错误的值 浮点值的位数，定义小数位数的规则 异常数据格式导入的处理手段" }, { "title": "适配器模式", "url": "/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-09 00:00:00 +0800", "snippet": "适配器模式的原理和实现适配器模式（Adapter Design Pattern），顾名思义：一种接口通过适配器模式能够当成另一种接口进行使用，它的意义是能够通过多态的方法，使得新增的接口能在不改变上层调用的实现就可以迅速接洽到程序中。适配器模式的两种实现方式类适配器使用继承关系来实现，对象适配器使用组合关系来实现实现方式如下：其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。类适配器示例 code 如下：// 类适配器: 基于继承public interface ITarget { void f1(); void f2(); void fc();}public class Adaptee { public void fa() { /**...*/ } public void fb() { /**...*/ } public void fc() { /**...*/ }}public class Adaptor extends Adaptee implements ITarget { public void f1() { super.fa(); } public void f2() { //...重新实现f2()... } // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点}对象适配器示例 code 如下：public interface ITarget { void f1(); void f2(); void fc();}public class Adaptee { public void fa() { /**...*/ } public void fb() { /**...*/ } public void fc() { /**...*/ }}public class Adaptor implements ITarget { private Adaptee adaptee; public Adaptor(Adaptee adaptee) { this.adaptee = adaptee; } public void f1() { adaptee.fa(); //委托给Adaptee } public void f2() { //...重新实现f2()... } public void fc() { adaptee.fc(); }}两种方式各在什么时候使用标准主要有两个：一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。 如果Adaptee接口并不多，那两种实现方式都可以。 如果Adaptee接口很多，而且 Adaptee 和 ITarget 接口定义大部分相同，推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分不同，推荐使用对象适配器，因为组合结构相对于继承更加灵活适配器应用场景一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。适配器模式的应用场景是 “接口不兼容”，实际开发中在下面这些情况下会出现接口不兼容：封装有缺陷的接口设计假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。具体 code 如下：public class CD { //这个类来自外部sdk，我们无权修改它的代码 //... public static void staticFunction1() { /**...*/ } public void uglyNamingFunction2() { /**...*/ } public void tooManyParamsFunction3(int paramA, int paramB, ...) { /**...*/ } public void lowPerformanceFunction4() { /**...*/ }}// 使用适配器模式进行重构public interface ITarget { void function1(); void function2(); void fucntion3(ParamsWrapperDefinition paramsWrapper); void function4(); //...}// 注意：适配器类的命名不一定非得末尾带Adaptorpublic class CDAdaptor extends CD implements ITarget { public void function1() { /** * 注意这里使用了 super 引用父类的静态方法，super 的作用如下： * 1.调用父类的方法 * 2.调用父类的构造器 * 注意：与 this 不同，super 不是一个引用变量，不能将它赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键词 */ super.staticFunction1(); } public void function2() { super.uglyNamingFucntion2(); } public void function3(ParamsWrapperDefinition paramsWrapper) { super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...); } public void function4() { //...reimplement it... }}统一多个类的接口设计某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率（指能尽可能多的过滤掉敏感词），我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。code 如下：public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口 //text是原始文本，函数输出用***替换敏感词之后的文本 public String filterSexyWords(String text) { // ... } public String filterPoliticalWords(String text) { // ... } }public class BSensitiveWordsFilter { // B敏感词过滤系统提供的接口 public String filter(String text) { //... }}public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口 public String filter(String text, String mask) { //... }}// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好public class RiskManagement { private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter(); private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter(); private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter(); public String filterSensitiveWords(String text) { String maskedText = aFilter.filterSexyWords(text); maskedText = aFilter.filterPoliticalWords(maskedText); maskedText = bFilter.filter(maskedText); maskedText = cFilter.filter(maskedText, &quot;***&quot;); return maskedText; }}// 使用适配器模式进行改造public interface ISensitiveWordsFilter { // 统一接口定义 String filter(String text);}public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter { private ASensitiveWordsFilter aFilter; public String filter(String text) { String maskedText = aFilter.filterSexyWords(text); maskedText = aFilter.filterPoliticalWords(maskedText); return maskedText; }}//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。public class RiskManagement { private List&amp;lt;ISensitiveWordsFilter&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;(); public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) { filters.add(filter); } public String filterSensitiveWords(String text) { String maskedText = text; for (ISensitiveWordsFilter filter : filters) { maskedText = filter.filter(maskedText); } return maskedText; }}替换依赖的外部系统当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。code 如下：// 外部系统Apublic interface IA { //... void fa();}public class A implements IA { //... public void fa() { /**...*/ }}// 在我们的项目中，外部系统A的使用示例public class Demo { private IA a; public Demo(IA a) { this.a = a; } //...}Demo d = new Demo(new A());// 将外部系统A替换成外部系统Bpublic class BAdaptor implemnts IA { private B b; public BAdaptor(B b) { this.b= b; } public void fa() { //... b.fb(); }}// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，// 只需要将BAdaptor如下注入到Demo即可。Demo d = new Demo(new BAdaptor(new B()))兼容老版本接口在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。比如在 JDK1.0 中，包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从 JDK2.0 中删除，那使用JDK1.0的项目如果切换到JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到Enumeration的地方，都修改为使用Iterator才行单独一个项目做Enumeration到Iterator的替换，勉强还能接受。但是，使用Java开发的项目太多了，一次JDK的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为直接调用Itertor。code 如下：public class Collections { public static Emueration emumeration(final Collection c) { return new Enumeration() { Iterator i = c.iterator(); public boolean hasMoreElments() { return i.hashNext(); } public Object nextElement() { return i.next(): } } }}前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。List&amp;lt;String&amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);剖析适配器模式在 Java 日志中的应用java中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有log4j、logback，以及JDK提供的JUL(java.util.logging)和Apache的JCL(JakartaCommons Logging)等。大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像JDBC那样，一开始就制定了数据库操作的接口规范。比如，项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。于是 Slf4j 横空出世，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。code 如下：// slf4j统一的接口定义package org.slf4j;public interface Logger { public boolean isTraceEnabled(); public void trace(String msg); public void trace(String format, Object arg); public void trace(String format, Object arg1, Object arg2); public void trace(String format, Object[] argArray); public void trace(String msg, Throwable t); public boolean isDebugEnabled(); public void debug(String msg); public void debug(String format, Object arg); public void debug(String format, Object arg1, Object arg2) public void debug(String format, Object[] argArray) public void debug(String msg, Throwable t); //...省略info、warn、error等一堆接口}// log4j日志框架的适配器// Log4jLoggerAdapter实现了LocationAwareLogger接口，// 其中LocationAwareLogger继承自Logger接口，// 也就相当于Log4jLoggerAdapter实现了Logger接口。package org.slf4j.impl;public final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger, Serializable { final transient org.apache.log4j.Logger logger; // log4j public boolean isDebugEnabled() { return logger.isDebugEnabled(); } public void debug(String msg) { logger.log(FQCN, Level.DEBUG, msg, null); } public void debug(String format, Object arg) { if (logger.isDebugEnabled()) { FormattingTuple ft = MessageFormatter.format(format, arg); logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); } } public void debug(String format, Object arg1, Object arg2) { if (logger.isDebugEnabled()) { FormattingTuple ft = MessageFormatter.format(format, arg1, arg2); logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); } } public void debug(String format, Object[] argArray) { if (logger.isDebugEnabled()) { FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray); logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); } } public void debug(String msg, Throwable t) { logger.log(FQCN, Level.DEBUG, msg, t); }//...省略一堆接口的实现...}所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用Java的SPI技术），只需要将相应的SDK导入到项目中即可。不过，你可能会说，如果一些老的项目没有使用Slf4j，而是直接使用比如JCL来打印日志，那如果想要替换成其他日志框架，比如log4j，该怎么办呢？实际上，Slf4j不仅仅提供了从其他日志框架到Slf4j的适配器，还提供了反向适配器，也就是从Slf4j到其他日志框架的适配。我们可以先将JCL切换为Slf4j，然后再将Slf4j切换为log4j。经过两次适配器的转换，我们就能成功将JCL切换为了log4j。代理、桥接、装饰器、适配器4种设计模式的区别代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。尽管代码结构相似，但这4种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。代理模式代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。桥接模式桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。装饰器模式装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。适配器模式适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。" }, { "title": "备忘录模式", "url": "/posts/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-08 00:00:00 +0800", "snippet": "定义来自 GOF 的定义：Captures and externalizes an object’s internal state so that it can berestored later, all without violating encapsulation.翻译过来就是：在不违反封装原则的前提下，捕获并外部化一个对象的内部状态，以便将来可以恢复到这个状态。从定义来看还是非常容易理解的，即将对象在内存某一时刻的状态给它拷贝一份保留下来，以便后续随时恢复到这个状态。另外是它的前提，不违反封装原则，即：原则意义上复制品或者说快照，不允许被其他对象修改，只能通过原对象进行设置/恢复。显然如果违反这个原则，该模式就没法有效的起到它的作用，比如快照可能被其他对象修改/被其他对象使用。演示示例下面是一个非常通俗的演示示例：// 定义备忘录类class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; }}// 定义原始类class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } public Memento saveStateToMemento() { return new Memento(state); } public void getStateFromMemento(Memento memento) { state = memento.getState(); }}// 定义负责人类行为class CareTaker { private List&amp;lt;Memento&amp;gt; mementoList = new ArrayList&amp;lt;Memento&amp;gt;(); public void add(Memento state) { mementoList.add(state); } public Memento get(int index) { return mementoList.get(index); }}// 测试类public class MementoPatternDemo { public static void main(String[] args) { Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(&quot;State #1&quot;); originator.setState(&quot;State #2&quot;); careTaker.add(originator.saveStateToMemento()); originator.setState(&quot;State #3&quot;); careTaker.add(originator.saveStateToMemento()); originator.setState(&quot;State #4&quot;); System.out.println(&quot;Current State: &quot; + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println(&quot;First saved State: &quot; + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println(&quot;Second saved State: &quot; + originator.getState()); }}这段代码演示了备忘录设计模式的实现，该模式的主要目的是在不破坏封装性的情况下，允许在对象之间保存和恢复状态。在这个例子中，有三个类：Originator（原始类）、Memento（备忘录类）和CareTaker（负责人类）。Originator类维护了一个状态属性state，并提供了saveStateToMemento()和getStateFromMemento()方法来创建备忘录对象和从备忘录对象中恢复状态。saveStateToMemento()方法创建并返回一个Memento对象，该对象封装了当前的状态属性值，而getStateFromMemento()方法接收一个Memento对象，用于从中获取状态属性值并还原到原始类的state属性中。Memento类定义了一个名为state的私有属性，并提供了一个构造函数和一个getState()方法，构造函数用于初始化state属性，getState()方法用于返回当前的状态属性值。CareTaker类维护了一个Memento对象列表，提供了add()和get()方法来向列表中添加备忘录对象以及从列表中获取备忘录对象。在这个例子中，CareTaker类用于存储Originator对象的不同状态快照。在main()方法中，创建了一个Originator对象和一个CareTaker对象，并对Originator对象的状态属性进行多次修改，每次修改后调用saveStateToMemento()方法创建备忘录对象并存储到CareTaker对象中。在最后，通过调用getStateFromMemento()方法，从不同的备忘录对象中恢复Originator对象的状态，并输出当前状态的值。该设计模式的优点是可以使得对象的状态恢复到之前的某个状态，而且不会破坏其封装性和整体的内聚性。缺点是如果需要保存的状态数据量很大，将会占用较大的内存空间。如何优化内存和时间消耗？上面的示例缺点很明显：如果要备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题该如何解决呢？有一个通用的解决方案：“低频率全量备份”和“高频率增量备份”相结合的方法。全量备份即快照，所谓“增量备份”，指的是记录每次操作或数据变动。事实上 MySQL 的 redo log 和 binlog 就是采用的增量备份的方式。优化备忘录设计模式除了上述的缺点，备忘录设计模式本身其实并不完美，通常还可使用下面这些方法进行优化： 可以使用多个备忘录对象来存储不同时间点的状态，而不仅仅是一个备忘录对象存储当前状态。这样可以更好地支持撤销和重做操作。 可以对备忘录对象进行压缩和序列化，以便在存储备忘录对象时占用更少的内存，并允许备忘录对象在不同系统之间传输。 可以使用观察者模式，当原始对象的状态发生更改时，自动通知所有的备忘录对象，以便它们可以更新自己的状态。 可以使用代理模式来代替备忘录对象的创建和管理，以便可以更好地控制备忘录对象的访问和修改。代理模式还可以实现更高级的功能，例如动态创建和销毁备忘录对象，或者允许只读访问备忘录对象等。" }, { "title": "装饰器模式", "url": "/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-08 00:00:00 +0800", "snippet": "装饰器模式在 Java IO 中的应用Java IO 类可分为下面四个维度：而根据不同的读取和使用场景 Java IO 又在这四个父类基础之上，扩展出了很多子类：但我们重点关注上图中最右边的一个类 BufferedInputStream，首先看下它的用法：InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);InputStream bin = new BufferedInputStream(in);byte[] data = new byte[128];while (bin.read(data) != -1) { //...}实际上 BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。但是按照平常的思维，我们会设计一个继承自 FileInputStream 的类，根据哪个方法需要缓存功能去自定义实现，但事实上，BufferedInputStream 并没有去继承 FileInputStream为什么前面我们学过组合优于继承，而 Java IO 的设计确实不能大量使用继承，因为根据基于以上四个父类派生了大量的子类，而每个子类都需要缓存功能，或者是其他很多功能的话，使用继承就会让类的继承关系变得异常复杂和冗余。而 Java IO 的设计恰恰是巧妙的应用了装饰器模式，实现方式具体可查看 JDK 源码，实际上它的实现方式就跟代理模式一模一样，只不过二者的区别是：代理模式常用与在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志，而装饰器模式附加的增强功能往往跟原始类是相关的。总结装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。/** * 嵌套使用 */InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);InputStream bin = new BufferedInputStream(in);DataInputStream din = new DataInputStream(bin);int data = din.readInt();" }, { "title": "桥接模式", "url": "/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2023-01-08 00:00:00 +0800", "snippet": "JDBC 与 MySQL、Oracle 等驱动实现的联系如何做到在不修改代码或者很少修改代码的情况下切换数据库JDBC 是作为规范抽离出来的框架，而 MySQL、Oracle 驱动是在遵循规范的基础上根据自身数据库做的一套实现。而 JDBC 和 MySQL、Oracle 驱动之间通过组合实现了如此优雅的数据库切换方式，而这便是桥接模式的一种经典使用场景。定义将抽象和实现解耦，让它们可以独立变化。" }, { "title": "如何调用本业务模块外的服务——服务调用", "url": "/posts/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%9C%AC%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97%E5%A4%96%E7%9A%84%E6%9C%8D%E5%8A%A1-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/", "categories": "项目, 商场停车", "tags": "", "date": "2023-01-05 00:00:00 +0800", "snippet": "服务调用方式既然引入了注册中心来统一的管理服务的每个实例，那么我们就可以大方的去调用其他的服务了。服务间调用常见的两种方式：RPC 与 HTTP： RPC 全称 Remote Produce Call 远程过程调用，速度快，效率高，早期的 WebService 接口，现在热门的 Dubbo、gRPC 、Thrift、Motan 等，都是 RPC 的典型代表 HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准。对服务的提供者和调用方没有任何语言限定，更符合微服务语言无关的理念。时下热门的 RESTful 形式的开发方式，也是通过 HTTP 协议来实现的。Spring Cloud 体系下常用的 HTTP 调用方式 RestTemplate，是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法，能够大大提高客户端的编写效率。 Ribbon，由 Netflix 出品，更为人熟知的作用是客户端的 Load Balance（负载均衡）。 Feign，同样由 Netflix 出品，是一个更加方便的 HTTP 客户端，用起来就像调用本地方法，完全感觉不到是调用的远程方法。内部也使用了 Ribbon 来做负载均衡功能。RestTemplate当我们使用 Java 编写客户端发送 HTTP 请求时，通常需要使用一些辅助库。RestTemplate 是 Spring Framework 中用于简化 HTTP 请求的一个模块。它提供了对 GET、POST、PUT 和 DELETE 等 HTTP 请求方法的支持，同时支持 URI 模板、请求/响应拦截、错误处理等一系列功能。使用 RestTemplate，我们可以以一种非常简单和直观的方式发送 HTTP 请求，如：RestTemplate restTemplate = new RestTemplate();String response = restTemplate.getForObject(&quot;http://example.com/api/resource&quot;, String.class);这里我们创建了一个 RestTemplate 实例，然后使用其 getForObject() 方法发送了一个 GET 请求到指定的 URI。该方法返回了一个类型为 String 的响应体。通过 RestTemplate，我们无需手动处理 HTTP 连接、请求头、请求体等一系列细节，可以非常方便地发送 HTTP 请求并解析响应。除了 getForObject() 方法，RestTemplate 还提供了一系列其他的请求方法，如 getForEntity()、postForObject()、postForEntity() 等，以及一些辅助方法，如 exchange()、execute() 等。这些方法都非常灵活，可以根据具体需求选择使用。另外，通过为 RestTemplate 配置相应的拦截器和错误处理器，我们还可以对请求和响应进行进一步的处理。这使得我们可以更加精细地控制 HTTP 请求过程中的各个环节，并对错误进行处理。总之，RestTemplate 是一个功能强大且易于使用的 HTTP 请求工具，特别适合用于开发基于 RESTful 风格的 Web 服务的客户端。FeignFegin 的调用最大的便利之处在于，屏蔽底层的连接逻辑，让你可以像调用本地接口一样调用第三方服务，代码量更少更优雅。当然，必须在服务注册中心的协调下才能正常完成服务调用（如果不在同一注册中心下的服务/不同的项目，则需要其他的 HTTP 客户端工具，如 Apache HttpClient 和 RestTemplate），而 RestTemplate 并不关心服务注册心是否正常运行。Feign 是由 Netflix 开发出来的另外一种实现负载均衡的开源框架，它封装了 Ribbon 和 RestTemplate，实现了 WebService 的面向接口编程，进一步的减低了项目的耦合度，因为它封装了 Riboon 和 RestTemplate ，所以它具有这两种框架的功能。 在会员模块的 pom.xml 中添加 jar 引用：&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;&amp;lt;/dependency&amp;gt;在客户端的模块启动类（接口调用方一般称为客户端）中增加 @EnableFeignClients 注解，才能正常使用 Feign 相关功能，启动时开启对 ＠FeignClient 注解的包扫描，并且扫描到相关的接口客户端。如下面的调用，parking-member 是客户端，而 parking-credit 是接口提供方：//parking-member 启动类@EnableFeignClients(basePackages = &quot;com.flameking.parking.member.client&quot;)public class ParkingMemberApplication { public static void main(String[] args) { SpringApplication.run(ParkingMemberApplication.class, args); }}//待扫描的 parking-credit 接口@FeignClient(&quot;paring-credit&quot;)public interface CreditClient { /** * 添加积分交易流水记录 * * @param creTransaction * @return 新添加记录的ID */ @PostMapping(&quot;/api/creTransaction/create&quot;) CommonResult&amp;lt;String&amp;gt; insert(@Valid @RequestBody CreTransactionDTO creTransaction);}使用 IDEA 运行类似的程序时有一个缺陷：一旦接口提供方代码发生了变化就需要按照提供方 -&amp;gt; 客户端的次序分别对服务进行重启。这样在测试代码的时候就非常的浪费时间（未找到解决方案）" }, { "title": "服务多不易管理如何破——服务注册与发现", "url": "/posts/%E6%9C%8D%E5%8A%A1%E5%A4%9A%E4%B8%8D%E6%98%93%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E7%A0%B4-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/", "categories": "项目, 商场停车", "tags": "", "date": "2022-12-30 00:00:00 +0800", "snippet": "服务调用问题在业务分析当中，有个简单的功能点：会员可以开通月卡，开通月卡的同时，需要增加相应的积分。开通月卡功能在会员服务模块维护，但增加积分功能在积分服务模块维护，这就涉及到两个模块间的服务调用问题。单实例（单机）情况：可以采用点对点的 HTTP 直接调用，采用 IP + Port + 接口的形式进行。在实际的业务开发过程中，越来越多的产品开发采用轻量级的 HTTP 协议进行数据交互。如果模块增多，将会形成蜘蛛网的形式，非常不利于开发维护。多实例的情况：为应对服务的压力，采用多实例集群部署已成为简捷易用的解决方案。仅仅多实例部署后，将直接面临多个严峻问题： 调用方如何知晓调用哪个实例，当实例运行失败后，如何转移到别的实例上去处理请求？ 如果采用了负载均衡，但往往是静态的，在服务不可用时，如何动态的更新负载均衡列表，保证调用者的正常调用呢？面对以上两种情况，为了将所有的服务（实例）统一的、动态的管理起来，服务注册中心的需求迫在眉捷。服务注册中心服务注册中心作分布式服务框架的核心模块，可以看出要实现的功能是服务的注册、订阅，与之相应的功能是注销、通知这四个功能。所有的服务都与注册中心发生连接，由注册中心统一配置管理，不再由实例自身直接调用。服务管理过程大致过程如下： 服务提供者启动时，将服务提供者的信息主动提交到服务注册中心进行服务注册。 服务调用者启动时，将服务提供者信息从注册中心下载到调用者本地，调用者从本地的服务提供者列表中，基于某种负载均衡策略选择一台服务实例发起远程调用，这是一个点到点调用的方式。 服务注册中心能够感知服务提供者某个实例下线，同时将该实例服务提供者信息从注册中心清除，并通知服务调用者集群中的每一个实例，告知服务调用者不再调用本实例，以免调用失败。在开发过程中有很多服务注册中心的产品可供选择： Consul Zookeeper Etcd Eureka Nacos比如 Dubbo 开发时经常配合 Zookeeper 使用，Spring Cloud 开发时会配合 Eureka 使用，社区都提供相当成熟的实施方案，本次将采用 NacosNacos 应用官网地址：https://nacos.io/en-us/，由阿里开源，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台，已经作为 Spring Cloud Alibaba 的一个子项目，更好与 Spring Cloud 融合在一起。下载应用本次采用 1.4.1 版本，下载地址，Windows 版本下载后，目录结构如下：启动应用此时直接双击 startup.cmd 启动会报错，正确操作应该是打开命令行输入下面的命令：# 单机启动 nacosstartup.cmd -m standalone界面如下，用户密码都默认：nacos服务中应用 nacos首先在父项目工程中依赖管理中引入 Spring Cloud、Spring Cloud Alibaba（它是后来加的，所以与Spring Cloud 不是同一个依赖）和 Spring Boot：SpringBoot、Spring Cloud、Spring Cloud Alibaba 版本之间的适配见：版本间的适配&amp;lt;!-- SpringBoot --&amp;gt;&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Spring Cloud 和 Spring cloud Alibaba --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Hoxton.SR9&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-alibaba-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.6.RELEASE&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/dependencyManagement&amp;gt;然后再子模块中引入 nacos 依赖：&amp;lt;dependencies&amp;gt; &amp;lt;!-- nacos 服务注册中心 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;最后在子模块启动类/配置类添加注解 @EnableDiscoveryClient，同时修改配置文件：spring: application: name: paring-member cloud: nacos: discovery: server-addr: localhost:8848 # nacos 服务地址启动子模块，然后刷新 nacos 页面，就可以看到你的服务了：nacos 服务分级存储模型分级模型如下： 服务：提供某项具体服务，如我们的 parking-member 就是提供会员信息管理服务的 实例：一个服务可以拥有多个实例，比如 parking-member 在不同端口启动，每个运行中的服务就是一个实例 集群：因为单机单实例部署服务，容灾性比较弱，现在都倡导多机器实例集群，即像很多大厂在不同的地域会有一处机房，按地域有华中、华东和华北等，一个机房可能会提供多种服务，不同机房也会提供相同的服务，但服务调用都是优先本地集群 再跨集群调用，如下所示：配置集群属性spring: cloud: nacos: discovery: server-addr: localhost:8848 # nacos 服务地址 cluster-name: HZ # 集群名称：华中如下所示，我针对 parking-member 服务设置了两个集群，分别是 HZ 和 HN：" }, { "title": "认识 Spring Cloud 与 Spring Cloud Alibaba 项目", "url": "/posts/%E8%AE%A4%E8%AF%86-Spring-Cloud-%E4%B8%8E-Spring-Cloud-Alibaba-%E9%A1%B9%E7%9B%AE/", "categories": "项目, 商场停车", "tags": "", "date": "2022-12-29 00:00:00 +0800", "snippet": "Spring Cloud 介绍但随着 Spring Cloud 的迭代，不少 Netflix 的组件进行了维护模式，最明显的莫过于 Spring Cloud Gateway 的推出来替代旧有的 Zuul 组件，有项目加入，也会有老旧项目退出舞台，这也是产品迭代的正常节奏。Spring Cloud Alibaba 介绍官网地址：https://github.com/alibaba/spring-cloud-alibaba 它是 Spring Cloud 的一个子项目，致力于提供微服务开发的一站式解决方案，项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务，只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。 项目特性见下图：包括一些关键组件： Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。与 Netflix 的 Hystrix 组件类似，但实现方式上更为轻量。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台，同时具备了之前 Netflix Eureka 和 Spring Cloud Config 的功能，而且 UI 操作上更加人性化。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务，目前已交由 Apache 组织维护。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架，自交由 Apache 组织孵化后，目前社区生态很活跃，产生形态越来越丰富。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案，由早期内部产品 Fescar 演变而来。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。" }, { "title": "swagger API——在线接口文档管理", "url": "/posts/swagger-API-%E5%9C%A8%E7%BA%BF%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/", "categories": "项目, 商场停车", "tags": "", "date": "2022-12-29 00:00:00 +0800", "snippet": "如何配置引入依赖&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.spring4all&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;swagger-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.0.RELEASE&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;application 配置swagger: enabled: true base-package: com.flameking.parking.member base-path: /** authorization: key-name: Authorization docket: v1: title: 会员服务# description: 会员服务Api base-package: com.flameking.parking.member version: 1.0启动类开启注解@EnableSwagger2Docpublic class ParkingMemberApplication { public static void main(String[] args) { SpringApplication.run(ParkingMemberApplication.class, args); }}" }, { "title": "第一个 Spring Boot 子服务——会员服务", "url": "/posts/%E7%AC%AC%E4%B8%80%E4%B8%AA-Spring-Boot-%E5%AD%90%E6%9C%8D%E5%8A%A1-%E4%BC%9A%E5%91%98%E6%9C%8D%E5%8A%A1/", "categories": "项目, 商场停车", "tags": "", "date": "2022-12-28 00:00:00 +0800", "snippet": "见 智能停车管理系统 first commit这一段主要是引入相关依赖，比如：MybatisPlus、MySQL 驱动、Lombok 和 Spring Boot 的相关依赖。" }, { "title": "centos7开放3306端口", "url": "/posts/centos7%E5%BC%80%E6%94%BE3306%E7%AB%AF%E5%8F%A3/", "categories": "服务器, centos", "tags": "", "date": "2022-12-28 00:00:00 +0800", "snippet": "前言腾讯云轻量级应用服务器控制台，防火墙设置打开3306端口限制，如下：然而实际上防火墙却并没有放开3306端口，实际是其他的规则给限制了（具体未找出），如下：firewall-cmd --list-ports --permanent20/tcp 21/tcp 22/tcp 80/tcp 443/tcp 8888/tcp 39000-40000/tcp开放 3306 端口# 开放端口需要先开启防火墙systemctl start firewalld# 开放端口firewall-cmd --zone=public --add-port=3306/tcp --permanent# 重新载入防火墙使设置生效firewall-cmd --reload# 查看是否开放端口firewall-cmd --zone=public --query-port=3306/tcp# 关闭已开放端口firewall-cmd --zone=public --remove-port=3306/tcp --permanent重新运行命令：firewall-cmd --list-ports --permanent20/tcp 21/tcp 22/tcp 80/tcp 443/tcp 8888/tcp 39000-40000/tcp 3306/tcp说明 3306 端口已经开放，下面就可以通过它远程连接数据库了" }, { "title": "需求分析", "url": "/posts/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/", "categories": "项目, 商场停车", "tags": "", "date": "2022-12-27 00:00:00 +0800", "snippet": "原始需求客户提出原始需求如下： 用户手机号绑定商场的系统，在里面添加车辆，每天到商场附近时可以签到，领取积分，积分可以用于兑换限量的商场优惠券，也可以兑换洗车券，在停车场指定位置洗车。 用户可以通过系统开通 VIP 停车月卡，出入停车场时，无须额外付费。可以充值为月卡延期，充值时，为用户赠送一定数量的积分，可以做为正常积分使用。充值后，用户可以收到充值通知。 若用户未开通月卡，出场时，必须在系统里支付停车费用后，才能出场。费用多少按停车场约定的计费规则来计算。缴费后，用户能收到缴费通知。 用户进停车场前，能实时看到可用停车位数量。 在系统后台，可以看到用户的支付流水、充值流水，车位使用情况等需求分析产品经理经过对原始需求提取分析，得到下面的具体业务： 会员，会员信息（主要是姓名、手机号、生日），车辆信息（主要车牌信息），月卡信息(充值一定金额后，指定区间内免支付出入场，针对商场的工作人员或办公区的白领)，签到信息 停车场资源，车位（车辆停靠车位后，系统自动打标，可用车位扣减，停车场入口可用车实时更新）、道闸(基础数据，真实场景中涉及到岗亭值班人员安排，设备维护等) 积分，会员到达商场后签到领取积分（如签到一次可免费停车 2 小时，超出部分，以计费规则为准）。积分可兑换商场优惠券、洗车券。 计费，计费规则，车辆进场（记录车辆入场时间，开始计费）、出场扣费(出场时识别车牌，依计费规则，支付停车费，分临时车与月卡车两种，临时车现场收费，月卡车做有效期判定是符合条件后再出场) 财务，车辆出入的支付流水，会员月卡充值费用，收入统计 消息，车辆出场支付消息，会员充值消息 兑换洗车券后，停车场内洗车消费用户故事，任务整理，职责分配产品经理输出用户故事取代传统的需求文档： 作为一个普通用户，我希望可以使用系统绑定手机号，并录入车辆信息，以便于可以离场时支付费用，接收支付结果通知。 作为一个系统用户，我希望可以开通停车场月卡，同时可额外获得积分，以便于在离场时无须额外支付，快速通过。 作为一个系统用户，我希望可以通过系统日常签到，得到积分，以便于可以兑换商场优惠券或停车场洗车券。 作为一个普通/系统用户，我希望可以在进入停车场前，识别可用车位数，以便我做出相应的决策。 作为一个系统月卡用户，为月卡充值时收到消费通知，同时得到额外的积分。 作为一个系统用户，离场时需要按计费规则支付对应的停车费，并接收支付通知。 作为一个系统管理用户，我希望可以看到所有场内车位的使用情况、用户的支付流水、会员月卡的充值流水。然后开发人员基于故事，将其拆解成较细的任务，并进行职责分配，以第一个 user story 为例： 商场系统中绑定手机号，通过手机验收码，确定是本人手机。 完善个人信息，可以保存个人姓名、生日等信息 录入车辆车牌信息，后期出场车牌识别后，自动计算车辆停车费核心业务流程梳理基于需求情况，找出核心的业务流程，指导后期的核心业务开发。" }, { "title": "系统设计", "url": "/posts/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/", "categories": "项目, 商场停车", "tags": "", "date": "2022-12-27 00:00:00 +0800", "snippet": "数据实体联系基于需求分析得到的具体业务，按领域划分为七个小模块，每个模块中划分出相应的实体、事件，如下是关键数据实体-联系图： 会员，车辆，月卡(绑定手机号，录入车辆，开月卡) 车位，闸机(车辆停靠、车辆离开) 积分(签到、兑换) 计费规则(入场、出场) 交易流水(支付、充值) 消息(推送) 洗车业务模块设计按照前面的需求分析，数据实体联系图，设计的微服务模块如下： 会员服务，包括会员信息、车辆信息、会员月卡 基础资源服务，包括车位、闸机，车辆停靠记录 计费服务，车辆出入场记录，计费规则 积分服务，积分兑换，会员积分，会员签到得积分 财务服务，支付流水，充值流水，财务统计 消息服务，记录通知内容 洗车服务，积分兑换的洗车券去场内洗车存储设计微服务架构风格的一个好处，是持久性的封装。我们可以根据每个服务的需要，去选择不同的持久化技术。根据每种数据类型的特点而去选择数据存储的方法，也就是混合持久化，结构化存储与非结构化存储混合使用。不同服务间使用不同的存储模型，单一服务中也可以使用混合存储。既然要采用微服务化结构，从独立开发、运行、部署和运维都是单独的小应用。每个小应用内部业务逻辑处理，到数据库访问，以及数据库都是独立的。依据本案例的业务场景，我们拆分为七个子存储库，分别为： park_member——会员服务库 park_resource——停车场资源服务库 park_charging——计费服务库 park_card——积分服务库 park_finance——财务服务库 park_message——消息服务库 park-carwash——洗车服务库 数据库文件见项目目录初始化数据有了初步数据库的模型，需要初始化一部分数据进去，比如计费规则、闸机信息，车位信息。闸机数据INSERT INTO `brake` VALUES (&#39;4edb0820241041e5a0f08d01992de4c0&#39;, &#39;ct1&#39;, &#39;入场口&#39;, &#39;admin&#39;, &#39;2019-12-27 11:37:22&#39;, NULL, &#39;2019-12-27 11:37:22&#39;, NULL, 0, 1);INSERT INTO `brake` VALUES (&#39;989170c529a348b3b93bf2a4653e8ea9&#39;, &#39;ct2&#39;, &#39;入场口&#39;, &#39;admin&#39;, &#39;2019-12-27 11:37:45&#39;, NULL, &#39;2019-12-27 11:37:45&#39;, NULL, 0, 1);INSERT INTO `brake` VALUES (&#39;e489029055654bccb3cd601f0be71c41&#39;, &#39;ct3&#39;, &#39;出场口&#39;, &#39;admin&#39;, &#39;2019-12-27 11:37:36&#39;, NULL, &#39;2019-12-27 11:37:36&#39;, NULL, 0, 1);INSERT INTO `brake` VALUES (&#39;f726873ed17441ea8dfbf78381bcde78&#39;, &#39;ct4&#39;, &#39;出场口&#39;, &#39;admin&#39;, &#39;2019-12-27 11:37:41&#39;, NULL, &#39;2019-12-27 11:37:41&#39;, NULL, 0, 1);车位数据INSERT INTO `stall` VALUES (&#39;004ac347b94e42bb8f0f6febd3265e35&#39;, &#39;P336&#39;, 0, &#39;admin&#39;, &#39;2019-12-27 11:42:03&#39;, NULL, &#39;2019-12-27 11:42:03&#39;, NULL, 0, 1);INSERT INTO `stall` VALUES (&#39;008773e089664ce49607c86b89dd8c0f&#39;, &#39;P250&#39;, 0, &#39;admin&#39;, &#39;2019-12-27 11:42:03&#39;, NULL, &#39;2019-12-27 11:42:03&#39;, NULL, 0, 1);INSERT INTO `stall` VALUES (&#39;0110ef02554f46ce91a3eeec6ecf2f95&#39;, &#39;P224&#39;, 0, &#39;admin&#39;, &#39;2019-12-27 11:42:03&#39;, NULL, &#39;2019-12-27 11:42:03&#39;, NULL, 0, 1);INSERT INTO `stall` VALUES (&#39;014f1f2b972e4e0092d749a7437f824d&#39;, &#39;P577&#39;, 0, &#39;admin&#39;, &#39;2019-12-27 11:42:04&#39;, NULL, &#39;2019-12-27 11:42:04&#39;, NULL, 0, 1);INSERT INTO `stall` VALUES (&#39;019f4aa0c22849e1a5758aaa33b855df&#39;, &#39;P229&#39;, 0, &#39;admin&#39;, &#39;2019-12-27 11:42:03&#39;, NULL, &#39;2019-12-27 11:42:03&#39;, NULL, 0, 1);计费规则INSERT INTO `charging_rule` VALUES (&#39;41ed927623cf4a0bb5354b10100da992&#39;, 0, 30, 0, &#39;admin&#39;, &#39;2019-12-27 11:26:08&#39;, NULL, &#39;2019-12-27 11:26:08&#39;, &#39;30 分钟内免费&#39;, 0, 1);INSERT INTO `charging_rule` VALUES (&#39;41ed927623cf4a0bb5354b10100da993&#39;, 31, 120, 5, &#39;admin&#39;, &#39;2019-12-27 11:26:12&#39;, NULL, &#39;2019-12-27 11:26:12&#39;, &#39;2 小时内，5 元&#39;, 0, 1);INSERT INTO `charging_rule` VALUES (&#39;4edb0820241041e5a0f08d01992de4c0&#39;, 121, 720, 10, &#39;admin&#39;, &#39;2019-12-27 11:34:06&#39;, NULL, &#39;2019-12-27 11:34:06&#39;, &#39;2 小时以上 12 小时以内，10 元&#39;, 0, 1);INSERT INTO `charging_rule` VALUES (&#39;7616fb412e824dcda41ed9367feadfda&#39;, 721, 1440, 20, &#39;admin&#39;, &#39;2019-12-27 13:35:37&#39;, NULL, &#39;2019-12-27 13:35:37&#39;, &#39;12 时至 24 时，20 元&#39;, 0, 1);非结构化存储主要使用 Redis 中间件来存储可用车位的实时性信息，计费规则信息等热数据。架构设计没有最优的架构，只有最合适的架构，一切系统设计原则都要以解决业务问题为最终目标，并随着业务的发展，不断进行迭代演进。经过上面业务模块、存储模型的划分，基本的代码架构已经清晰可见。综合业务模块、微服务架构特性，输出功能架构设计图。基于总体功能架构图，使用特定的功能组件即可实现相应的功能。前期也提到，Spring Cloud 全家桶中囊括了很多组件，开箱即用，这对快速上手微服务开发提供了极大的便利。同时，再融入时常开发实践一些常用的高效工具来提升编码效率如 Lombok，MBG 等。" }, { "title": "微服务技术概述", "url": "/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/", "categories": "项目, 商场停车", "tags": "", "date": "2022-12-27 00:00:00 +0800", "snippet": "为什么要学习微服务 单体应用或者粗放式的软件服务，功能代码堆积，维护成本高，一个小功能的变更都有可能导致整个工程的宕机，而生产环境的奔溃更可能造成经济损失甚至不好的社会影响 云原生架构、容器化部署、中台等等都与微服务有个微妙的关系微服务能解决实际业务场景的哪些问题将单体应用分拆成多个小体量的的高内聚低耦合的软件服务，可以采用不同的软件语言，不同的数据存储，每个小服务独立部署运行，服务间采用轻量级的通信机制，由不同的团队开发和维护，大大提高了软件的可维护性、扩展性。采用微服务架构有下列好处： 组织层面，容易分工，责任清晰 单个微服务业务单一易于维护 服务之间耦合性低，可随时加入服务，剔除过时服务 更贴合云时代背景的软件开发运维环境，高效自动化构建部署 数据存储解耦，不必将所有数据集中在一个大库中，不易拆分扩容Spring Cloud 的核心特性Spring Cloud 的生态组件" }, { "title": "针对业务系统的开发，如何做需求分析和设计（以积分兑换系统为例）", "url": "/posts/%E9%92%88%E5%AF%B9%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91-%E5%A6%82%E4%BD%95%E5%81%9A%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1-%E4%BB%A5%E7%A7%AF%E5%88%86%E5%85%91%E6%8D%A2%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BE%8B/", "categories": "设计模式", "tags": "", "date": "2022-12-21 00:00:00 +0800", "snippet": "前言作为一名软件工程师，对自己的定位不能永远是一名代码实现者，而能独立负责一个系统，能端到端开发一个完整的系统才是最该具备的能力，这其中的工作就包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。现在我以一个积分兑换系统的开发实战，展示一个业务系统从需求分析到上线维护的整个开发套路（业务开发中，也会蕴含设计原则、思想和模式）需求分析从前面的学习，大致总结了这么一条需求分析的思路： 多沟通和借鉴，尽量将业务梳理完全 将业务中体现的功能一个个列出来 根据功能点，进行面向对象分析、设计和实现其中关于业务梳理，有多种方法： 和客户、同事沟通 通过产品的线框图 or 用户故事等细化业务流程，用户故事 like 单元测试用例，侧重情景化，以用户的角度来体现一个完整的业务操作流程 借鉴其他优秀的产品，自行分析业务细节以积分有效期的用户用例来说： 用户在获取积分的时候，会告知积分的有效期； 用户在使用积分的时候，会优先使用快过期的积分； 用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）； 用户在查询总可用积分的时候，会排除掉过期的积分。 从这几条用户用例也能发现，业务系统的设计其实归根结底就是增删改查积分系统的具体需求需求如下：积分赚取渠道 and 兑换规则积分的赚取渠道包括：下订单、每日签到、评论等。兑换规则如下： 签到送 10 积分 按照订单总金额的 10% 兑换成积分积分消费渠道 and 兑换规则积分的消费渠道包括：抵扣订单金额、兑换优惠券、积分换购、参与活动（如抽奖）扣积分等。兑换规则如下： 10 积分抵扣 1 块钱 100 积分可以兑换 15 元优惠券对于积分的有效期： 在消费积分的时候，优先使用快到期的积分 积分在到期后作废，不计入总积分 有效期可根据不同的赚取渠道进行设置，比如签到积分 7 天有效期，评论积分 10 天有效期等（感觉有点麻烦）积分明细查询 查询用户的总积分 赚取积分和消费积分的历史记录系统设计面向对象设计聚焦在代码层面（主要是针对类），而系统设计却是聚焦在架构层面（主要是针对模块）如何进行系统设计合理的将功能划分到不同的模块合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。对于前面罗列的所有功能点，有下列三种模块划分方法： 积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。举个例子：用户通过下订单赚取积分。订单系统通过异步发送消息或者同步调用接口的方式，告知营销系统订单交易成功。营销系统根据拿到的订单信息，查询订单对应的积分兑换规则（兑换比例、有效期等），计算得到订单可兑换的积分数量，然后调用积分系统的接口给用户增加积分。 积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。比如：用户下订单成功之后，订单系统根据商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。 所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。比如：用户下订单成功之后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分。怎么判断哪种模块划分合理呢？ 如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，明显说明模块划分不合理 为了避免不同业务之间的耦合，应该让下层更加通用，一般不希望下层系统包含太多上层系统（调用系统）的业务信息，但是可以接受上层系统包含下层系统的业务信息，如订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统可以包含一些积分相关的业务信息，但是反过来积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。综上所述，第 1、2 种模块划分方式更合适，但是不管选择哪一种，积分系统负责的工作都是：积分的增、减、查询，和积分明细的记录和查询设计模块与模块之间的交互关系在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互。常见的系统交互方式有两种： 同步接口调用（简单直接） 利用消息中间件异步调用（解耦效果好）一般，上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。同层之间往往不归属同一事务，因而通常不会要求事务一致性，而上下层关系的系统通常属于同一层业务系统，因而同步接口调用更便于控制事务一致性。如何设计模块本身业务系统本身的设计无外乎：接口设计、数据库设计和业务模型设计（即业务逻辑）。针对积分系统，如何设计数据库它实际只需要一张记录积分流水明细的表就可以了，表中记录积分的赚取和消费流水，用户积分的各种统计数据，比如总积分，总可用积分等，都可以通过这张表来计算得到。针对积分系统，如何设计接口接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，但另一个接口执行失败了）。所以，为了兼顾易用性和性能，我们可以借鉴facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。（简单来说就是避免多次（远程）接口调用）对于积分系统来说，我们需要设计如下这样几个接口：业务模型设计由于积分系统相对简单，因此选择基于贫血模型的 MVC 三层架构，Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑，也就是这里说的业务模型。同时积分系统可以作为一个独立的项目开发，也可跟其他业务代码一起开发（如营销系统），从运维的角度它可以跟其他业务一块部署，也可作为一个微服务独立部署，这里更倾向将它跟营销系统放在同一个项目中开发部署，只要做好代码的模块化和解耦，让积分系统更其他业务代码保持边界，无太多耦合，后期需要拆分成独立的项目开发部署也会很简单为什么要分MVC三层开发？分层能起到代码复用的作用同一个 Repository 可能会被多个 Service 来调用，同一个 Service 可能会被多 Controller 调用。比如，UserService 中的 getUserById() 接口封装了通过ID获取用户信息的逻辑，这部分逻辑可能会被 UserController 和 AdminController 等多个 Controller 使用。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。分层能起到隔离变化的作用分层体现了一种抽象和封装的设计思想。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当我们需要替换数据库的时候，比如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动 Repository 层的代码，Service 层的代码完全不需要修改。除此之外，Controller、Service、Repository 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。比如，Repository 层基于数据库表，而数据库表改动的可能性很小，所以 Repository 层的代码最稳定，而 Controller 层提供适配给外部使用的接口，代码经常会变动。分层之后，Controller层中代码的频繁改动并不会影响到稳定的 Repository 层。分层能起到隔离关注点的作用Repository 层只关注数据的读写。Service 层只关注业务逻辑，不关注数据的来源。Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。分层能提高代码的可测试性后面讲单元测试的时候，我们会讲到，单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repsitory 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，我们可以用 mock 的数据源替代真实的数据库，注入到 Service 层代码中。代码的可测试性和单元测试我们后面会讲到，这里你稍微了解即可。分层能应对系统的复杂性所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。还是那句话，不管是分层、模块化，还是 OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”。总结用到的设计原则和思想" }, { "title": "设计原则", "url": "/posts/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/", "categories": "设计模式", "tags": "", "date": "2022-12-01 00:00:00 +0800", "snippet": "SOLID 单一职责原则 开闭原则 里式替换原则 接口隔离原则 依赖反转原则单一职责原则（Single Responsibility Principle）A class or module should have a single responsibility，即保持类或者模块的职责单一。何谓职责单一依托现实场景为依据，当一个类包含了两个或两个以上业务不相关的功能，其职责就不是单一的。如何以现实场景为依据，判断一个类是否职责单一以下面的 UserInfo 为例：public class UserInfo {private long userId;private String username;private String email;private String telephone;private long createTime;private long lastLoginTime;private String avatarUrl;private String provinceOfAddress; // 省private String cityOfAddress; // 市private String regionOfAddress; // 区private String detailedAddress; // 详细地址// ...省略其他属性和方法...}它即包含用户的基本信息，亦包含详细的地址信息，比如省，市，区和详细地址，当地址信息不止用来展示而是需要用在其他功能模块中，比如物流模块，那么在物流模块中用户的其他基本信息其实是多余的，因此要把地址从其中独立出来成为 UserAddress总结不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的，但归根结底类的设计要是破坏了代码的内聚性，增加了代码的维护成本那它就是不好的设计开闭原则software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。即模块、类和方法的设计应该对扩展开发，对修改关闭。为什么要开闭原则代码的可扩展性低意味着但需求改变需要经常修改代码，这样会导致调用者跟着修改，但是调用者可能散落在类、模块的各个角落，因此修改的成本为大幅增加，如何实现开闭原则开闭原则是为了提高程序的可扩展性，这也是大部分设计模式的目的，也是面向对象四大特性的最终目的，因此灵活的应用设计模式和面向对象特性就是实现开闭原则如何在项目中或用开闭原则 如果开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。 如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。注意：没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。里氏替换If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program，即在不破坏程序原本的逻辑，基类对象引用应该能用派生类对象进行替换。另一个描述是Design By Contract，即按照协议来设计里氏替换和多态的不同即是否改变程序原本的逻辑，多态是基于不同的子类，而产生不同的代码逻辑。违反里氏替换的例子 子类违背父类声明要实现的功能 子类违背父类对输入、输出、异常的约定 子类违背父类注释中所罗列的任何特殊说明接口隔离原则Clients should not be forced to depend upon interfaces that they do not use，即调用者不应该被强迫依赖它不需要的接口。接口隔离原则和单一职责原则的区别前者是在调用者的角度判断类的职责是否单一，如果调用者并需要要接口中的一些功能，那么该接口就不满足接口隔离，我们应该把其中的不需要的功能独立出来成为一个单独的接口。关于接口的理解一组 API 接口集合，如微服务提供的一组跟用户相关的 API：public interface UserService { boolean register(String cellphone, String password); boolean login(String cellphone, String password); UserInfo getUserInfoById(long id); UserInfo getUserInfoByCellphone(String cellphone);}public class UserServiceImpl implements UserService { //...}单个的 API 接口或函数：public class Statistics { private Long max; private Long min; private Long average; private Long sum; private Long percentile99; private Long percentile999; //...省略constructor/getter/setter等方法...}public Statistics count(Collection&amp;lt;Long&amp;gt; dataSet) { Statistics statistics = new Statistics(); //...省略计算逻辑... return statistics;}面向对象中的接口，如 Java 中的 interface。依赖反转原则什么是控制反转以 Spring IOC 为例：框架提供好一个代码骨架，用来组装对象管理整个执行流程，程序员只需要往预留的扩展点加入自己的业务代码，这里“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。需要注意的是控制反转并不是一种具体的实现技巧而是比较笼统的设计思想，它的实现像依赖注入、模板设计模式等何谓依赖注入即不通过 new 创建依赖对象，而是在外部创建好之后，通过构造函数或者 Setter 传递给类使用依赖注入框架简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。依赖反转原则High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions，即调用链上层不应该依赖调用链下层，它们俩都应该依赖抽象，除此自外抽象不应该依赖具体实现，实现应该依赖抽象。举个形象的例子：Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。YAGNI 和 KISS 原则 YAGNI，You Ain’t Gonna Need It，即不要做过度设计。 KISS，keep it stupid and simple，尽量保持代码简单。DRY 原则Don’t Repeat Yourself，即不要写重复的代码重复的代码 实现逻辑重复 功能语义重复 代码执行重复迪米特法则实际上跟接口隔离原则差不多，本质上还是解耦，减少类和类之间不必要的依赖.总结实际上设计原则都是为了提高代码的可读性，可扩展性和可维护性，它们是不断打磨的经验，遵循它们我们更容易写出更加易扩展的代码，但也不必过分拘泥设计原则是什么，内容有多少，设计模式才是对设计原则的实现。" }, { "title": "如何进行面向分析、设计和实现", "url": "/posts/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%9D%A2%E5%90%91%E5%88%86%E6%9E%90-%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/", "categories": "设计模式", "tags": "", "date": "2022-11-27 00:00:00 +0800", "snippet": "面向对象分析、设计和实现有哪些要点 根据需求描述分析有哪些类 职责划分（进而识别出有哪些类） 设计类，包括类有哪些属性，类之间该如何交互（组合、继承和实现） 零件有了（类），如何组装成可执行的程序呢？接口鉴权还是以接口鉴权设计为例，根据前面得到的可落地的需求描述依次进行分析，需求描述的流图展示如下：划分职责（有哪些类）如何划分，按照需求描述将其中涉及的功能点一个个列出来，根据功能点职责是否相近，操作属性是否相同，判断是否将其归为同一个类，比如针对上面的需求描述图： 拼接 URL、用户名、时间戳和密码，并加密成 token，再将 token、用户名和时间戳拼接到 URL 中并发送到微服务端 微服务端解析 URL，得到 token、用户名、时间戳 根据时间戳比较当前时间，判断请求是否过期，否则拒绝请求调用 请求没有过期，根据用户名取出密码，并再次生成 token，并判断两个 token 是否一致，否则拒绝请求调用上面是需求描述流图的文字描述，下面分析功能点： 把 URL、用户名、密码、时间戳拼接为一个字符串； 对字符串通过加密算法加密生成 token； 将 token、用户名、时间戳拼接到 URL 中，形成新的 URL； 解析 URL，得到 token、用户名、时间戳等信息； 从存储中取出用户名和对应的密码； 根据时间戳判断 token 是否过期失效； 验证两个 token 是否匹配；综上： 2，4，6，7等都是对 token 进行操作，分别有 token 加密，token 是否失效，验证 token， 1，3，4 是与 URL 相关的，包括对 URL 的拼接和解析 5 是从数据库取出用户名和密码因此可将需求描述建模成这几个类：AuthToken、Url 和 CredentialStorage类的属性和方法按照上面总结的操作，设计出方法和属性即可类之间的交互关系 泛化，即继承 实现，即接口和实现类之间的关系 组合 依赖其中组合和依赖的代码表示形式没有什么区别，不过 A 组合 B 来说，B 是无法独立存在的，就像翅膀不能脱离鸟自身而存在，那样将没有任何意义组装并执行 独立运行的程序：提供 main 函数入口或暴露接口 框架：封装并向外界暴露接口面向对象实现将上述设计翻译成代码" }, { "title": "如何把粗糙的模糊的需求整理分析得到清晰的可落地的需求描述", "url": "/posts/%E5%A6%82%E4%BD%95%E6%8A%8A%E7%B2%97%E7%B3%99%E7%9A%84%E6%A8%A1%E7%B3%8A%E7%9A%84%E9%9C%80%E6%B1%82%E6%95%B4%E7%90%86%E5%88%86%E6%9E%90%E5%BE%97%E5%88%B0%E6%B8%85%E6%99%B0%E7%9A%84%E5%8F%AF%E8%90%BD%E5%9C%B0%E7%9A%84%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0/", "categories": "设计模式", "tags": "", "date": "2022-11-27 00:00:00 +0800", "snippet": "面向对象分析、设计和实现之前在进行面向对象分析、设计和实现之前，我们需要将模糊的需求整理分析得到清晰的可落地的需求描述接口鉴权以接口鉴权需求设计为例，下面分析流图：需要注意的是： 合适的满足需求的方案是从最简单的开始，不断迭代优化出来的，妄想一步到位是不可能的 避免脱离具体的应用场景做需求分析，尽量与不同的部门和同事多沟通，力求分析整理出最有价值的需求 满足需求即可，避免过度设计" }, { "title": "经典策略模式VS枚举策略", "url": "/posts/%E7%BB%8F%E5%85%B8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FVS%E6%9E%9A%E4%B8%BE%E7%AD%96%E7%95%A5/", "categories": "设计模式", "tags": "", "date": "2022-11-22 00:00:00 +0800", "snippet": "1. 枚举类1.1. 定义简单创建一个枚举类@Getterenum WeekdayEnum { Monday(1, &quot;星期一&quot;), Tuesday(2, &quot;星期二&quot;), Wednesday(3, &quot;星期三&quot;), Thursday(4, &quot;星期四&quot;), Friday(5, &quot;星期五&quot;), Saturday(6, &quot;星期六&quot;), Sunday(7, &quot;星期天&quot;), ; private static final HashMap&amp;lt;Integer, WeekdayEnum&amp;gt; enumHashMap = new HashMap&amp;lt;&amp;gt;(); private final Integer code; private final String desc; static { for (WeekdayEnum value : values()) { enumHashMap.put(value.getCode(), value); } } WeekdayEnum(Integer code, String desc) { this.code = code; this.desc = desc; } public static WeekdayEnum getEnumByCode(Integer code){ return enumHashMap.get(code); }}该枚举类穷举了一周内的所有天，并建立了一个基于 HashMap 的本地缓存，通过缓存向外界提供了 getEnumByCode()，即通过 code 获取对应的枚举。当类的对象是有限的，该类适合定义成枚举类。枚举类的特性反编译 WeekdayEnum.class 能得到下面的结果：import java.util.HashMap;final class WeekdayEnum extends Enum{ public static WeekdayEnum[] values(){ return (WeekdayEnum[])$VALUES.clone(); } public static final WeekdayEnum Monday; public static final WeekdayEnum Tuesday; public static final WeekdayEnum Wednesday; private final Integer code; private final String desc; private static final WeekdayEnum $VALUES[]; static { Monday = new WeekdayEnum(&quot;Monday&quot;, 0, Integer.valueOf(1), &quot;\\u661F\\u671F\\u4E00&quot;); Tuesday = new WeekdayEnum(&quot;Tuesday&quot;, 1, Integer.valueOf(2), &quot;\\u661F\\u671F\\u4E8C&quot;); $VALUES = (new WeekdayEnum[] { Monday, Tuesday, Wednesday }); }}通过这段反编译代码，我们发现编译器为我们做了这些事情： 枚举类是一个被 final 修饰的普通类，即它无法被继承。 构造函数新增两个参数，String 类型的 s，和 int 类型的 i，分别是枚举对象的变量名和排序值（从 0 开始） 新增一个 valueOf()，即通过变量名获取枚举对象 新定义了一个枚举数组 $VALUES 缓存所有的枚举，以及一个返回数组拷贝的 values()以上便是编译器为定义的枚举类额外做的事，我们发现枚举类就是一个普通的类，并且如果只有一个枚举对象，那么它其实就是一个单例模式的实现。1.3. 枚举类 vs 常量类枚举类和常量类没有可比性，因为枚举是作为对象而存在，并且能使用常量类的地方一定可以用枚举类替换，但使用枚举类的地方不一定能用常量类替换，枚举类作为对象使用时能应用到的场景更多更广，总而言之枚举类可玩性更强。经典策略模式策略模式也属于一种行为型模式，在实际的开发中这个模式也用的非常多，最常见的应用场景是利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。定义策略模式，英文全称是Strategy Design Pattern：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。其实就是一种解耦方式，们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者，终究是应用的场景不同。实现假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。很简单：先将文件中的内容读出来，以逗号分隔将其读取成一个个的数字，再以任意一种排序算法对其进行排序，并将排序好的数据重新写入文件当中。我猜你肯定是这么想的，但是这样存在问题，比如文件 size 非常大，像 10GB，50GB，甚至 100GB，那么内存根本不够，跟别说还在内存中排序了想都别想。这时候我们应该根据文件的 size 合理分析： 当文件 size &amp;lt; 6GB（现在的手机、电脑，只要稍微好点的内存至少有 6GB 吧），那么直接读取到内存并使用快排。 10GB &amp;lt;= size &amp;lt; 100GB 这时候没办法加入到内存当中，那么就使用外部排序算法。 100GB &amp;lt;= size &amp;lt; 1T，为了利用 CPU 多核的优势可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的MapReduce。 size &amp;gt; 1T，这时候即便是单机多线程排序，也算很慢了。这样可以使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率。先用最简单的方式实现：public class Sorter { private static final long GB = 1000 * 1000 * 1000; public void sortFile(String filePath) { // 省略校验逻辑 File file = new File(filePath); long fileSize = file.length(); if (fileSize &amp;lt; 6 * GB) { // [0, 6GB) quickSort(filePath); } else if (fileSize &amp;lt; 10 * GB) { // [6GB, 10GB) externalSort(filePath); } else if (fileSize &amp;lt; 100 * GB) { // [10GB, 100GB) concurrentExternalSort(filePath); } else { // [100GB, ~) mapreduceSort(filePath); } } private void quickSort(String filePath) { // 快速排序 } private void externalSort(String filePath) { // 外部排序 } private void concurrentExternalSort(String filePath) { // 多线程外部排序 } private void mapreduceSort(String filePath) { // 利用MapReduce多机排序 }}public class SortingTool { public static void main(String[] args) { Sorter sorter = new Sorter(); sorter.sortFile(args[0]); }}这段代码确实很简单，但是类看起来会很臃肿，因为上面的几个算法的内容会很多，同时如果后续增加算法，就需要增加 if/else，同时几个算法函数作为私有函数放在 Sorter 类中，这就没法给其它类复用了。综上可优化重构将这几个算法函数独立出来成为单个类，正好可以用到策略模式：/** * 定义和创建策略 * @see ISortAlg、QuickSort、ExternalSort、ConcurrentExternalSort 和 MapReduceSort */public interface ISortAlg { void sort(String filePath);}public class QuickSort implements ISortAlg { @Override public void sort(String filePath) { //... }}public class ExternalSort implements ISortAlg { @Override public void sort(String filePath) { //... }}public class ConcurrentExternalSort implements ISortAlg { @Override public void sort(String filePath) { //... }}public class MapReduceSort implements ISortAlg { @Override public void sort(String filePath) { //... }}/** * 使用策略 */public class Sorter { private static final long GB = 1000 * 1000 * 1000; public void sortFile(String filePath) { // 省略校验逻辑 File file = new File(filePath); long fileSize = file.length(); ISortAlg sortAlg; if (fileSize &amp;lt; 6 * GB) { // [0, 6GB) sortAlg = new QuickSort(); } else if (fileSize &amp;lt; 10 * GB) { // [6GB, 10GB) sortAlg = new ExternalSort(); } else if (fileSize &amp;lt; 100 * GB) { // [10GB, 100GB) sortAlg = new ConcurrentExternalSort(); } else { // [100GB, ~) sortAlg = new MapReduceSort(); } sortAlg.sort(filePath); }}经过重构，我们将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用实际上上面的代码还可以优化，因为算法是无状态的，跟具体的业务无关，所以没必要每次使用的时候都重新创建一个对象。所以可有使用工厂模式对其对象的创建进行封装：public class SortAlgFactory { private static final Map&amp;lt;String, ISortAlg&amp;gt; algs = new HashMap&amp;lt;&amp;gt;(); static { algs.put(&quot;QuickSort&quot;, new QuickSort()); algs.put(&quot;ExternalSort&quot;, new ExternalSort()); algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort()); algs.put(&quot;MapReduceSort&quot;, new MapReduceSort()); } public static ISortAlg getSortAlg(String type) { if (type == null || type.isEmpty()) { throw new IllegalArgumentException(&quot;type should not be empty.&quot;); } return algs.get(type); }}public class Sorter { private static final long GB = 1000 * 1000 * 1000; public void sortFile(String filePath) { // 省略校验逻辑 File file = new File(filePath); long fileSize = file.length(); ISortAlg sortAlg; if (fileSize &amp;lt; 6 * GB) { // [0, 6GB) sortAlg = SortAlgFactory.getSortAlg(&quot;QuickSort&quot;); } else if (fileSize &amp;lt; 10 * GB) { // [6GB, 10GB) sortAlg = SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;); } else if (fileSize &amp;lt; 100 * GB) { // [10GB, 100GB) sortAlg = SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;); } else { // [100GB, ~) sortAlg = SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;); } sortAlg.sort(filePath); }}通过两次重构，现在的代码已经符合策略模式的代码结构了，不过，Sorter类中的sortFile()函数还是有一堆if-else逻辑。这里的if-else逻辑分支不多、也不复杂，这样写完全没问题。但是如果一定要消除 if-else，那么可以依据策略工厂的这种”查表法”，再弄一个工厂：public class Sorter { private static final long GB = 1000 * 1000 * 1000; private static final List&amp;lt;AlgRange&amp;gt; algs = new ArrayList&amp;lt;&amp;gt;(); static { algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;))); algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;))); algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;))) algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;))) } public void sortFile(String filePath) { // 省略校验逻辑 File file = new File(filePath); long fileSize = file.length(); ISortAlg sortAlg = null; for (AlgRange algRange : algs) { if (algRange.inRange(fileSize)) { sortAlg = algRange.getAlg(); break; } } sortAlg.sort(filePath); } private static class AlgRange { private long start; private long end; private ISortAlg alg; public AlgRange(long start, long end, ISortAlg alg) { this.start = start; this.end = end; this.alg = alg; } public ISortAlg getAlg() { return alg; } public boolean inRange(long size) { return size &amp;gt;= start &amp;amp;&amp;amp; size &amp;lt; end; } }}相应的这里用的是 List 结构遍历查询，而非 Map 的匹配查询。现在当新增策略时，我们只需要新增一个策略类，然后两个工厂类中的静态代码块加上对应的候选项就可了。当然也许有人会说这样封装的还是不彻底呀，还是需要修改代码，那么我们可以参照 Spring 中的设计，通过为策略类打上注解/配置文件的方式，并通过反射创建策略类对象从而避免对工厂类的修改。" }, { "title": "基于贫血模型的MVC三层架构和基于充血模型的DDD分层架构", "url": "/posts/%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/", "categories": "设计模式", "tags": "", "date": "2022-11-17 00:00:00 +0800", "snippet": "什么是贫血模型？什么是充血模型？什么是 MVC 三层架构其中 M 表示 Model，V 表示 View，C 表示 Controller。MVC 会将整个项目分为三层：展示层、逻辑层和数据层。但是在实际开发中并不一定会遵从这种固定的分层，如：在前后端分离项目中，后端往往分为：Repository、Service 和 Controller 三层，其中 Repository 负责与数据库交互进行数据访问，Service 负责业务逻辑，Controller 负责向前端暴露接口。而在 SpringMVC 的那一套中，Controller 层我们往往会返回一个 Model（视图对象），即它代表展示层。什么是贫血模型以 MVC 三层架构为例，开发中我们经常定义 Entity &amp;lt;–&amp;gt; Repository，VO &amp;lt;–&amp;gt; Controller，BO &amp;lt;–&amp;gt; Service，这样数据与业务逻辑分离的操作，是典型的面向过程编程，而其中的 BO 这样只有数据没有业务逻辑的类就被称作贫血模型什么是基于充血模型的DDD开发模式什么是充血模型与贫血模型正相反，它将数据和业务逻辑封装在一个类中，这个类就被称作充血模型什么是领域驱动设计（DDD）除了监控、调用链追踪、API网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。 做好领域驱动设计的关键是：看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。基于充血模型的 DDD 开发模式与基于贫血模型的 MVC 的区别开发模式相同都是基于三层架构，主要区别在于 Service 层，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service重 Domain。而 Domain 就是数据和业务类型封装在一起的类为什么说基于贫血模型的传统开发模式违反OOP?数据和业务逻辑分离，违反了 OOP 的封装特性，数据能够被外界随意修改，同时业务逻辑往往基于 SQL，难以复用两者的开发流程有何不同基于充血模型的 DDD 开发模式前期做大量的业务调研、领域模型设计（可复用的业务中间件），后期根据领域模型完成新功能需求的开发基于贫血模型的 MVC 开发模式根据需求抽象 Entity 对象，每个 Entity 对应数据库中的一张表 –&amp;gt; 根据业务需求编写 SQL –&amp;gt; 按照 SQL 模板式的往 Repository、Service 和 Controller 中填充代码什么情况下我们应该考虑使用基于充血模型的DDD开发模式？越复杂的系统，对代码的复用性和易维护性要求越高，就越需要花精力和时间在前期的设计上，而基于充血模型的DDD开发模式正好适合。实战-虚拟钱包需求分析 虚拟钱包的充值、提现和支付实际上就是真实账户的转账操作DDD开发模型图从上图总结 Domain 的特性： Domain 作为一个领域驱动模型，它不与 Service 和 Repository 进行耦合，因此可以方便的复用 Service 通过组合和委托通过 Domain 完成业务逻辑，通过 Repository 完成数据交换" }, { "title": "接口和抽象类", "url": "/posts/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/", "categories": "设计模式", "tags": "", "date": "2022-11-14 00:00:00 +0800", "snippet": "1. 接口和抽象类的特性抽象类 抽象类不允许被实例化，只能被继承 抽象类必须有抽象方法 子类继承抽象类必须实现抽象类中的所有抽象方法接口 接口只能定义常量不能定义属性 接口只能声明方法，不能实现方法 实现接口的类必须实现接口中声明的所有方法接口和抽象类的不同点 语法特性：相比抽象类，接口中不能定义属性，不能实现方法。 设计角度：抽象类和子类表示的是 is-a 关系，接口和实现类表示的是 has-a 关系，即具有某些功能。接口的更形象的称呼：协议（contract）接口和抽象类的意义 相比普通类，抽象类除了可以实现代码复用，亦可以实现多态，其中模板设计模式就是以抽象类为基础，从设计上而言很有美感。如下面这段代码：//抽象类public abstract class Logger { private String name; private boolean enabled; private Level minPermittedLevel; public Logger(Stringname,booleanenabled,LevelminPermittedLevel){ this.name=name; this.enabled=enabled; this.minPermittedLevel=minPermittedLevel; } public void log(Level level, String message){ boolean loggable = enabled &amp;amp;&amp;amp; (minPermittedLevel.intValue() &amp;lt;= level.intValue()); if(!loggable) return; doLog(level, message); } protected abstract void doLog(Levellevel,Stringmessage);}//抽象类的子类：输出日志到文件public class FileLogger extends Logger{ private Writer fileWriter; public FileLogger(String name,boolean enabled,Level minPermittedLevel,String filepath){ super(name, enabled, minPermittedLevel); this.fileWriter = newFileWriter(filepath); } @Override public void doLog(Level level, String mesage){ //格式化level和message,输出到日志文件 fileWriter.write(...); }}//抽象类的子类:输出日志到消息中间件(比如kafka)public class Message QueueLogger extends Logger{ private MessageQueueClient msgQueueClient; publicMessageQueueLogger(String name, boolean enabled, Level minPermittedLevel, MessageQueueClient msgQueueClient){ super(name, enabled, minPermittedLevel); this.msgQueueClient = msgQueueClient; } @Override protectedvoiddoLog(Level level, String mesage){ //格式化level和message,输出到消息中间件 msgQueueClient.send(...); }} 相比抽象类，接口更多用于实现多态特性，用于解耦，提高程序的可扩展性。如下面这段代码：//接口public interface Filter{ void doFilter(RpcRequest req) throws RpcException;}// 接口实现类：鉴权过滤器public class AuthencationFilter implements Filter { @Override public void doFilter(RpcRequest req) throws RpcException {/**...鉴权逻辑..**/} }// 接口实现类：限流过滤器public class RateLimitFilter implements Filter { @Override public void doFilter(RpcRequest req) throws RpcException {/**...限流逻辑...**/}}// 过滤器使用Demopublic class Application { private List&amp;lt;Filter&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;(); filters.add(new AuthencationFilter()); filters.add(new RateLimitFilter()); public void handleRpcRequest(RpcRequest req) { try { for (Filter filter : filters) { filter.doFilter(req); } } catch(RpcException e) {/**...处理过滤结果...**/} // ...省略其他处理逻辑... }}2. 什么时候用接口？什么时候用抽象类？ 实际上，判断的标准很简单。如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示 一种has-a关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。 从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。3. 设计原则：基于接口而非实现编程首先这条原则是先于 Java 诞生的，因而此 ‘接口’ 非彼‘接口’，实际上，该原则的另一个表述方式是“基于抽象而非实现编程”，这样更能体现该原则的设计初衷。理解接口的定义“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。设计初衷将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。如何应用这条原则 函数的命名不能暴露任何实现细节。 封装具体的实现细节 为实现类定义抽象的接口。4. 多用组合少用继承什么是组合参考监听者模式，被监听者类里组合监听者作为它的一个属性，这就是组合为什么多用组合少用继承继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性，如下面这张继承图：该设计旨在抽象现实中的鸟类，而现实往往千变万化，比如除会飞的鸟、不会飞的鸟，还有下蛋的不下蛋的，食肉的和不食肉的等等，这样就会导致类继承关系很复杂，类的数量也会急剧增加使用方法实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段一块儿来解决刚刚继承存在的问题。像下面这样：public interface Flyable { void fly()；}public class FlyAbility implements Flyable { @Override public void fly() { /**...**/ }}public class Ostrich implements Flyable {//鸵鸟 private FlyAbility flyAbility = new FlyAbility(); //组合 @Override public void tweet() { tweetAbility.tweet(); // 委托 } @Override public void layEgg() { eggLayAbility.layEgg(); // 委托 }}替换组合继承主要的三个作用都可用其他手段替换： 表示is-a关系，可通过组合和接口的has-a关系来替代 支持多态特性，可以利用接口来实现 代码复用，可以通过组合和委托来实现少用继承不是完全不用继承？继承改写成组合意味着要做更细粒度的类的拆分，即要定义更多的类和接口。类和接口的增多必然增加代码的复杂程度和维护成本。要根据具体的情况，来选择继承还是组合。如： 类继承关系最多2层，就大胆用继承 类与类之间没有继承关系，即为了实现代码复用没必要抽象一个父类，这时候就大胆用组合吧（搞一个工具类啥的） 函数参数强制为类而不是接口，这个时候为了实现多态就只能使用继承重写对应的方法" }, { "title": "面向对象编程与面向过程编程", "url": "/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/", "categories": "设计模式", "tags": "", "date": "2022-11-13 00:00:00 +0800", "snippet": "1. 面向过程编程和面向过程编程语言1.1. 定义面向过程编程：以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。面向过程编程语言：不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。2. 两种编程范式的不同点 开发方式不同：OOP 以类和对象为思考对象，考虑如何给业务建模，如何将需求翻译成类，如何建立类之间的交互关系。而完成这些工作完全不要考虑错综复杂的处理流程。类的分析和设计完成之后再按照流程实现整个程序，POP 思考如何将复杂的流程拆解为一个个方法，然后按照顺序执行的步骤进行代码设计 应用场景不同：OOP 适合大规模复杂程序的开发，POP 适合业务逻辑简单，流程单一的程序开发。大规模复杂程序的特点，整个程序的处理流程错综复杂，把整个程序的处理流程画出来的话，会是一个网状结构 出现时间不同：OOP 晚于 POP 出现，顺应时代的需求，相比于 POP，OOP 提供了更多的特性，比如四大特性，通过类组织函数和数据结构更容易进行代码模块化的设计并且结合四大特性，更方便开发者写出易复用、易扩展、易维护的代码。总的来说： 面向过程编程是计算机思维方式，即：如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务 而面向对象编程思考如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道3. 避免面向对象编程退化成面向过程编程3.1. 滥用Getter、Setter方法解决办法： Getter 针对集合对象，集合数据容易被外部修改。 返回拷贝对象 Collections.unmodifiableList() Setter 提供给外部随意更改数据的方法。 尽量不要给属性提供 Setter 方法 根据业务需要选择提供 3.2. 滥用全局变量和全局方法常量类 Constants缺点： 一旦内容变多可维护性差，且难以查找修改需要的常量 被很多类依赖，每次修改 Constants 会导致程序重新编译增加编译时间，降低开发效率 影响代码的复用性，如果其他服务需要就要把整个类迁过去解决办法： 将 Constants 类拆解为功能更加单一的多个类 不单独设计 Constants 类，而是将变量定义到使用变量的类中Utils 类 为什么要设计 Utils 类：A 类 和 B 类不具有继承关系，但有相同的代码逻辑，为了代码复用，将其抽象到 Utils 类中成为一个静态方法缺点：方法与数据分离是完完全全的面向过程编程解决方案： 如果相同的代码逻辑可有抽象到其他类（前提是业务相关联） 功能细化，拆解成功能更加单一的类在 Java 中什么叫全局变量和全局方法： 全局变量：单例类对象、静态成员变量和常量（常量类） 全局方法：静态方法3.3. 定义数据和方法分离的类基于贫血模型的开发模式传统的 MVC 三层架构开发方案就是典型的贫血模型开发方式，这种方式下业务逻辑方法都被定义在 Controller、Service和Repository中，而数据则放在 Entity 和 DTO 中。缺点：强依赖 SQL（业务逻辑都被封装在 SQL 中），且就算业务逻辑只有一点改动，也需要新写一条 SQL，SQL 语句难以复用解决方案：采用基于充血模型 DDD 领域驱动开发（前提是业务很复杂，否则没有效果）4. 如何正确的在 OOP 中使用 POP最终目的还是写出易维护、易读、易复用、易扩展的高质量代码只要我们能避免 POP 风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。" }, { "title": "设计思想-面向对象", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/", "categories": "设计模式", "tags": "", "date": "2022-11-13 00:00:00 +0800", "snippet": "1. 面向对象编程和面向对象编程语言1.1. 定义面向对象编程：以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。面向对象编程语言：支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。1.2. 面向对象分析、设计和实现 软件工程 面向对象 定需求、产品方案、研发落地、测试上线和后期运营 围绕类、对象以及类与类之间如何交互 需求分析和系统设计 面向对象分析和设计：程序拆解为类、类的属性和方法以及类之间的交互 软件开发 面向对象实现：将分析和设计翻译成代码 1.3. 四大特性1.3.1. 封装what也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。how需要编程语言本身提供一定的语法机制来支持，即访问权限控制。why过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。1.3.2. 抽象what隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。实际上，类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。how在面向对象编程中，我们常借助编程语言提供的接口类（比如Java中的interface关键字语法）或者抽象类（比如Java中的abstract关键字语法）这两种语法机制，来实现抽象这一特性。why 抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。 抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则、代码解耦等。 我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。抽象在多数据源、多存储源等场景中体现的非常充分，这类场景往往需要以基于接口而非实现编程的思想进行设计。抽象为什么可以排除在面向对象编程特性之外呢？该设计思想非常通用，不仅在面向对象编程中，也可指导架构设计等。该特性不需要编程语言提供特殊的语法机制来支持，仅需“函数”这基础的语法机制，就可实现抽象特性，即它没有很强的“特异性”，所以有时候并不被看作面向对象编程的特性之一。1.3.3. 继承what用来表示类之间的 is-a 关系how编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()，Ruby使用&amp;lt;。why 代码复用 is-a关系关联两个类更符合人类的思考方式，并且以设计的角度来看，具有结构美感。为什么有些语言支持多重继承，有些语言不支持呢？ 强耦合，子类和多个父类耦合在一起，可维护性差 多个父类中的出现同名方法（产生歧义），子类不知道继承哪个父类的方法，即著名的多重继承的 diamond problem，如下图，继承关系像钻石过度使用继承带来的问题 过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。先要了解类的功能需要查看该类和它的所有父类（如果它的继承关系非常复杂，那就没法看） 子类和父类高度耦合，修改父类的代码，会直接影响到子类。为达成代码复用：推荐利用组合关系而不是继承关系1.3.4. 多态what子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。how编程语言需要提供下面的语法机制： 支持父类对象可以引用子类对象 支持继承、接口类或者 duck-typing。存在这种关系才能将子类传递给父类 支持子类可以重写（override）父类中的方法why 提高代码的可扩展性和复用性，①即便子类的逻辑发生改变，调用者代码也不需要更改，因为使用的是父类，②新增一种策略，只需要继承或实现接口（符合开闭原则） 多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的if-else语句等等。what is duck-typing只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的duck-typing，是一些动态语言所特有的语法机制。" }, { "title": "设计模式之美导读和知识框图", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%E5%AF%BC%E8%AF%BB%E5%92%8C%E7%9F%A5%E8%AF%86%E6%A1%86%E5%9B%BE/", "categories": "设计模式", "tags": "", "date": "2022-11-08 00:00:00 +0800", "snippet": "1. 导读1.1. 为什么要学设计模式 应对面试 提高代码质量 提高复杂系统的设计和开发能力 便于理解开源项目（优秀的开源项目往往大量用到了设计模式） 提升软实力1.2. 如何评价代码质量评价指标 可维护性 可读性 可扩展性 可复用性 可测试性 bug易修复 易修改 易添加功能 逻辑清晰 简单易懂 开闭原则 高内聚 解耦 功能模块化 易进行单元测试 知识框图" }, { "title": "基于 DDD 领域驱动设计的抽奖系统", "url": "/posts/%E5%9F%BA%E4%BA%8E-DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F/", "categories": "项目, 基于 DDD 领域驱动设计的抽奖系统", "tags": "", "date": "2022-10-25 00:00:00 +0800", "snippet": "项目相关的面试提问 表设计 服务器配置情况和 TPS、QPS 等指标 如何在项目种介绍这个项目，公司项目？学习项目？还是导师带的？ DDD 和 MVC 的区别工程列表 分布式核心功能服务系统 网关 API 测试 自研分库分表路由组件 B端运营系统 C端用户系统（Vue 前端页面）大厂规范大厂码农开发基础主要是大厂开发的一整套流程： 文档撰写（如编写项目需求文档（PRD）、研发设计、代码评审、架构设计以及晋升答辩都涉及到文档的编写） 开发工具之类的，如文档编写工具Xmind、PPT等一些 技术方面除了我们常用的①如 Spring、Spring Boot、MyBatis、MySQL、Redis、RPC、MQ等，②根据不同的开发系统，如数据需要分库分表，将涉及数据库路由组件，③分库分表后又会用到数据整合汇总服务，如 MySQL 的 binlog 日志，把数据通过 Otter 同步到 ES 中，④还可能用到分布式任务以及分布式事务的组件，但也可以基于 MQ 做最终一致性。⑤互联网项目往往采用前后端分离，有时候服务端会把 RPC 这样的接口转换为 http 服务，不过这种转换只要把 RPC 接口配置到网关平台即可，不需要自己处理 http 开发，⑥网关服务上会提供像白名单、黑名单、防刷、切量、限流等各种服务治理的能力，⑦前端的接口也会有 LVS/F5、Nginx、CDN 等各项能力来保障系统的可用度 数据方面，分库分表时需要进行数据整合服务，将 MySQL 汇总到 ES，还会有像 HBase 等大数据服务，用于使用量化模型做数据分析以及生成人群标签等 上线，大公司一般采用自动化上线系统，它们的内核开发有的是基于 Jenkins，也有一些是自研的，另外还有上云服务。上线之后还会有对应的 JMeter 压测服务和运行日志实时查询服务。 系统和数据库的监控，尤其对于业务体量大、流量较高、有秒杀和大促的业务场景时就更需要颗粒度更细的监控系统。比如需要知道 TP99、TP999、可用率、响应时长、TPS、QPS 等各项指标，来判断服务的整体可用度。数据库层面需要知道当前 IO 吞吐量、慢查询、事务、可用连接、LOAD 等综合指标和日常的数据报表。这些都是可以非常方便地反馈出整体服务的可用度。需求怎么来的需求确定和各方人员参与研发直到项目上线在传统行业和互联网有所不同：系统架构设计当完成 PRD 评审后，并不是立即开发，而要视需求大小进行不同层级的系统设计，这个过程包括：进入开发阶段当系统设计完成后，就正式进入开发阶段了，流程包括：系统上线维护当项目开发完成，并完成测试，就到了正式发布上线的阶段，流程如下：" }, { "title": "详解暴力递归", "url": "/posts/%E8%AF%A6%E8%A7%A3%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92/", "categories": "算法与数据结构", "tags": "", "date": "2022-10-18 00:00:00 +0800", "snippet": "介绍暴力递归暴力递归 = 暴力 + 递归对于递归，有下列规律： 递归函数要具体做什么（比如求1~10的和） 必须要有 basecase（即退出递归的条件） 必须缩小讨论的规模，求子问题，并且有得到了子问题之后的决策过程 不去深究递归过程是怎么样的，递归不记录子问题的解对于暴力：就是遍历所有的可能：关键在于如何列举出所有的可能注意何为规模缩小，即我们不从整体上（从头置为）去讨论一个问题，而是摘取其中一个部分进行讨论，比如对于一个序列 X[…i…]，我们优先讨论 i 和 i 之后的选择，i 之前的我们假设已经讨论过了经典例题汉诺塔问题三个塔，把左边的 n 个圆盘按小的在上的规则移到右边的塔，问一共需要移动几步，并且打印这个过程思路： 把所有 n 个圆盘看成一个整体，我们需要把 n 个圆盘从 from（左）移到 to（右） 为此我们首先要把上面 1~n-1 个圆盘移到 other（中间的塔），然后把 n 移到 to，再把 1~n-1 个盘移回从 other 移动到 to，重复 2 的操作code 如下：public class Solution{ public static void hanoi(int n){ if(n &amp;gt; 0){ func(n, &quot;左&quot;, &quot;右&quot;, &quot;中&quot;); } } public static void func(int i, String start, String end, String other){ if(i == 1){ System.out.println(&quot;Move 1 from&quot; + start + &quot; to &quot; + end); }else{ func(i - 1, start, other, end); System.out.println(&quot;Move &quot; + i + &quot; from&quot; + start + &quot; to &quot; + end); func(i - 1, other, end, start); } } public static void main(String[] args){ int n = 3; hanoi(n); }}leetcode 例题：面试题 08.06. 汉诺塔问题public class Solution{ /** * n：从 from 移到 to 的盘子数量 * from：出发的塔 * to：目标塔 */ public void hanota(int n, List&amp;lt;Integer&amp;gt; from, List&amp;lt;Integer&amp;gt; tmp, List&amp;lt;Integer&amp;gt; to){ if(n &amp;lt;= 1){ //basecase Integer num = from.remove(from.size() - 1); to.add(num); return ; } hanoi(n-1, from, to, tmp); //将盘子的上面 n-1 个一起从 from 移到 tmp Integer num = from.remove(from.size() - 1); //然后把第 n 个盘子从 from 移到 to to.add(num); hanoi(n-1, tmp, from, to); //再把那 n-1 个盘子一起从 tmp 移到 to }}打印字符串全部子序列，包括空字符串什么叫做子序列在数学中，某个序列的子序列是从最初序列通过去除某些元素但不破坏余下元素的相对位置（在前或在后）而形成的新序列。后半句话的意思：子数列的次序必须和主数列的次序一样，另外序列自己也是自己的子序列思路：对于字符串上的每个字符，在子串中有两种情况：0-不存在，1-存在解法1：public class Solution1{ public static void function(String str){ char[] chs = str.toCharArray(); process(chs, 0, new ArrayList&amp;lt;Character&amp;gt;()); } public static void process(char[] str, int i, List&amp;lt;Character&amp;gt; res){ if(i == str.length){ printList(res); return; } //递归会自动回溯，我们关注的重点是不要让res是同一个引用，否则回溯的时候会出错 List&amp;lt;Character&amp;gt; resKeep = copyList(res); resKeep.add(str[i]); process(str, i+1, resKeep); //保留当前字符 process(str, i+1, res); //不保留（可以直接传 res，而不用 copy，因为 res 的变化本身只依靠“保留这一操作”） } public static void printList(List&amp;lt;Character&amp;gt; res){ for (Character ch : res) { System.out.print(ch); } System.out.println(); } public static List&amp;lt;Character&amp;gt; copyList(List&amp;lt;Character&amp;gt; list){ ArrayList&amp;lt;Character&amp;gt; chs = new ArrayList&amp;lt;&amp;gt;(); list.forEach(chs::add); return chs; }}解法2（省空间）：public class Solution2{ public static void printAllSubsquence(String str){ char[] chs = str.toCharArray(); process(chs, 0); } public static void process(char[] str, int i){ if(i == str.length){ System.out.println(String.valueOf(str)); return; } process(str, i+1); //要当前字符 char tmp = str[i]; str[i] = 0; //转义成空字符&#39;&#39; process(str, i + 1); //不要当前字符 str[i] = tmp; //回溯之前还原 }}原题链接：打印全部子序列，题解如下：public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * 用来求出一个字符串的全部子序列，包含空字符串（因为这个不好统一输出的子序列，所以按照上课所讲写这个代码） * @param s string字符串 需要打印全部子序列的那个字符串 * @return string字符串一维数组 */ public String[] getAllSubs (String s) { char[] chas = s.toCharArray(); List&amp;lt;String&amp;gt; strList = new ArrayList&amp;lt;&amp;gt;(); process(strList, chas, &quot;&quot;, 0); String[] subs = strList.toArray(new String[0]); return subs; } private void process(List&amp;lt;String&amp;gt; strList, char[] chas, String curs, int i){ if(i == chas.length){ strList.add(curs); return; } //我并没有刻意去控制回溯，每次递归完之后，它自己就回溯了 process(strList, chas, curs, i + 1); //这里每次连接字符串就成为了一个新的对象，必须每次是新的对象，否则一旦改变会影响到之前添加的旧的对象 process(strList, chas, curs + chas[i], i + 1); }}打印一个字符串的全部排列（不出现重复的排列）字符串的排列思路： 不占任何空间，仅仅数组上交换位置生成不同的可能 如何生成不同的可能：数组上的每个位置都可由剩下的字符占用，还是以递归思路：假设 0…i-1 上的位置已经确定，i…n-1上的字符就有 i…n-1 上的字符交换生成 如何递归：如下图所示，先对数组上的位置遍历，然后对每个位置上可能的字符遍历 递归 basecase：当前遍历的位置 index = n - 1 如何去除重复：①如果字符的范围是 26 个大小写字母，可以使用一个 boolean 数组进行标记，如果范围更大就直接使用 HashSet 吧code：public class Solution{ public static List&amp;lt;String&amp;gt; permutation (String str) { // write code here List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); process(str.toCharArray(), 0, res); return res; } private static void process(char[] chs, int i, List&amp;lt;String&amp;gt; res){ if(i == chs.length){ res.add(String.valueOf(chs)); return; } //如果字符的范围更广，那就改为 HashSet 结构吧 boolean[] filter = new boolean[26]; for(int j = i; j &amp;lt; chs.length; j++){ int index = chs[j] - &#39;a&#39; &amp;lt; 0 ? chs[j] - &#39;A&#39; : chs[j] - &#39;a&#39;; if (!filter[index]){ filter[index] = true; swap(chs, i, j); process(chs, i + 1, res); swap(chs, i, j); } } } private static void swap(char[] chs, int i, int j) { char tmp = chs[i]; chs[i] = chs[j]; chs[j] = tmp; }}拿纸牌问题思路：同样我们还是采用暴力递归的解法（老套路了，递归函数是干嘛的，basecase 是什么，如何决策并缩小规模成为子问题）code 如下：首先是定义我们的递归函数，简单梳理一下题意，玩家从任意一端取一张牌，最后的牌的数目之和最大谁就是赢家，并输出最大的和，其实对于这种为一个序列，求和或者是求最大值的题目最适合用暴力递归做了，题目中说玩家都绝顶聪明，即他们最后都会使得自己的分数最大化，由于先手又是固定的，所以我们的递归函数可以是这样：/** * 在区间 [l, r] 上先手能获得的最大值 */private int f(int[] nums, int l, int r)/** * 在区间 [l, r] 上后手能获得的最大值 */private int s(int[] nums, int l, int r)注意：同一时刻先手和后手决策的区间一定是相同的，否者逻辑跑不通，或者说无法递归，即对于数组的某个区间 [l, r]，f 代表先手取得的最大值，s 代表后手取得的最大值，重申一遍：他们俩决策时的区间一定都是 [l, r]，而不是说先手是 [l, r]，后手就是 [l + 1, r] 或者 [l, r - 1]，理解了这一点，题目就完成了一半了（递归函数是干什么的讨论完成），接下来讨论该怎么决策： 先手和后手都递归一下 就递归先手，后手用总值减前者即可这里只讨论第2点，第1点直接给出代码，也许你已经想到了，玩家1在取完第一轮牌后，相对于玩家2就是后手了，而后手必然被先手取得的结果影响，即区间 [l, r] 上的和的最小值，因为先手一定会取 [l, r] 上的和的最大值，理解了这一点离成功就只剩一步之遥了（决策过程讨论完成）下面就是 basecase 了，很显然 l == r 就是 basecase，问题是我们该怎么退出，显然如果是先手，l == r 时，他就只能取这最后一张牌加到自己的和当中，如果是后手，l == r 就只能眼睁睁的看着先手取走了哈哈哈哈（basecase 讨论完成）下面是 code：/** * 第2点 */class Solution { public boolean PredictTheWinner(int[] nums) { int sum = 0; for (int i = 0; i &amp;lt; nums.length; i++) { sum += nums[i]; } int fMax = f(nums, 0, nums.length - 1); return fMax &amp;gt; (sum - fMax) ? fMax : (sum - fMax); } private int f(int[] nums, int l, int r) { if (l == r){ return nums[l]; } return Math.max(nums[l] + s(nums, l+1, r), nums[r] + s(nums, l, r-1)); } private int s(int[] nums, int l, int r) { if (l == r){ return 0; } return Math.min(f(nums, l+1, r), f(nums, l, r - 1)); }}/** * 第1点 */public class Solution{ public static int win1(int[] arr){ if(arr == null || arr.length == 0){ return 0; } //返回先手和后手的最大值 return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1)); } //先手 public static int f(int[] arr, int i, int j){ if(i == j){ return arr[i]; } //先手完成一轮后，在下一轮变成后手 return Math.max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1)); } //后手 public static int s(int[] arr, int i, int j){ if(i == j){ //已经完成选牌，不需要后手了，所以直接返回0 return 0; } //后手完成一轮后，在下一轮变成先手 return Math.min(f(arr, i + 1, j), f(arr, i, j - 1)); }}leetcode 相似题486. 预测赢家不申请额外的数据结构，只使用递归函数，逆序一个栈即如何在只有一个栈的情况下，将栈内的数据逆序，这道题是非常典型的递归解法题，采用了经典的递归策略，从递归的老套路来书，思路永远是最简单的，我们只需要按照大脑的第一反映想到的解法辅以简单的递归套路就可完成，下面是思路和 code。思路： 将栈底的元素出栈 逆序剩余其他元素的栈 将从栈底弹出的元素重新压栈解析：通过第二点我们将问题缩小规模变成子问题，而整个解决方案的功能就是逆序一个栈code：import java.util.Stack;public class Solution6 { /** * 反转栈 * @param stack */ public static void reverse(Stack&amp;lt;Integer&amp;gt; stack){ //basecase if (stack.isEmpty()){ return; } //弹出栈底的元素 int item = getBottomItem(stack); //反转剩余其他元素的栈 reverse(stack); //将栈底元素重新入栈 stack.push(item); } private static int getBottomItem(Stack&amp;lt;Integer&amp;gt; stack) { Integer res = stack.pop(); if (stack.isEmpty()){ return res; } int i = getBottomItem(stack); stack.push(res); return i; }}数字转换字符串思路：这是典型的爬楼梯问题，这里可以爬一层，也可以爬两层，加上限制条件即可，感觉比较简单，所以直接上代码吧！code ：public class Solution{ public static int translateNum(int num) { char[] arr = String.valueOf(num).toCharArray(); return process(arr, 0); } private static int process(char[] arr, int i) { if (i &amp;gt;= arr.length - 1){ return 1; } int count = 0; int num = Integer.parseInt(arr[i] + &quot;&quot;); if (num == 1){ return count + process(arr, i + 1) + process(arr, i + 2); }else if (num == 2){ return Integer.parseInt(arr[i+1]+&quot;&quot;) &amp;lt; 6 ? count + process(arr, i + 1) + process(arr, i + 2) : count + process(arr, i + 1); }else { //arr[i] = &#39;0&#39; || arr[i] &amp;gt;= &#39;3&#39; return count + process(arr, i + 1); } }}原题链接：剑指 Offer 46. 把数字翻译成字符串0-1背包问题的贪心解法code 如下：public class Solution{ //讨论 i 和 i 之后的货物选择，形成的最大价值返回 //重量永远不要超过 bag //i 之前做的决定，所达到的重量，alreadyweight public static int process1(int[] weights, int[] values, int i, int alreadyweight, int bag){ if(alreadyweight &amp;gt; bag){ return 0; } return Math.max( process1(weights, values, i + 1, alreadyweight, bag), values[i] + process1(weights, values, i + 1, alreadyweight + weights[i], bag)); }}" }, { "title": "MyBatis中四种模糊查询的方式", "url": "/posts/mybatis%E4%B8%AD%E5%9B%9B%E7%A7%8D%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F/", "categories": "框架, MyBatis", "tags": "", "date": "2022-10-18 00:00:00 +0800", "snippet": "mybatis的模糊查询方式一： 手动添加”%”通配符 xml配置：&amp;lt;!--模糊查询--&amp;gt;&amp;lt;select id=&quot;fuzzyQuery&quot; resultType=&quot;com.bin.pojo.Book&quot;&amp;gt; select * from mybatis.book where bookName like #{info};&amp;lt;/select&amp;gt; 测试：@Testpublic void fuzzyQuery(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BookMapper mapper = sqlSession.getMapper(BookMapper.class); List&amp;lt;Book&amp;gt; books = mapper.fuzzyQuery(&quot;%萨%&quot;); for (Book book : books) { System.out.println(book); } sqlSession.close();}说明：需要手动添加”%”通配符，显然这种方式很麻烦，并且如果忘记添加通配符的话就会变成普通的查询语句，匹配全部字符查询。 缺点： 麻烦 易出错 方式二： 在xml配置文件中添加”%”通配符，拼接字符串形式&amp;lt;select id=&quot;fuzzyQuery&quot; resultType=&quot;com.bin.pojo.Book&quot;&amp;gt; select * from mybatis.book where bookName like &#39;%${info}%&#39;;&amp;lt;/select&amp;gt;说明：在mapper.xml配置文件中添加”%”通配符，但是需要用单引号将其包裹住，但是用单引号裹住之后#{}就无法被识别，要改成${}这种拼接字符串的形式。虽然通过方式二优化了方式一的缺点，但同时也造成了SQL安全性的问题，也就是用户可以进行SQL注入。 缺点： 不安全，可进行SQL注入 方式三： 在xml配置文件中添加”%”通配符，借助mysql函数&amp;lt;select id=&quot;fuzzyQuery&quot; resultType=&quot;com.bin.pojo.Book&quot;&amp;gt; select * from mybatis.book where bookName like concat(&#39;%&#39;,#{info},&#39;%&#39;);&amp;lt;/select&amp;gt;说明：解决了SQL注入且能在配置文件中写”%”通配符的问题，完美实现了模糊查询 优点： 安全 方便 方式四： 与方式三一样使用mysqk函数，但使的用是${}形式，不过需要用单引号包裹住&amp;lt;select id=&quot;fuzzyQuery&quot; resultType=&quot;com.bin.pojo.Book&quot;&amp;gt; select * from mybatis.book where bookName like concat(&#39;%&#39;,&#39;${info}&#39;,&#39;%&#39;);&amp;lt;/select&amp;gt;总结： #{}是预编译处理，mybatis在处理#{}时，会将其替换成”?”，再调用PreparedStatement的set方法来赋值。 ${}是拼接字符串，将接收到的参数的内容不加任何修饰的拼接在SQL语句中，会引发SQL注入问题。" }, { "title": "详解贪心算法", "url": "/posts/%E8%AF%A6%E8%A7%A3%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/", "categories": "算法与数据结构", "tags": "", "date": "2022-10-15 00:00:00 +0800", "snippet": "介绍贪心算法在某个标准下，优先考虑满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫做贪心算法（相当于基于某个标准做个排序），也就是说贪心算法不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解，其中由局部最优 –&amp;gt; 整体最优的证明可能会很困难，也可能证明出来压根就是错误的，而对于确定的算法有时候可能又必须要求全局最优，这时候就需要局部最优 –&amp;gt; 整体最优的证明贪心算法在笔试中的解题套路 实现一个不依靠贪心策略的解法 X，可以用暴力的尝试 脑补出贪心策略 A、B、C…… 用解法 X，和对数器，去验证每个贪心策略，用实验的方式得知哪个贪心策略正确 不要去纠结贪心策略的证明（因为往往需要复杂的数学证明，即证明耗时长，难度大），当然常见的证明方法：举反例，这种方法是最高效的 另外贪心算法试题在笔试中占比可能比较少（因为贪心 code 很容易，重点在于能不能想到贪心策略，这就容易导致 0-1 分化的局面）贪心策略的技巧 根据某标准建立一个比较器来排序 根据某标准建立一个比较器来组成堆经典贪心例题-会议室一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个最多的宣讲次数。）思路： 我们的排序标准是哪个会议结束的时间早来优先安排（即按照会议结束时间进行排序） 每安排一个结束时间最早的会议就把与其冲突的会议排除，最后能安排的会议室就是最多的code：public static class Program{ public int start; public int end; public Program(int start, int end){ this.start = start; this.end = end; }}public static class ProgramComparator implements Comparator&amp;lt;Program&amp;gt;{ @Override public int compare(Program o1, Program o2){ return o1.end - o2.end; }}public static int bestArrange(Program[] programs, int timePoint){ Arrays.sort(programs, new ProgramComparator()); int result = 0; //按结束时间升序排好的数组 for(int i = 0; i &amp;lt; programs.length; i++){ //当前时间之后的会议能够安排 if(timePoint &amp;lt;= programs[i].start){ result++; //以第一个结束时间最早的会议结束时间更新当前时间 timePoint = programs[i].end; //排除其他于进行中的会议冲突的会议 } } return result;}贪心证明-将若干字符串连接保证字典序最小证明较为复杂，可前往 B 站左程云的相关课程观看 ab 和 abc，字典序比较 ab &amp;lt; abc贪心例题切金条-哈夫曼编码问题例题如下：思路： 将给定数组的数据全部放入小根堆中 每次弹出两个数做结合（相加），然后把结合后的数字放入小根堆 重复以上操作，直到弹出两个数后，小根堆为空，最后小根堆内只有一个数据code 如下：public static int lessMony(int[] arr){ PriorityQueue&amp;lt;Integer&amp;gt; pQ = new PriorityQueue&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; arr.length; i++){ pQ.add(arr[i]); } int sum = 0; int cur = 0; while(pQ.size() &amp;gt; 1){ cur = pQ.poll() + pQ.poll(); sum += cur; pQ.add(cur); } return sum;}项目起始资金和最后最大资金例题如下：题意：给出项目清单，每个项目由启动资金和利润两个数据构成，要求计算做完项目后（有些项目可能因为启动资金比较大，做不了）获得的最大钱数。思路： 准备一个按照项目启动资金排序的小根堆和一个按利润排序的大根堆 根据开发者拥有的资金 X，从小根堆中弹出 &amp;lt;= X 的数据到大根堆 然后从大根堆中弹出一个要做的项目，更新开发者拥有的资金，每次更新就继续执行 2 步骤 重复 2，3 操作，直到大根堆为空code 如下：public class Solution{ public static class Node{ public int p; public int c; public Node(int p, int c){ this.p = p; this.c = c; } } public static class MinCostComparator implements Comparator&amp;lt;Node&amp;gt;{ @Override public int compare(Node o1, Node o2){ return o1.c - o2.c; } } public static class MaxProfitComparator implements Comparator&amp;lt;Node&amp;gt;{ @Override public int compare(Node o1, Node o2){ return o2.p - o1.p; } } public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital){ PriorityQueue&amp;lt;Node&amp;gt; minCostQ = new PriorityQueue&amp;lt;&amp;gt;(new MinCostComparator()); PriorityQueue&amp;lt;Node&amp;gt; maxProfitQ = new PriorityQueue&amp;lt;&amp;gt;(new MaxProfitComparator()); // 所有项目扔到被锁池中，花费组织的小根堆 for(int i = 0; i &amp;lt; Profits.length; i++){ minCostQ.add(new Node(Profits[i], Capital[i])); } for(int i = 0; i &amp;lt; k; i++){ // 进行 k 轮 // 能力所及的项目，全解锁 while(!minCostQ.isEmpty() &amp;amp;&amp;amp; minCostQ.peek.c &amp;lt;= W){ maxProfitQ.add(minCostQ.poll()); } if(maxProfitQ.isEmpty()){ //大根堆为空，流程结束 return W; } W += maxProfitQ.poll().p; } return W; }}动态寻找中位数-堆的应用在一个数据流中，随时可以取得中位数思路： 准备一个大根堆和小根堆，对数据流中的每个数，判断是否 &amp;lt;= 大根堆堆顶的数据，如果是扔进大根堆，否则进小根堆 对于大根堆的 sizeA，和小根堆的 sizeB，判断是否 sizeA - sizeB == 2，如果是，size 大的一方弹出堆顶的数据到另一个堆 重复 1、2 操作直到数据流结束，如果数据流的总数是偶数，中位数就是大小根堆堆顶数据的和 / 2，否则就是 size 较大方的堆顶数据其实 1、2 的操作达到的效果就是将n个数据，较小的 n / 2，和较大的 n / 2 分别保存在两个堆中N 皇后问题例题如下：题意：给定一个 n * n 的棋盘，要求摆放 n 个棋子，并且所有棋子不同列不同行不在同一斜线，求共有几种摆法。思路：第一种：依然是深度优先遍历，通过暴力尝试，根据要求走出一条合适的摆法第二种：位运算优化，棋盘是 n * n 形式的，那么就用一个 n 位的二进制数表示棋盘中的一行，改行某个位置能不能放棋盘由二进制位的值（0-1）决定，而这个二进制数随着棋子的摆放会不断更新，总之改二进制数就表示了能摆放棋子的位置。code 如下：public class Solution{ public static int num1(int n){ if(n &amp;lt; 1){ //n &amp;lt; 1 不合法，默认返回 0 return 0; } int[] record = new int[n]; //record[i]：i行的皇后放在了第几列 return process1(0, record, n); } /** * 潜台词：record[0...i-1]各行已经放了皇后，并且任何两个皇后一定都不共行、不共列、不共斜线 * 目前来到第 i 行 * n 代表一共有 n 行 * 返回值是：摆完所有的皇后合理的摆法有多少种 */ public static int process1(int i, int[] record, int n){ if(i == n){ //终止行 return 1; } int res = 0; for(int j = 0; j &amp;lt; n; j++){ //在 i 行尝试所有的列 if(isValid(record, i, j)){ //第 i 行的皇后放在 j 列，并且不与 0~i-1 的皇后共行共列共斜线 record[i] = j; res += process1(i + 1, record, n); } } return res; } /** * 潜台词：当前是 i 行，因此与 0~i-1 一定不同行 */ public static boolean isValid(int[] record, int i, int j){ for(int k = 0; k &amp;lt; i; k++){ //record[k]：0~i-1 行的皇后放的列 if(j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)){ //同列、同斜线（行数差值 == 列数差值成45°：同斜线）不合法 return false; } } return true; }}时间复杂度：n!，即一共 n 行，每行会有 n 个摆放位置的可能，所以是 n!;常量级优化-位运算加速思路：code 如下：public class Solution{ public static int num2(int n){ if(n &amp;lt; 1 || n &amp;gt; 32){ //int 类型最多 32 位 return 0; } //limit 表示所有能放皇后的位置，1 能放，0 不能放 int limit = (n == 32 ? -1 : (1 &amp;lt;&amp;lt; n) - 1); return process2(limit, 0, 0, 0); } public static int process2(int limit, int coLim, //列限制，1 的位置不能放皇后，0 的位置可以 int leftDiaLim, //左斜线限制，1 的位置不能放皇后，0 的位置可以 int rightDiaLim){ //右斜线限制，1 的位置不能放皇后，0 的位置可以 if(colLim == limit){ //base case return 1; } //所有候选皇后的位置都在 pos 上，最终 1 的位置能放皇后，0 不能 int pos = limit &amp;amp; (~(colLim | leftDiaLim | rightDiaLim)); int mostRightOne = 0; int res = 0; while(pos != 0){ //对候选的位置（即为 1 的位置）一个一个试 mostRightOne = pos &amp;amp; (~pos + 1); //每次从最右的 1 开始 pos = pos - mostRightOne; //将占用的位置置为 0 res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) &amp;lt;&amp;lt; 1, //左斜线限制或运算后左移 (rightDiaLim | mostRightOne &amp;gt;&amp;gt;&amp;gt; 1)); //右斜线限制或运算后右移 } return res; }}" }, { "title": "详解前缀树", "url": "/posts/%E8%AF%A6%E8%A7%A3%E5%89%8D%E7%BC%80%E6%A0%91/", "categories": "算法与数据结构", "tags": "", "date": "2022-09-24 00:00:00 +0800", "snippet": "介绍前缀树何为前缀树前缀树（Trie树），即字典树，又称单词查找树或键树，是一种树形结构，典型应用是用于统计和排序大量的字符串（但不限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的核心思想是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。如何创建前缀树有如下字符串：【”abc”, “bck”, “abd”, “ace”】，建树过程如下： 前缀树的根节点是空节点 经典前缀树的字符都是在路径上的，而不是节点上 对于每个字符，判断是否存在根节点到该字符的路径，没有就创建，有就复用 虽然经典前缀树，节点上是没有额外信息的，但是为了某些功能，常常会把节点上的信息变得更加丰富为节点添加丰富信息前缀树节点codepublic static class TrieNode{ public int pass; public int end; //HashMap&amp;lt;Char, TrieNode&amp;gt; nexts //TreeMap&amp;lt;Char, TrieNode&amp;gt; nexts public TrieNode[] nexts; //该节点下有无通向字符的路 public TrieNode(){ pass = 0; end = 0; //next[0] = null 没有走向‘a’的路 //next[0] != null 有走向‘a’的路 nexts = new TrieNode[26]; //我们定义了一个26容量的数组，0~25分别对应a~z }}TrieNode中我们为节点丰富了更多的信息，如pass、end和nexts属性。通过他们我们可以实现更多的功能： pass 值：以根节点到该节点对应的字符串为前缀的字符串的数目，空节点的 pass 值表示以空串为前缀的字符串的数目 end 值是以根节点到该节点对应的字符串的数量 通过 nexts，可知该节点下有没有路，如果nexts所有元素都为空那么就没有路了 如果字符串的字符除了26个字母，还存在其他字符，那么可以使用 hash 表，如果需要每个节点下的路径是有序组织的，那么可以使用有序表结构操作前缀树的方法插入节点到前缀树已知某字符在前缀树中不存在，就需要创建该字符对应的节点，code 如下：public void insert(String word){ if(word == null){ return ; } char[] chs = word.toCharArray(); TrieNode node = root; node.pass++; int index = 0; for(int i = 0; i &amp;lt; chs.length; i++){ index = chs[i] - &#39;a&#39;; //求路径在next中的下标 if(node.nexts[index] == null){ node.nexts[index] = new TrieNode(); } node = node.nexts[index]; node.pass++; //这条路径有多少单词经过 } //单词在前缀树中插入完成，当前节点是单词的尾节点 node.end++;}解释一下节点的意思：节点即表示某条路径的终止，所以每条路径的最后都会存在一个节点，这也是为什么在插入业务中某个字符不存在我们是直接创建一个节点，创建了该节点就表示以该字符结尾的路径形成了或（子）字符串存入完毕了查询某个单词在前缀树中加入过几次code如下：public int search(String word){ if(word == null){ return 0; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for(int i = 0; i &amp;lt; chs.length; i++){ index = chs[i] - &#39;a&#39;; if(node.nexts[index] == null){ return 0; //如果字符串还未结束，路走不下去了，说明该字符串还未曾加入到前缀树 } node = node.nexts[index]; } return node.end;}所有加入的字符串中，有几个是以 pre 这个字符串作为前缀的code如下：public int search(String word){ if(word == null){ return 0; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for(int i = 0; i &amp;lt; chs.length; i++){ index = chs[i] - &#39;a&#39;; if(node.nexts[index] == null){ return 0; //如果 pre 还未结束，路走不下去了，说明没有以 pre 作为前缀的字符串加入到前缀树中 } node = node.nexts[index]; } return node.pass;}删除某个单词在前缀树中的痕迹有两种情况： 删除痕迹后，每个节点的 pass 都不为0 删除后，存在某个节点的 pass == 0code 如下：public void delete(String word){ if(search(word) != 0){ //首先得判断该字符串在前缀树种是否存在 char[] chs = word.toCharArray(); TrieNode node = root; node.pass--; int index = 0; for(int i = 0; i &amp;lt; chs.length; i++){ index = chs[i] - &#39;a&#39;; if(--node.nexts[index].pass == 0){ node.nexts[index] = null; //如果某节点对应的字符串，已经没有以它为前缀的了，后面的路径就都无效了，那么直接置为 null return; } node = node.nexts[index]; } node.end--; }}" }, { "title": "Redis键值过期操作", "url": "/posts/Redis%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C/", "categories": "数据库, Redis", "tags": "", "date": "2022-09-21 00:00:00 +0800", "snippet": "过期设置、查看key的剩余存活时间、移除过期时间等指令过期时间设置，并查看key剩余存活时间 expire key seconds：设置 key 在 n 秒后过期； pexpire key milliseconds：设置 key 在 n 毫秒后过期； expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期； pexpireat key millisecondsTimestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；1和3使用ttl查询，2和4采用pttl查询，如果返回结果为-1，说明键值永不过期字符串数据类型中的过期时间设置 set key value ex seconds：设置键值对的同时指定过期时间（精确到秒）； set key value px milliseconds：设置键值对的同时指定过期时间（精确到毫秒）； setex key seconds valule：设置键值对的同时指定过期时间（精确到秒）。移除过期时间指令：persist key持久化中的过期键RDBAOF主从库的过期键值从库时被动的接收主库的指令对过期键进行删除操作" }, { "title": "Redis过期策略", "url": "/posts/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/", "categories": "数据库, Redis", "tags": "", "date": "2022-09-21 00:00:00 +0800", "snippet": "过期键的检查机制Redis维护一个存储了所有设置了过期值的键值，称之为过期字典过期策略Redis为什么要制定一堆过期策略由于Redis是单线程操作，因此为了避免键值删除操作影响主业务的进行，那么就有必要制定出合适的过期删除策略三种过期策略 惰性删除：使用时判断，已过期则删除 定时删除：创建定时器，到过期时间立即删除 定期删除：每段时间删除一次，具体看算法，一般检查一定规模的数据（随机抽取数据而非全部遍历），如果过期数据占比较多，扩大检查范围，同时为了保证过期扫描不影响 Redis 主业务，Redis 的定期删除策略中还提供了最大执行时间，以保证 Redis 正常并高效地运行。Redis实际使用的策略惰性删除和定期删除两种策略，通过配合使用这两种删除策略，可以很好地在合理使用CPU和避免浪费内存之间取得平衡。" }, { "title": "Redis事务", "url": "/posts/Redis%E4%BA%8B%E5%8A%A1/", "categories": "数据库, Redis", "tags": "", "date": "2022-09-21 00:00:00 +0800", "snippet": "Redis事务和MySQL事务对比（主要是操作流程）MySQL： 开启事务 执行事务 提交（正常执行）/（出现异常）回滚事务Redis： 开启事务 任务入队列（一个先进先出的结构，命令的执行顺序是先进先执行） exec/discard事务机制：事务开启后，每次输入的指令会依次入事务队列，待执行exec执行后，队列中的命令会按照进入顺序，依次执行命令介绍 multi：开启事务，事务执行之后不能嵌套执行 exec：执行事务 discard：放弃整个事务 expire：设定过期值（值只能为数字，如 expire key 10，而expire key 10s是错误的） watch：用于在客户端并发中，为事务提供一个乐观锁（也就是CAS，及Check And Set），也就是在执行了watch命令并监控了某几个变量，如果变量被并发事务更改，事务就会发生回滚 unwatch：是否所有变量的乐观锁（在）事务错误和回滚 执行时错误（不回滚），如对于命令expire k 10s，本身没有缺少参数，但是参数的类型是错误的，因此在执行的时候会报错 指令入队列时错误，并且会终止整个事务（回滚），如对于指令set k，因为缺少参数，会在入队列时发生错误，并且会终止整个事务（事务开启后的指令都不会执行） 指令入队列时错误，不会终止整个事务（不回滚），如：在开启事务后，输入指令multi，在事务中嵌套开启事务，不能入队列，发生错误，但是不会影响事务的执行Redis为什么不支持运行时错误事务回滚 作者认为错误通常是编译错误造成的，这些错误通常在开发环境中出现，极少出现在生产环境中 与Redis追求简单高效的设计原则不符watch指令种的事务回滚 watch执行的时机：在事务开启之前执行 即使把原对象的值重新赋值给原对象，watch依然生效 在事务中执行watch命令会报错，但不会终止事务预留问题是否在队列中如果有指令unwatch的存在，watch就没有用了总结事务回滚的情况 watch监控的变量在事务执行期间被修改 指令缺少参数时入队列" }, { "title": "每日一题", "url": "/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/", "categories": "算法与数据结构, 每日一题", "tags": "", "date": "2022-09-14 00:00:00 +0800", "snippet": "22.09.15最长回文串解法1：动态规划最初的思路： 找一种方法枚举出所有的字符串字串 判断各个字符串是否会问子串，留下长度较大的子串" }, { "title": "JVM内存结构详解", "url": "/posts/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/", "categories": "JVM", "tags": "", "date": "2022-09-13 00:00:00 +0800", "snippet": "JVM组成部分如下图：结构简析： Java程序需要首先编译成字节码，再由JVM的类加载器模块加载到JVM当中 JVM内存结构分为【方法区】、【Heap堆】、【虚拟机栈】、【程序计数器】、【本地方法栈】 方法区主要存在类的定义，像类字段、方法数据、方法和构造器代码（包括类构造器、实例构造器、接口构造器） 对象空间在堆区分配，而对象调用方法会创建栈帧，就要使用到虚拟机栈 而方法的执行（包括JVM指令）就需要程序计数器记住下一条要执行的命令 Java程序无法调用操作系统api，需要借助本地方法（C或C++编写的，如Object类中的wait()、clone()等），而也本地方法的调用于普通方法类似，不过会存在本地方法栈当中程序计数器程序计数器有什么作用它可以记住下一条指令的地址程序计数器在什么时候发挥作用呢 cpu的调度组件会给每个线程分配时间片，当时间片用完，线程会发生切换，而切换的线程需要知道之前指令执行的位置，这个时候就需要程序计数器器了 另外在指令的执行过程中，程序计数器也会实时更新，如下图经反编译生成的方法指令 指令前面的编号，我们其实就可以看作指令的内存地址，虽然指令之间间隔不同，那是因为一条指令由操作码和操作数组成，操作码由一个字节存储，操作数就确定了，所以地址间隔会有不同，每执行到当前指令，程序计数器就会记住下一条要执行的指令，而每条JVM指令通过解释器，最终由cpu执行程序计数器器的特点 线程私有 JVM结构中唯一一个不会出现内存溢出的错误程序计数器的物理实现通过寄存器实现虚拟机栈（也称为线程栈）它在JVM中的位置如下图：虚拟机栈的概念 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存 每个线程只有有一个活动栈帧，对应着当前正在执行的那个方法栈帧的结构结构图如下：栈帧的具体大小在编译期就能确定，栈帧的结构主要组成部分如下： 局部变量表 操作数栈 类引用，指向方法区中类的定义 方法引用（或者说方法返回地址），同样时方法区中类中的方法定义 方法返回值虚拟机栈的思考 垃圾回收是否涉及内存 栈内存分配越大越好吗？ 方法内的局部变量是否线程安全？ 不涉及，垃圾回收的区域主要针对heap堆（也称作GC 堆），即由垃圾回收器管理的堆，而对于虚拟机栈，栈帧随着方法调用创建，随着方法结束弹出，因此它的内存会自动销毁，并不需要GC进行回收 不是的，栈内存分配的越大，能够创建的线程数量就会越少，显然会影响并发量 是的，虚拟机栈是线程私有的，不存在多个线程共享的问题，自然不会有线程安全问题方法中的线程安全问题看下面的代码：public class ThreadTest{ public static void public static void main(String[] args) { StringBuilder sb = new StringBuilder(); sb.append(4); sb.append(5); sb.append(6); new Thread(() -&amp;gt; { m2(sb); }).start(); } public static void m1(){ StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString()); } public static void m2(StringBuilder sb){ sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString()); } public static StringBuilder m3(){ StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); return sb; }}分析可得： m1的显然不会存在线程安全问题，问题在于m2和m3 我们发现，m2，m3要么对象是形参，要么会作为返回值返回，而判断对象是否存在线程安全问题，就在于一个对象会不会存在多个线程访问，显然无论是返回值还是形参，都有可能被其他线程所访问，所以m2和m3是存在线程安全问题的，这个时候就应该使用StringBuffer而不是StringBuilder栈内存溢出栈内存溢出的常见场景 栈帧过多（如无限递归调用、循环依赖） 栈帧多大，即一个栈帧非常大，直接撑爆了虚拟机栈栈内存溢出演示代码之无限递归1public class StackOverflowErrorTest{ private static int count; public static void main(String[] args) { try{ method1(); } catch(Throwable e){ e.printStackTrace(); System.out.println(count); } } private static void method1(){ count++; method1(); }}在服务器上运行这个程序，会报下面的错误：java.lang.StackOverflowError at StackOverflowErrorTest.method1(StackOverflowErrorTest.java:15) at StackOverflowErrorTest.method1(StackOverflowErrorTest.java:15) at StackOverflowErrorTest.method1(StackOverflowErrorTest.java:15) ..... at StackOverflowErrorTest.method1(StackOverflowErrorTest.java:15) at StackOverflowErrorTest.method1(StackOverflowErrorTest.java:15) at StackOverflowErrorTest.method1(StackOverflowErrorTest.java:15) at StackOverflowErrorTest.method1(StackOverflowErrorTest.java:15)21705这个就是典型的栈溢出错误了java.lang.StackOverflowError，在IDEA中可以调整堆内存的大小，如下图：修改之后可以看到count的数值明显变小了，虚拟机栈的默认大小是1Mjava.lang.StackOverflowError at com.flameking.stack.StackOverflowErrorTest.method1(StackOverflowErrorTest.java:17) at com.flameking.stack.StackOverflowErrorTest.method1(StackOverflowErrorTest.java:17) at com.flameking.stack.StackOverflowErrorTest.method1(StackOverflowErrorTest.java:17) at com.flameking.stack.StackOverflowErrorTest.method1(StackOverflowErrorTest.java:17) at com.flameking.stack.StackOverflowErrorTest.method1(StackOverflowErrorTest.java:17)7755栈内存溢出演示代码之无限递归2/** * 第三方json转换库调用 */public class StackOverflowErrorTest2{ public static void main(String[] args) { Dept d = new Dept(); d.setName(&quot;Market&quot;); Emp e1 = new Emp(); e1.setName(&quot;zhang&quot;); e1.setDept(d); Emp e2 = new Emp(); e2.setName(&quot;li&quot;); e2.setDept(d); d.setEmps(Arrays.asList(e1, e2)); ObjectMapper mapper = new ObjectMapper(); System.out.println(mapper.writeValueAsString(d)); }}@Dataclass Dept{ private String name; private List&amp;lt;Emp&amp;gt; emps;}@Dataclass Emp{ private String name; //解决方法 // @JsonIgnore private Dept dept;}这段代码存在无限递归：属性之间存在循环依赖，Dept依赖Emp，Emp依赖Dept，结果就导致循环依赖报错如下：Exception in thread &quot;main&quot; com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion (StackOverflowError)线程运行诊断案例1：CPU占用过多某个程序CPU占用高达90%以上，影响其他程序的运行code如下：public class PayloadOfCPUTest { public static void main(String[] args) { new Thread(null, () -&amp;gt; { System.out.println(&quot;1....&quot;); while (true){ } }, &quot;thread1&quot;).start(); new Thread(null, () -&amp;gt; { System.out.println(&quot;2....&quot;); try{ Thread.sleep(1000000L); } catch (InterruptedException e){ e.printStackTrace(); } }, &quot;thread2&quot;).start(); new Thread(null, () -&amp;gt; { System.out.println(&quot;3....&quot;); try{ Thread.sleep(1000000L); } catch (InterruptedException e){ e.printStackTrace(); } }, &quot;thread3&quot;).start(); }}以下面的命令开始启动程序，并进行运行诊断1.首先在服务器输入命令：nohup java PayloadOfCPUTest &amp;amp;，让程序在后台运行2.输入top实时检测Java代码，如下图所示：我们发现top能监测到某个进程的cpu占用情况，并且可以查看到进程ID，但是无法定位到具体的线程，并且无法定位到代码中具体的位置3.输入ctrl c结束top命令，然后继续输入命令：ps H -eo pid,tid,%cpu，其中H代表输出所有进程，-eo 表示具体想要显示的信息，这里就会显示进程ID，线程ID，和cpu占用，显示结果如下： PID TID %CPU 1 1 0.0 8 8 0.0......14799 14809 0.014799 14810 0.014799 14811 99.914799 14812 0.014799 14813 0.0......我们可以发现，除了我们要定位到的进程和线程信息，还有很多其他的信息，这时候可以用命令ps H -eo pid,tid,%cpu | grep 14799，过滤出我们想要的进程的所有线程信息，结果如下：这样我们就定为到了具体的线程ID了4.为了查看具体的线程状态我们使用jdk的一个命令：jstack 进程ID，这个命令能打印输出该进程的所有线程状态信息的快照，输入后得到如下结果：在这其中我们发现了自己创建的thread1线程，而其他的特殊名字的线程都是JVM自己的线程，从打印信息中看我们的程序处于Runnable状态，并且下面还定位到了代码中可能出现问题的位置，第5行，我们用vim命令打开PayloadOfCPUTest.java文件，发现确实在第5行出现了while死循环，这也就是问题的根源：5.根据ps命令我们定位到了线程ID，而在jstack打印的线程信息中，编号是16进制的，将14811转换成16进制39DB，我们发现就是thread16.在去修改代码之前，别忘了结束进程，kill 14799，kill 进程ID，结束进程到这我们的线程运行诊断就结束了，我们已经定位到了具体的代码行数，接下来就可以自行修改代码，解决问题了注意在IDEA中有个自带的功能可以是先jstack的效果案例2：程序运行很久没有结果（死锁）code如下：package com.flameking.stack;class A { }class B { }public class DeadlockTest { static A a = new A(); static B b = new B(); public static void main(String[] args) throws InterruptedException { new Thread(() -&amp;gt; { //1.线程先获得a的monitor锁，接下来便进行休眠 synchronized (a) { try { Thread.sleep(2000); } catch (InterruptedException e){ e.printStackTrace(); } //4.此时线程先要获取b对象的monitor锁，但是也已经被占用，所以进入阻塞状态 synchronized (b){ System.out.println(&quot;我获得了a和b&quot;); } } }).start(); //2.main线程休眠 Thread.sleep(1000); //3.在其他线程休眠期间，该线程会获取到对象b的monitor锁，进而想要获取a的monitor锁 //然而目前a被其他线程，占用，该线程进入阻塞状态 new Thread(() -&amp;gt; { synchronized (b){ synchronized (a){ System.out.println(&quot;我获得了a和b&quot;); } } }).start(); }}这个程序最终两个线程会因为对方互相占用了锁并且也不释放，导致死锁，下面演示排查过程，如下图： 执行命令：nohup java DeadlockTest &amp;amp; 执行命令：jstack 进程ID我们可以看到jstack打印信息的最后面的部分，可以看到下面的信息：Found one Java-level deadlock:=============================&quot;Thread-1&quot;: waiting to lock monitor 0x00007fab28003778 (object 0x00000000ecc5d220, a A), which is held by &quot;Thread-0&quot;&quot;Thread-0&quot;: waiting to lock monitor 0x00007fab280062c8 (object 0x00000000ecc5de68, a B), which is held by &quot;Thread-1&quot;Java stack information for the threads listed above:===================================================&quot;Thread-1&quot;: at DeadlockTest.lambda$main$1(DeadlockTest.java:27) - waiting to lock &amp;lt;0x00000000ecc5d220&amp;gt; (a A) - locked &amp;lt;0x00000000ecc5de68&amp;gt; (a B) at DeadlockTest$$Lambda$2/303563356.run(Unknown Source) at java.lang.Thread.run(Thread.java:750)&quot;Thread-0&quot;: at DeadlockTest.lambda$main$0(DeadlockTest.java:17) - waiting to lock &amp;lt;0x00000000ecc5de68&amp;gt; (a B) - locked &amp;lt;0x00000000ecc5d220&amp;gt; (a A) at DeadlockTest$$Lambda$1/471910020.run(Unknown Source) at java.lang.Thread.run(Thread.java:750)Found 1 deadlock.从第一行我们就能明显看出，程序出现了死锁问题，从370行后面能够看到死锁产生的具体原因，到这我们的死锁诊断就完成了总结在线程诊断中，我们用到了下面这些命令： nohup java 程序名 &amp;amp;，后台运行Java程序 top，实时监控进程cpu占用情况 ps H -eo pid,tid,%cpu | grep 进程ID，过滤出指定进程的所有线程占用cpu情况 jstack 进程ID，能打印出线程更加详细的状态信息快照本地方法栈也是线程私有的，它给本地方法的运行提供内存，本地方法（native method）：不是由Java语言编写的（Java不能直接与操作系统api交互，这时候就需要使用本地方法，它们大多是使用C、C++编写的）GC堆通过new关键字创建的对象都会使用GC堆的内存特点 它是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制，具体也是针对GC堆GC堆在堆内存中的位置如下：从图中来简单看看堆内存的组成，后面会详细介绍： heap堆（GC堆） 年轻代 新生代 存活区：S0、S1 老年代 非堆（Non-Heap） 方法区 堆内存溢出试想一个问题：为什么堆内存有垃圾回收机制自动回收垃圾，还会出现堆内存溢出现象呢？ 因为堆内存会将那些空闲的对象，比如在代码中将对象引用指向null后，对象就会自动有垃圾回收器回收但也有这样的情况，程序不断的生成对象，而且每个对象都有在使用，这样慢慢积累对象，最后就会出现堆内存溢出堆内存溢出演示代码public class HeapSpaceTest{ public static void main(String[] args) { int i=0; try{ List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); String a = &quot;hello&quot;; while(true){ list.add(a); a = a + a; i++; } } catch(Throwable e){ e.printStackTrace(); System.out.println(i); } }}代码大致逻辑：不断拼接字符串，然后将每次拼接得到的字符串存在list当中，因为list一致不断在使用，同时字符串也存在list中，因此都有在使用，所以不会有垃圾回收运行一段时间后，报错：java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at com.flameking.HeapSpaceTest.main(HeapSpaceTest.java:14)26修改堆内存的大小通过-Xmx指令修改堆内存大小：修改后能明显发现i的值变小，测试后i为17注意：如果我们要排查堆内存溢出问题，应该把堆内存设置的小一些，这样能够尽早的排除出问题堆内存诊断工具 jps工具，查看当前系统中有哪些Java进程 jmap工具，拿到进程ID后，查看堆内存使用情况，只能查询某个时刻堆内存情况 jconsole功能，图形界面，多功能检测进程，线程，cpu等，并能连续检测诊断演示代码public class HeapToolTest { public static void main(String[] args) throws InterruptedException { System.out.println(&quot;1.....&quot;); Thread.sleep(30000); byte[] array = new byte[1024*1024*10]; //10Mb System.out.println(&quot;2.....&quot;); Thread.sleep(20000); array = null; System.gc(); System.out.println(&quot;3.....&quot;); Thread.sleep(1000000L); }}程序大致逻辑：程序运行时会有三个不同点状态，第一个是起始运行状态，第二个是创建了一个10Mb字节数组的状态，第三个是回收了字节数组的状态使用诊断工具检测堆内存状态注意这些工具请在Linux环境下运行，jmap在Windows环境下不太好用1.用jsp命令查询所有的进程，输入：jps2.执行命令：jmap -heap 进程ID，这样我们能在其中看到GC堆的各个结构的大小，如年轻代，新生代，老年代，最大堆内存大小等等，打印结果如下：Attaching to process ID 14120, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.341-b10using thread-local object allocation.Parallel GC with 2 thread(s)Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 968884224 (924.0MB) NewSize = 19922944 (19.0MB) MaxNewSize = 322961408 (308.0MB) OldSize = 40894464 (39.0MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space: capacity = 15728640 (15.0MB) used = 629224 (0.6000747680664062MB) free = 15099416 (14.399925231933594MB) 4.000498453776042% usedFrom Space: capacity = 2097152 (2.0MB) used = 0 (0.0MB) free = 2097152 (2.0MB) 0.0% usedTo Space: capacity = 2097152 (2.0MB) used = 0 (0.0MB) free = 2097152 (2.0MB) 0.0% usedPS Old Generation capacity = 40894464 (39.0MB) used = 0 (0.0MB) free = 40894464 (39.0MB) 0.0% used710 interned Strings occupying 47392 bytes.以上两个工具介绍完成，开始介绍jconsole工具的使用，在命令行输入：jconsole命令，会弹出一个窗口：点击要检测的程序，进行连接，连接后的界面如下：其中的Threads功能界面就可以发挥jstack的作用堆内存工具诊断案例：垃圾回收后内存占用仍然很高code如下：import java.util.ArrayList;import java.util.List;public class GCTest { public static void main(String[] args) throws InterruptedException { List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 200; i++) { students.add(new Student()); } Thread.sleep(1000000000L); }}class Student{ private byte[] big = new byte[1024*1024];}我们先使用jps和jconsole命令诊断，然后在jconsole中进行手动GC回收，如下：虽然使用了上诉两个命令，但是仍然没能排查出问题，所以下面我们使用一个工具，叫做jvisualvm，输入命令：jvisualvm，得到如下界面：点击进入到我们要排查的程序，这里是GCTest，进去之后能看到下面的界面：而我们实际要进入的界面是下面的这个：前20最大的对象信息如下：第一个ArrayList对象的内部信息如下：总结我们总共介绍了四款工具，分别是： jps，查看所有的Java进程 jmap，查询Java进程的堆内存使用情况 jconsole，实时查看堆内存情况，功能也更多 jvisualvm，它基本包含了1，2，3的功能方法区方法区存在的位置就是非堆当中，但它其实是一个规范，具体要看各个jvm的实现方法区的特性 运行时常量池，类定义信息：类字段，方法数据，方法和构造器代码（类构造器、实例构造器 方法区在虚拟机启动时创建，并且在逻辑上是堆的一部分（在不同的jvm实现上会有不同，虽然规范这样要求，但也不是每个jvm实现都遵守了的） 方法区会导致JVM内存溢出下面是hotspot在1.6和1.8方法区的不同实现：在1.6中，方法区的实现被称作永久代，里面包含常量池信息，类定义信息，类加载器信息，并且放在堆内存中而在1.8中被称作元空间，这个时候StringTable从常量池抽取出来放在了Heap堆中，而元空间整个移进了本地内存中（也就是操作系统内存）方法区内存溢出演示代码如下：import jdk.internal.org.objectweb.asm.ClassWriter;import jdk.internal.org.objectweb.asm.Opcodes;public class MethodspaceTest extends ClassLoader{ public static void main(String[] args) { int j = 0; try { MethodspaceTest test = new MethodspaceTest(); for (int i = 0; i &amp;lt; 10000; i++, j++) { //ClassWriter 作用是生成类的二进制字节码 ClassWriter cw = new ClassWriter(0); //版本号（1.8），public（类的访问修饰符），类名，报名，父类，接口 cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null); //返回byte[] byte[] code = cw.toByteArray(); //执行类的加载（大量的类加载到元空间就会造成内存溢出） test.defineClass(&quot;Class&quot; + i, code, 0, code.length); } }finally { System.out.println(j); } }}之前我们在jmap中输出的信息看到，元空间的最大空间可以很大，因此这里运行并不会导致内存溢出，我们可以通过指令-XX:MaxMetaspaceSize=8m，将元空间大小改位8m，再次执行，结果如下：5411Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.lang.ClassLoader.defineClass(ClassLoader.java:642) at com.flameking.methodspace.MethodspaceTest.main(MethodspaceTest.java:19)如果是1.6版本的话，这里报的错就是java.lang.OutOfMemoryError: PermGen space实际应用中可能会出现元空间溢出的场景Spring、MyBatis使用cglib采用的字节码动态生成技术生成代理类，它们其实就非常容易导致OOM错误的，我们上面的演示代码用的就是跟Spring、MyBatis同样的字节码动态生成技术运行时常量池首先看看常量池，我们使用javap -v .class文件，会输出类的信息（类基本信息，如类的访问修饰符，类使用的Java版本，类的名称，类的父类，类的接口信息等等），常量池信息，类方法的定义（包含虚拟机指令）常量池和运行时常量池 常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 常量池是.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号变为真实地址" }, { "title": "图", "url": "/posts/%E5%9B%BE/", "categories": "算法与数据结构", "tags": "", "date": "2022-09-10 00:00:00 +0800", "snippet": "图的存储方式如何表达图？生成图？图又分为无向图，有向图，它们该怎么表示对于图G = (V，{E})，其中V表示顶点集合，E则是边的集合邻接表邻接表有下列两个结构： 顶点表 边表结构如下：以无向图为例：参考： 图的邻接表表示法（C语言）邻接矩阵以无向图为例： 第一种是无向无权图的建模，无向无权图G=(V，E)有n(n≧1)个顶点，其邻接矩阵是n阶对称方阵，两顶点联通则为1，否则为0，其元素的定义如下： 第二种是无向有权图，这时矩阵值就是权值了，如果两顶点不连通则为正∞，建模如下： 参考： 邻接矩阵表示法统一图的表达由于图的实现结构多种多样，对于每一种结构，都有一套不同的图运算api，因此要想掌握全部的图的表达方式非常困难，因此为了解题更加方便快速，我们应该选择自己喜欢和熟练的图的表达方式来实现所有的api，那么面对不同的结构，我们只需要将陌生的图结构转换成我们准备好的图结构就好了我的图结构（邻接表） 图的总结构：即顶点集和边集public class Graph{ //顶点集：key是顶点的编号，value是顶点的实际结构，如果顶点结构较为简单，可以将哈希表替换为数组，这样效率会更高 public HashMap&amp;lt;Integer, Node&amp;gt; nodes; //边集，Edge是边的结构 public HashSet&amp;lt;Edge&amp;gt; edges; public Graph(){ nodes = new HashMap&amp;lt;&amp;gt;(); edges = new HashSet&amp;lt;&amp;gt;(); }} 顶点的实际结构Nodepublic class Node{ //入度（无向图出度和入度相等） public int in; //出度 public int out; //由当前顶点发散出去的边所连接的其他顶点（也被称为直接邻居） public ArrayList&amp;lt;Node&amp;gt; nexts; //当前顶点发散出去的边的集合 public ArrayList&amp;lt;Edge&amp;gt; edges; public Node(int value){ this.value = value; in = 0; out = 0; nexts = new ArrayList&amp;lt;&amp;gt;(); edges = new ArrayList&amp;lt;&amp;gt;(); }} 边的实际结构Edgepublic class Edge{ //权值 public int weight; public Node from; public Node to; public Edge(int weight, Node from, Node to){ this.weight = weight; this.from = from; this.to = to; }} 图的接口函数public class GraphGenerator{ /** * matrix是一个n*3的矩阵，其中n代表节点个数，这应该是个有向图 * 结构：【weight, from节点上的值，to节点上面的值】 */ public static Graph createGraph(Integer[][] matrix){ Graph graph = new Graph(); for (int i = 0; i &amp;lt; matrix.length; i++) { Integer weight = matrix[i][0]; Integer from = matrix[i][1]; Integer to = matrix[i][2]; //初始化图的顶点集，key为value，如果在图的顶点集中已经存在，就不需要存了 if (!graph.nodes.containsKey(from)) { graph.nodes.put(from, new Node(from)); } if(!graph.nodes.containsKey(to)){ graph.nodes.put(to, new Node(to)); } //初始化起点，终点，和边的实际结构 Node fromNode = graph.nodes.get(from); Node toNode = graph.nodes.get(to); Edge newEdge = new Edge(weight, fromNode, toNode); //给起点添加直接领居 fromNode.nexts.add(toNode); //出度++ fromNode.out++; //终点的入度++ toNode.in++; //添加到起点的发散的边集中 fromNode.edges.add(newEdge); //添加到图的边集中 graph.edges.add(newEdge); } }}图的宽度优先遍历基本思路： 利用队列实现 从源节点开始依次按照宽度进队列，然后弹出 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列 直到队列变空code如下：public class GraphGenerator{ //从图的某个顶点出发 public static void bfs(Node node){ if(node == null){ return; } Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); //相比于二叉树，图是可能存在环的，而set的作用就是为了避免遍历因为环陷入死循环， //我们将已经遍历的顶点记录在set中，这样就不会重复遍历了 HashSet&amp;lt;Node&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); queue.add(Node); set.add(node); while(!queue.isEmpty()){ Node cur = queue.poll(); //如果是其他处理逻辑，就替换打印操作就行了 System.out.println(cur.value); for (Node next : cur.nexts) { //如果顶点已存在set中，那么不对它重复处理，也就是不加到队列 if(!set.contains(next)){ set.add(next); queue.add(next); } } } }}图的广度优先遍历基本思路： 利用栈实现 从源节点开始依次按照深度放入栈，然后弹出 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈 直到栈变空code如下：public class GraphGenerator{ //从图的某个顶点出发 public static void dfs(Node node){ if(node == null){ return; } Stack&amp;lt;Node&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); //相比于二叉树，图是可能存在环的，而set的作用就是为了避免遍历因为环陷入死循环， //我们将已经遍历的顶点记录在set中，这样就不会重复遍历了 HashSet&amp;lt;Node&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); stack.add(Node); set.add(node); //如果是其他处理逻辑，就替换打印操作就行了 System.out.println(cur.value); //最后栈的弹出顺序就是深搜路径 while(!stack.isEmpty()){ Node cur = stack.pop(); for (Node next : cur.nexts) { //如果顶点已存在set中，说明已经在深搜路径当中了，我们应该找还没走过的路 if(!set.contains(next)){ //先逮住一个直接邻居，一路走到黑，同时会把当前节点重新压入栈中，因为该入口可以还有其他路需要探索 stack.push(cur); stack.push(next); set.add(next); System.out.println(next.value); //深搜路径继续延申，这是我们来到了新的路口，所以退出上一个路口的循环 break; } } } }}拓扑排序 适用范围：要求有向图，且有入度为0的节点，且没有环（没有循环依赖，假设存在循环依赖，那么可能压根就没有入度为0的节点，这样也就求不出拓扑排序） 适用场景：依赖的编译顺序，即依赖A需要先编译，因为编译依赖B的时候需要依赖A，这时的顺寻就是A -&amp;gt; B算法步骤： 找到入度为0的节点，放入队列 从队列中弹出节点，放到顺序数组中，将这个节点的直接邻居的入度-1，相当于把这个节点和它发散出去的边从图中消除 重复1，2操作，直到队列为空，返回顺序数组code如下：public class GraphGenerator{ public static List&amp;lt;Node&amp;gt; sortedTopology(Graph graph){ //hash表记录每个节点当前的入度，key为节点node，value为入度，value会随着入度为0的节点及其发散边的消除而变化 HashMap&amp;lt;Node, Integer&amp;gt; inMap = new HashMap&amp;lt;&amp;gt;(); //只有入度为0的时候才会放到这个队列 Queue&amp;lt;Node&amp;gt; zeroInQueue = new LinkedList&amp;lt;&amp;gt;(); //1.初始化inMap //2.并且找到第一批的入度为0的节点（注意入度为0的节点可以一次性会有多个） for (Node node : graph.nodes.values()) { inMap.put(node, node.in); if(node.in == 0){ zeroInQueue.add(node); } } //顺序数组 List&amp;lt;Node&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); while(!zeroInQueue.isEmpty()){ Node cur = zeroInQueue.poll(); result.add(cur); //将入度为0的节点的影响消除，并且找出下一批的入度为0的节点 for (Node node : cur.nexts) { //将邻居节点的入度-1 inMap.put(next, inMap.get(next)-1); if(inMap.get(next) == 0){ zeroInQueue.add(next); } } } return result; }}最小生成树请思考一个问题：假设要在n个城市之间建立通信联络网，则联通n个城市只需要n-1条线路，那么如何在最省经费的前提下建立这个通信网？因为n个城市之间，最多可能设置n(n-1)/2条线路，那么如何在这些可能的线路中选择n-1条，使得总的耗费最少呢？下面将介绍两种解决【构造连通网的最小代价生成树】问题的方法： Prim算法 Kruskal算法Kruskal基本思路：首先假设对于非连通图T = (V, {}),此时只有顶点集，没有边，现在依次将代价最小的边加入，如果加入的边在在图中会形成环，那么这条边就不加了，遍历所有的边执行上述相同的操作，最后生成的图就是最小生成树如果判断是否会形成环首先假设对于非连通图T = (V, {})，每个顶点自成一个连通分量，若代价最小的边的依附的顶点分别在不同的连通分量中，就加入T中，否则不加入，加入之后，该连通分量就是这两个顶点的集合总结步骤如下： 最初每个顶点自成一个连通分量（初始化工作） 准备一个依照边的权值从小到大的排序集合（例如小根堆，每次弹出的就是最小代价的边） 依次加入代价最小的边，如果边E依附的顶点A和B在不同的连通分量就加入到T中，并且将两个连通分量合并成一个，即将{A}与{B}合并成{A,B}，那么原来的连通分量{A}，{B}就不存在了（合并操作） 重复上诉操作，直到遍历了所有的边（循环遍历操作）补充：1.连通图：任意两个节点之间都有一条联通的路径，则是连通图，否则叫做非连通图2.连通分量：即极大连通子图，如下图【连通分量】在该图片中，图G由三个部分组成，{0,1,2,3,4,5,6}，{7,8}，{9,10,11,12}，而这三个部分就是图G的三个连通分量code如下：public class Kruskal{ //每个顶点对应的连通分量 private HashMap&amp;lt;Node, List&amp;lt;Node&amp;gt;&amp;gt; setMap; private Kruskal(){ setMap = new HashMap&amp;lt;&amp;gt;() } /** * 初始化连通分量，起初每个顶点自成一个连通分量 */ public void makeSets(List&amp;lt;Node&amp;gt; nodes){ for (Node cur : nodes) { List&amp;lt;Node&amp;gt; set = new ArrayList&amp;lt;Node&amp;gt;(); set.add(cur); setMap.put(cur, set); } } /** * 判断边两个顶点是否在同一个连通分量中 */ public boolean isSameSet(Node from, Node to){ List&amp;lt;Node&amp;gt; fromSet = setMap.get(from); List&amp;lt;Node&amp;gt; toSet = setMap.get(to); //两个集合不是同一个集合，即同一个连通分量 return fromSet == toSet; } /** * 将边的两个顶点所属的不同的连通分量合并在一起 */ public void union(Node from, Node to){ List&amp;lt;Node&amp;gt; fromSet = setMap.get(from); List&amp;lt;Node&amp;gt; toSet = setMap.get(to); //将其中一个连通分量的顶点合并到另一个连通分量中，并更新setMap for (Node toNode : toSet) { fromSet.add(toNode); setMap.put(toNode, fromSet); } } public static Set&amp;lt;Edge&amp;gt; kruskalMST(Graph graph){ Kruskal kruskal = new Kruskal(); //初始化连通分量 kruskal.makeSets(graph.nodes.values()); PriorityQueue&amp;lt;Edge&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Edge&amp;gt;(){ public int compare(Edge o1, Edge o2) { return o1.weight - o2.weight; } }); //准备好最小代价的边的排序集合 for (Edge edge : graph.edges) { pq.add(edge); } Set&amp;lt;Edge&amp;gt; result = new HashSet&amp;lt;&amp;gt;(); while(!pq.isEmpty()){//遍历每条边 Edge edge = pq.poll(); if(!kruskal.isSameSet(edge.from, edge.to)){ result.add(edge); kruskal.union(edge.from, edge.to); } } return result; }}Prim基本思路：首先对于图N = (V, {E})，任意选择一个顶点作为起始连通分量U，我们从U = {u0}(u0 ε V),TE = {}开始，其中TE是最小生成树边的集合，重复进行下面的操作：在所有的u ε U，v ε V-U 的边(u, v) ε E中找到一条代价最小的边(u0,v0)添加到TE中，并将v0并入到连通分量U中，直到U = V为止，此时T = (U, {TE})就是MST。Prim算法和Kruskal算法的关系其实Prim的思路和kruskal的思路是一样的，都是在不同的连通分量通过最小代价的边进行融合，最后形成MST，在kruskal中是不同的连通分量随机融合，而Prim算法中，融合的连通分量一方是固定的，即U，另一方就是V-U，V-U是剩余顶点（也就是连通分量的集合）Code如下：public class Prim{ public static Set&amp;lt;Edge&amp;gt; primMST(Graph graph){ PriorityQueue&amp;lt;Edge&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Edge&amp;gt;(){ public int compare(Edge o1, Edge o2) { return o1.weight - o2.weight; } }); //初始连通分量 HashSet&amp;lt;Node&amp;gt; uSet = new HashSet&amp;lt;&amp;gt;(); //MST的边的集合 Set&amp;lt;Edge&amp;gt; teSet = new HashSet&amp;lt;&amp;gt;(); for (Node node : graph.nodes.values()) {//这个遍历保证V中的所有顶底最终都会合并到uSet中 if(!uSet.contains(node)){//第一个随机的初始点形成最初的连通分量 uSet.add(node); for (Edge edge : node.edges) {//把所有的边存入pq，注意这里会有重复的边，也就是边的两个顶点都在uSet中的，但是不慌后面的if条件会筛掉 pq.add(edge); } while(!pq.isEmpty()){ Edge edge = pq.poll(); //弹出连通分量的所有顶点发散的边中的最小边 Node toNode = edge.to; if(!uSet.contains(toNode)){//筛掉重复的边（边的两个顶点都在uSet中） set.add(toNode); //合并V-U中的顶点 teSet.add(edges); //将最小代价边添加到MST的边集合中 for (Edge nextEdge : toNode.edges) { pq.add(nextEdge); } } } } } }}从代码量来看Prim算法完胜，但相对kruskal要更加难理解写总结Kruskal和Prim算法针对的都是无向图的最小生成树（MST）算法单源最短路径这个算法就是求某个源点到其他各顶点的最小距离，因此这种算法必须决定一个源点，下面介绍解决该问题的算法： Dijkstra算法Dijkstra基本思路： 选一个源点A，初始化源点到其他顶点的距离（包括源点自己）序列，此时到其他源点的距离为正无穷，到源点自己的距离是0 从最短距离序列中，找出到源点距离最小的顶点B，用该顶点去更新其他顶点到源点的距离（包括他自己），即假设更新的顶点是C，原本A -&amp;gt; C，距离是10，而A -&amp;gt; B距离是2，B -&amp;gt; C距离是5，所以A -&amp;gt; B -&amp;gt; C距离是7，比原本距离短，就更新，否则不更新。选到的点后面就不再选了，比如B这一轮更新完后，下一轮就不再选它 重复2的操作，直到所有顶点都被选过注意：Dijkstra 没有负数的边，所以它是不支持负值的，并且不能存在环（从后面的代码中看：在计算最小距离的时候负值和环都是不允许存在的，否在会导致程序错误）code如下：public class Dijkstra{ /** * head就是选择的源点 */ public static HashMap&amp;lt;Node, Integer&amp;gt; dijkstra(Node head){ HashMap&amp;lt;Node, Integer&amp;gt; distanceMap = new HashMap&amp;lt;&amp;gt;(); //代表node到head的距离n，value就是n //初始时，只有head到自己的距离，并且value=0，其他未添加的表示距离为正无穷 distanceMap.put(head, 0) //存放已经选过的顶点 HashSet&amp;lt;Node&amp;gt; selectedNodes = new HashSet&amp;lt;&amp;gt;(); //获取距离到head最小的顶点，并用它更新其他顶点到head的距离 Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes); //当所有顶点都被选过后，停止循环 while(minNode != null){ int distance = distanceMap.get(minNode); for (Edge edge : minNode.edges) { Node toNode = edge.to; //如果顶点到head的初始距离为正无穷，则直接更新 if(!distanceMap.containsKey(toNode)){ distanceMap.put(toNode, distance + edge.weight); } //否则将原来的距离与更新后的距离比较，留下最小的 distanceMap.put(toNode, Math.min(distanceMap.get(toNode), distance + edge.weight)); } //一轮更新完成，将minNode打入到selectedNodes selectedNodes.add(minNode); minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes); } return distanceMap; } public static Node getMinDistanceAndUnselectedNode(HashMap&amp;lt;Node, Integer&amp;gt; distanceMap, HashSet&amp;lt;Node&amp;gt; touchedNodes){ Node minNode = null; int minDistance = Integer.MAX_VALUE; //遍历所有顶点，找出没有选过并且距离最小的顶点 for (Entry&amp;lt;Node, Integer&amp;gt; entry : distanceMap.entrySet()) { Node node = entry.getKey(); int distance = entry.getValue(); if(!touchedNodes.contains(node) &amp;amp;&amp;amp; distance &amp;lt; minDistance){ minNode = node; minDistance = distance; } } return minNode; }}Dijkstra的堆加速算法思路：未优化时从 distanceMap 中选取一个最小并且没有被用过的 Node 是采用 for 循环遍历的方式，而为了加速算法我们可以通过小根堆优化这个步骤： 起初将所有数据放入小根堆，每次弹出一个值，用于更新其他 Node 到 head 的距离 在堆中更新值，有需要保持小根堆的结构系统自带的实现是做不到的，因此我们需要手写堆，并对这种更新操作进行实现code 如下：public class Solution{ /** * 从 head 出发，所有 head 能到达的节点，生成到达每个节点的最小路径记录并返回 * size：总共的节点数 * 返回值：每个 Node 到 head 的最短距离 */ public static HashMap&amp;lt;Node, Integer&amp;gt; dijkstra2(Node head, int size){ NodeHeap nodeHeap = new NodeHeap(size); /** * addOrUpdateOrIgnore 方法 * add --&amp;gt; 每添加一条新的记录 * update --&amp;gt; 记录已存在，并且 Node 到 head 的距离更短，就更新 * ignore --&amp;gt; 记录已存在，但更新的距离要大，就忽略 */ nodeHeap.addOrUpdateOrIgnore(head, 0); HashMap&amp;lt;Node, Integer&amp;gt; result = new HashMap&amp;lt;&amp;gt;(); while(!nodeHeap.isEmpty()){ //每弹出一个 Node，更新它的直接节点 NodeRecord record = nodeHeap.pop(); Node cur = record.node; int distance = record.distance; for(Edge edge : cur.edges){ /** * edge.to：直接节点 * edge.weight：到直接节点的距离 * distance：cur 到 head 的距离 */ nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance); } result.put(cur, distance); } return result; } public static class NodeRecord{ public Node node; public int distance; public NodeRecord(Node node, int distance){ this.node = node; this.distance = distance; } } public static class NodeHeap{ private Node[] nodes; //所有的节点放在 nodes 数组当中 private HashMap&amp;lt;Node, Integer&amp;gt; heapIndexMap; //堆中的 node 在数组中的 index，当 index == -1，表示 node 已经被选择过了 private HashMap&amp;lt;Node, Integer&amp;gt; distanceMap; private int size; public NodeHeap(int size){ nodes = new Node[size]; heapIndexMap = new HashMap&amp;lt;&amp;gt;(); distanceMap = new HashMap&amp;lt;&amp;gt;(); size = 0; } public boolean isEmpty(){ return size == 0; } public void addOrUpdateOrIgnore(Node node, int distance){ if(inHeap(node)){ distanceMap.put(node, Math.min(distanceMap.get(node), distance)); insertHeapify(node, heapIndexMap.get(node)); } //从没进入过堆的，增加记录 if(!isEntered(node)){ nodes[size] = node; heapIndexMap.put(node, size); distanceMap.put(node, distance); insertHeapify(node, size++); } } public NodeRecord pop(){ NodeRecord nodeRecord = new NodeRecord(node[0], distanceMap.get(nodes[0])); swap(0, size - 1); heapIndexMap.put(nodes[size - 1], -1); distanceMap.remove(nodes[size - 1]); nodes[size - 1] = null; heapify(0, --size); return nodeRecord; } //有问题 private void insertHeapify(Node node, int index){ while(distanceMap.get(nodes[index]) &amp;lt; distanceMap.get(nodes[(index - 1) / 2])){ swap(index, (index - 1) / 2); index = (index - 1) / 2; } } //有问题 private void heapify(int index, int size){ int left = index * 2 + 1; while(left &amp;lt; size){ int smallest = left + 1 &amp;lt; size &amp;amp;&amp;amp; distanceMap.get(nodes[left + 1]) &amp;lt; distance ? left + 1 : left; smallest = distanceMap.get(nodes[smallest]) &amp;lt; distanceMap.get(nodes[index]); if(smallest == index){ break; } swap(smallest, index); index = smallest; left = index * 2 + 1; } } private boolean isEntered(Node node){ return heapIndexMap.containsKey(node); } private boolean inHeap(Node node){ return isEntered(node) &amp;amp;&amp;amp; heapIndexMap.get(node) != -1; } private void swap(int index1, int index2){ heapIndexMap.put(nodes[index1], index2); heapIndexMap.put(nodes[index2], index1); Node tmp = nodes[index1]; nodes[index1] = nodes[index2]; nodes[index2] = tmp; } }}" }, { "title": "SQL专项练习", "url": "/posts/SQL%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/", "categories": "数据库, MySQL", "tags": "", "date": "2022-09-09 00:00:00 +0800", "snippet": "LeetCode-SQL入门专题595. 大的国家考点：简单的where条件筛选select name, population, area from World where area &amp;gt;= 3000000 or population &amp;gt;= 25000000;1757. 可回收且低脂的产品考点：where的特殊语法：where (low_fats, recyclable) = (&#39;Y&#39;, &#39;Y&#39;)select product_id from Products where (low_fats, recyclable) = (&#39;Y&#39;, &#39;Y&#39;);584. 寻找用户推荐人考点：where条件逻辑表达式，is与null的搭配使用select name from customer where referee_id &amp;lt;&amp;gt; 2 or referee_id is null;183. 从不订购的客户考点：子查询，左外链接；左外链接右表无数据会直接为null（不管什么类型，都是显示为null）select `Name` as `Customers` from Customers c where c.Id not in (select distinct CustomerId from Orders);select Name Customers From Customers left join Orders on Customers.id = Orders.CustomerId where Orders.id is null;1873. 计算特殊奖金考点：流程函数：if(boolean, value1, value2)，case where exp then value1 else default value end, case exp where value1 then result1 else default result end在select语句中的使用select employee_id , if((name like &#39;M%&#39;) or (employee_id % 2 = 0), 0, salary) bonus from Employees order by employee_id;select employee_id, (case when name like &#39;M%&#39; then 0 when employee_id%2=0 then 0 else salary end) bonus from Employees order by employee_id;select employee_id, (case (name like &#39;M%&#39;) or (employee_id % 2 = 0) when true then 0 else salary end) bonus from Employees order by employee_id;627. 变更性别考点：流程函数：if(boolean, value1, value2)，case where exp then value1 else default value end, case exp where value1 then result1 else default result end在update语句中的使用update Salary set sex = if(sex=&#39;m&#39;, &#39;f&#39;, &#39;m&#39;);update Salary set sex = (case sex when &#39;m&#39; then &#39;f&#39; when &#39;f&#39; then &#39;m&#39; else null end);196. 删除重复的电子邮箱考点：1.在from后使用了别名时，delete语句后面必须跟上要删除的表的别名，否则报错，可参考 Delete争取使用别名的方式；2.from后面的派生表必须有别名-- 解法1DELETE p1 FROM Person p1, Person p2WHERE p1.Email = p2.Email AND p1.Id &amp;gt; p2.Id-- 解法2delete from Person where id not in( select t.id from ( select min(id) as id from Person group by Email ) t)" }, { "title": "Scanner用法", "url": "/posts/Scanner%E7%94%A8%E6%B3%95/", "categories": "编程语言, Java", "tags": "", "date": "2022-09-06 00:00:00 +0800", "snippet": "1、输入整数、字符串数组第一行输入n, m第二行输入n个整数第三行输入m个字符串//导入包import java.util.Scanner;import java.util.Arrays;public class MyScanner { public static void main(String[] args) { //创建对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;输入数据:&quot;); //多行输入 int n = sc.nextInt(); int m = sc.nextInt(); int[] arr = new int[n]; String[] str = new String[m]; //int等基本数据类型的数组,用nextInt()，同行或不同都可以 for(int i=0; i&amp;lt;n; i++) { arr[i] = sc.nextInt(); } //String字符串数组, 读取用next()，以空格划分 for(int i=0; i&amp;lt;m; i++) { str[i] = sc.next(); } //调用方法进行操作 TestSc(n, m, arr); TestStr(str); System.out.println(&quot;Test01 End&quot;); //关闭 sc.close(); } public static void TestSc(int n, int m, int[] arr) { System.out.println(&quot;数据n：&quot; + n + &quot;, 数据m：&quot; + m); System.out.println(Arrays.toString(arr)); } public static void TestStr(String[] str) { System.out.println(Arrays.toString(str)); } }若输入的字符串中想要包含空格，使用scanner.nextLine()换行后用scanner.nextLine()进行读入，见情形7.2、输入二维数组第一行输入n, m第二行开始输入二维数组。import java.util.Arrays;import java.util.Scanner;public class MyScanner2 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(&quot;输入数据:&quot;); //二维数组 int n = sc.nextInt(); int m = sc.nextInt(); int[][] arr2 = new int[n][m]; System.out.println(&quot;Test02 输入二维数组数据：&quot;); //可以直接读入 for(int i=0; i&amp;lt;n; i++) { for(int j=0; j&amp;lt;m; j++) { arr2[i][j] = sc.nextInt(); } } TestSc(n, m, arr2); //关闭 sc.close(); } public static void TestSc(int n, int m, int[][] arr) { System.out.println(&quot;数据n：&quot; + n + &quot;, 数据m：&quot; + m); for(int i=0; i&amp;lt;n; i++) { System.out.println(Arrays.toString(arr[i])); } System.out.println(&quot;数组行数： arr.length= &quot;+ arr.length); System.out.println(&quot;数组列数： arr[0].length= &quot;+ arr[0].length); } }3、输入字符串输入字符串，用空格隔开。next()和nextLine()区别。import java.util.Scanner;/* *next()读取到空白停止，在读取输入后将光标放在同一行中。 *nextLine()读取到回车停止 ，在读取输入后将光标放在下一行。 */public class MyScanner3 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(&quot;输入字符串:&quot;); //next():只读取输入直到空格。 String str = sc.next(); //nextLine():读取输入，包括单词之间的空格和除回车以外的所有符号 String str2 = sc.nextLine(); System.out.println(&quot;str：&quot; + str); System.out.println(&quot;str2：&quot; + str2); //关闭 sc.close(); } }4、输入字符串分割为数组先用scanner.nextLine()读入字符串，再将字符串分割为字符数组或字符串数组。import java.util.*;public class MyScanner4 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(&quot;输入字符串数组：&quot;); String str; str = sc.nextLine(); char[] ch = new char[str.length()]; for(int i=0; i&amp;lt;str.length(); i++) { //用charAt();进行定位分隔 ch[i] = str.charAt(i); System.out.println(ch[i] + &quot; &quot;); } System.out.println(&quot;END&quot;); //读入字符串后,用空格分隔为数组 String[] strs = str.split(&quot; &quot;); System.out.println(Arrays.toString(strs)); }}5、连续输入数字和字符串区别于情形1，对于不能采用for循环的方式获取String。采用情形5,6用来处理。采用while(scanner.hasNext()) 循环，实现连续输入。格式：数字，空格，字符串。或： 数字，回车，字符串import java.util.Scanner;public class MyScanner5 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()) { int n = sc.nextInt(); String str = sc.next(); Tes(n, str); } sc.close(); } public static void Tes(int n, String str) { System.out.println(&quot;n = &quot; + n); System.out.println(&quot;str = &quot; + str); System.out.println(&quot;str.length = &quot; + str.length()); } }6、换行输入数字和字符串也采用scanner.nextLine()，将光标移到下一行。再继续读入字符串。第一行输入整数n，m，第二行开始输入字符串。或第一行输入整数n，第二行输入m，第三行开始输入字符串。import java.util.*;public class MyScanner6 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); //注意！！！光标换到下一行 sc.nextLine(); String s = sc.nextLine(); String str = sc.nextLine(); System.out.println(&quot;n = &quot; + n + &quot; , m = &quot; + m); System.out.println(&quot;s = &quot; + s); System.out.println(&quot;str = &quot; + str); sc.close(); }}7、换行输入数字和字符串(需要包含空格)采用scanner.nextLine()，将光标移到下一行。再继续读入字符串。第一行输入n，第二行开始输入n行字符串，字符串中包含空格。import java.util.Scanner;public class MyScanner7 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String[] strs = new String[n]; sc.nextLine(); for(int i=0; i&amp;lt;n; i++) { String str = sc.nextLine(); strs[i] = str; } Tes2(strs); System.out.println(&quot;End&quot;); sc.close(); } public static void Tes2(String[] strs) { for(int i=0; i&amp;lt;strs.length; i++) { String str = strs[i]; System.out.println(str); } }}" }, { "title": "Elasticsearch", "url": "/posts/%E8%AE%A4%E8%AF%86Elasticsearch/", "categories": "Elasticsearch", "tags": "", "date": "2022-09-03 00:00:00 +0800", "snippet": "Elasticsearch的流行程度什么是Elasticsearch 一个分布式的实时文档存储，每个字段 可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据Elasticsearch的功能和应用场景功能： 全文搜索 结构化搜索 分析应用场景： 网站搜索、垂直搜索、代码搜索； 日志管理与分析、安全指标监控、应用性能监控、Web抓取舆情分析；Elasticsearch与关系型数据库对比" }, { "title": "在Linux系统上安装Oracle JDK8", "url": "/posts/%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85Oracle-JDK8/", "categories": "Linux", "tags": "", "date": "2022-09-03 00:00:00 +0800", "snippet": "Linux版本uname -a，查看Linux版本如下：Linux VM-12-14-centos 3.10.0-1160.71.1.el7.x86_64 #1 SMP Tue Jun 28 15:37:28 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux官网下载JDK8JDK8下载链接可以下载的版本：版本x86和x64x86对应32的机器，x64对应64为的机器，我的机器是64位的，现在一般的机器应该都是64位的使用Xftp7发送文件使用Xftp7将之前下载到Windows系统上的JDK压缩包，发送给远程服务器，如下图所示：我在Linux系统上，目录/opt下，创建了一个jdk的目录用于存放jdk压缩包，创建命令：mkdir /opt/jdk使用Xshell远程链接服务器Xshell远程连接服务器后，如下图所示：下面就是在Xshell上的一系列操作： 解压jdk压缩包，命令：tar -zxvf jdk-8u341-linux-x64.tar.gz，-zxvf的z指的就是.tar.gz这种压缩格式 创建/usr/local/java目录，命令：mkdir /usr/local/java 将解压后的jdk文件移动到java目录下，命令：mv jdk1.8.0_341/ /usr/local/java，即将jdk1.8.0_341/目录下的所有文件移动到java目录下 此时在java目录下，进入jdk1.8.0_341/bin目录，通过命令./java -version可以查看jdk版本，但这还不够，我们要设置环境变量，使得命令能在其他目录下执行 配置环境变量的配置文件，命令：vim /etc/profile，键入：insert，开始编辑，编辑内容如下：在末尾添加：export JAVA_HOME=/usr/local/java/jdk1.8.0_341export PATH=$JAVA_HOME/bin:$PATH其中$PATH是指原本已经存在的环境变量，如果不加这个就会覆盖掉其他环境变量配置，造成严重的后果，编辑完毕后的效果如图所示： 编辑完成，键入ESC退出编辑，然后输入:wq，保存配置并推出，当然如果不保存，命令是：:q! 此时输入命令：echo $PATH，我们发现环境变量并没有添加成功，这是因为没有刷新环境变量配置文件，输入命令：source /etc/profile，然后输入命令：echo $PATH，此时环境变量添加成功 编写一个简单的Hello.java文件，测试是否能运行成功 输入命令，cd ~，进入用户主目录，创建目录workspace，命令：mkdir workspace，进入到workspace目录，输入命令：vim Hello.java，开始编写Java代码，如下图所示： 输入命令：javac Hello.java，然后输入命令：java Hello，运行Java程序，你会得到下面的结果：至此jdk8安装完成" }, { "title": "SpringBoot的自动装配原理", "url": "/posts/SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/", "categories": "框架, SpringBoot", "tags": "注解", "date": "2022-09-03 00:00:00 +0800", "snippet": "SpringBoot的自动装配解决了什么问题减少了Spring的xml等繁琐的配置怎么利用自动装配便利通过注解和一些简单的配置，就能直接使用外部依赖的某些功能，或Spring内部的某些功能SpringBoot的自动装配是如何实现的@SpringBootApplication ==&amp;gt; @EnableAutoConfiguration首先自动装配是从注解@EnableAutoConfiguration开始@EnableAutoConfiguration@EnableAutoConfiguration是一个合成注解，它的里面包含两个重要的注解： @AutoConfigurationPackage，用来自动导入我们的项目根目录下，添加了@Configuration、@Component等注解的类到Spring IoC容器的 @Import({AutoConfigurationImportSelector.class})，用来导入在spring-boot-autoconfigure包下，META-INF/spring.factories中指定的自动配置类条件装配，按需配置 每个自动配置类会按照条件进行生效，并且默认绑定配置文件指定的值，这个配置文件就是SpringBoot的全局配置文件application.yml 常见的按条件配置，比如，某个Bean是否存在，如果存在就不生效，或者某个类是否存在，如果不存在就不生效 生效的配置类最终会通过@EnableAutoConfiguration中的Import，将配置类中定义的Bean全部注入到IoC容器中定制化配置两种方式： 用户直接自己在自定义配置类中通过@Bean替换底层的组件 用户通过修过SpringBoot全局配置文件中的值如何实现一个 Starter 新疆工程，artifactId应该符合规范： XXXX-spring-boot-starter 引入SpringBoot Starter基础库 创建XXXXAutoConfiguration自动配置类，用于往容器中注入Bean 在工程的 resources 包下创建META-INF/spring.factories文件，里面的一行为自动配置类全限定名 最后新建其他工程，引入XXXX-spring-boot-starter总结SpringBoot 通过@EnableAutoConfiguration开启自动装配，通过 SpringFactoriesLoader 最终加载META-INF/spring.factories中的自动配置类实现自动装配，自动配置类其实就是通过@Conditional按需加载的配置类" }, { "title": "Import注解", "url": "/posts/Import%E6%B3%A8%E8%A7%A3/", "categories": "框架, SpringBoot", "tags": "注解", "date": "2022-09-03 00:00:00 +0800", "snippet": "@Import的定义@Import的源码package org.springframework.context.annotation;@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import { Class&amp;lt;?&amp;gt;[] value();}注解内部只有一个默认属性，并且类型是Class对象数组类型，实际上@Import就是用来把需要定义为Bean的类导入到IOC容器里面。导入普通类如何导入 @Import应该标记在@SpringBootApplication(启动类)、@Configuration(配置类)、@Component(组件类)对应的类上。 @RestController、@Service、@Repository都属于@Component 在默认属性中指定需要导入的类的class对象示例：@SpringBootApplication@Import(ImportBean.class) // 通过@Import注解把ImportBean添加到IOC容器里面去public class MyBatisApplication { public static void main(String[] args) { SpringApplication.run(MyBatisApplication.class, args); }}引入配置类(@Configuration修饰的类)达到的效果能够使得配置类生效，当然在启动类的根目录或子目录下，@Configuration标注的类会自动生效，使用@Import的场景往往是不在启动类根目录下，比如自定义Starter会经常用到如何使用与导入普通时一样，依然需要满足第一点，在第二点时就导入对应的配置类的class对象示例：@Configuration(proxyBeanMethods = false)@Import({ // import了两个 XXXDataConfiguration.XXXPartOneConfiguration.class, XXXDataConfiguration.XXXPartTwoConfiguration.class})public class XXXDataAutoConfiguration {}public class XXXDataConfiguration { @Configuration(proxyBeanMethods = false) static class XXXPartOneConfiguration { @Bean @ConditionalOnMissingBean public BeanForIoc beanForIoc() { return new BeanForIoc(); } } @Configuration(proxyBeanMethods = false) static class XXXPartTwoConfiguration { /** * 省略了@Bean的使用 */ }}导入ImportSelector的实现类达到的效果可以把ImportSelector接口selectImports()方法返回的Class名称都定义为bean。ImportSelector接口源码public interface ImportSelector { /** * Select and return the names of which class(es) should be imported based on * the {@link AnnotationMetadata} of the importing @{@link Configuration} class. * @return the class names, or an empty array if none */ String[] selectImports(AnnotationMetadata importingClassMetadata); @Nullable default Predicate&amp;lt;String&amp;gt; getExclusionFilter() { return null; }}在实现类中，selectImports()会返回需要导入容器中的类名静态导入示例：/** * XXXConfigurationSelector一定要配合@Import使用 */public class XXXConfigurationImportSelector implements ImportSelector { @Override @NonNull public String[] selectImports(@NonNull AnnotationMetadata importingClassMetadata) { // 把XXX对应的类，定义为Bean return new String[]{XXX.class.getName()}; }}/** * 注意 @Import(XXXConfigurationImportSelector.class) */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(XXXConfigurationImportSelector.class)public @interface EnableXXX {}@SpringBootApplication@EnableXXX // 使之生效public class MyBatisApplication { public static void main(String[] args) { SpringApplication.run(MyBatisApplication.class, args); }}" }, { "title": "wait、notify、notifyAll方法的使用注意事项", "url": "/posts/wait-notify-notifyAll%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/", "categories": "多线程", "tags": "", "date": "2022-09-01 00:00:00 +0800", "snippet": "为什么wait方法必须在 synchronized 保护的同步代码中使用？wait方法的使用原则线程在调用wait方法之前，必须先持有对象的monitor锁，也就是synchronized锁wait为什么要这样设计为了验证这个问题，我们从反面来看，假设现在有一个阻塞队列：class BlockingQueue { Queue&amp;lt;String&amp;gt; buffer = new LinkedList&amp;lt;String&amp;gt;(); public void give(String data) { buffer.add(data); notify(); // Since someone may be waiting in take } public String take() throws InterruptedException { while (buffer.isEmpty()) { wait(); } return buffer.remove(); }}从代码看： 方法give()是生产者，每次往队列中添加一个元素，就去唤醒正在等待的线程 方法take()是消费者，它会进行循环判断，如果队列为空，就进入等待状态，否则从队列中取出一个元素由于消费者代码块没有被synchronized修饰，所以就容易出现下面的情况： 消费者判断循环，true，进入循环，此时因为cpu调度，生产者方法开始执行，而wait()方法没来的及执行 由于生产者已经执行，那么队列不为空，当cpu占用权回到消费者时，while条件已经失效，此时生产者会进行无效的等待 而如果没有其他生产者运行，消费者就不会得到唤醒的通知，那么就会无限期的等待总结消费者while语句块，判断和执行不是一个原子操作，所以整个程序就很容易出错加了synchronized之后public void give(String data) { synchronized (this) { buffer.add(data); notify(); }}public String take() throws InterruptedException { synchronized (this) { while (buffer.isEmpty()) { wait(); } return buffer.remove(); }}我们知道先要进入synchronized修饰的语句块必须首先获得对象的monitor锁，那么当消费者进入到synchronized语句块后，就已经持有了monitor锁，那么在消费者释放monitor锁之前，生产者一定不会执行另外由于wait会释放monitor锁，这也要求我们必须首先进入到 synchronized 内持有这把锁。为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？ wait方法调用时会释放monitor锁，notify、notifyAll在调用前必须持有monitor锁，它们都是与monitor锁相关的，而monitor锁是对象级别的，而非线程级别的，所以把wait/notify/notifyAll 定义在 Object 类是最合适的，因为 Object 类是所有对象的父类。 如果把 wait/notify/notifyAll 方法定义在 Thread 类中，会带来很大的局限性，假设此时wait在Thread中，那么线程如何明确释放哪把锁，而线程又该如何持有多把锁。 既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。wait/notify 和 sleep 方法的异同？主要对比 wait 和 sleep 方法相同点： 都可以让线程阻塞 都可以响应interrupt中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。不同点： wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。 在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁。 leep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。 wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。" }, { "title": "线程是如何在6种状态之间转换的", "url": "/posts/%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A86%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84/", "categories": "多线程", "tags": "", "date": "2022-09-01 00:00:00 +0800", "snippet": "线程的6种状态 New（新建） Runnable（可运行） Blocked（阻塞） Waiting（等待） Timed Waiting（计时等待） Terminated（终止）查看当前线程的状态：Thread.currentThread().getState()New（新建）New表示线程新创建但还未启动的状态，即：通过new Thread()创建，但还未调用start()方法。一旦调用start()，就从New态转换为Runnable态Runnable（可运行）Java的Runnable状态对应操作系统线程状态的两种状态，分别是：Running和Ready，即Runnable状态的线程可能正在运行，也可能正在等待被分配CPU资源因此当执行线程A的CPU被调度去执行其他任务，线程A依然是Runnable状态，因为CPU随时有可能被调度回来继续执行任务阻塞状态Java中阻塞状态通常不仅仅是 Blocked，实际上它包括三种状态，分别是 Blocked(被阻塞）、Waiting(等待）、Timed Waiting(计时等待），这三 种状态统称为阻塞状态Blocked（阻塞）什么时候进入Blocked状态从Runnable进入Blocked状态，就是在线程A进入synchronized代码块或synchronized方法的时候没有抢到monitor锁，如果线程B释放锁，并且线程A抢到monitor锁，就会从Blocked状态回到Runnable状态Waiting（等待）什么时候进入Waiting状态从Runnable进入Waiting状态，由三种可能： 没有设置 Timeout 参数的 Object.wait() 方法。 没有设置 Timeout 参数的 Thread.join() 方法。 LockSupport.park() 方法。第三种可能解释Blocked状态仅仅针对synchronized monitor锁，但是在Java种还有很多其他锁，比如ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。Blocked于Waiting的区别Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。Timed Waiting（计时等待）Waiting（等待）和Timed Waiting（计时等待）两种状态非常相似，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。 设置了时间参数的 Thread.sleep(long millis) 方法； 设置了时间参数的 Object.wait(long timeout) 方法； 设置了时间参数的 Thread.join(long millis) 方法； 设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。如何从阻塞状态（Block、Waiting、Timed Waiting）转换成其他状态Blocked（阻塞）转换成RunnableBlocked的线程如果获得了monitor锁，就会 ==&amp;gt; Runnable（可运行）Waiting（等待）如何转换成其他状态Waiting比较特殊，因为它是不限时等待，所以它不会自己主动恢复到Runnable状态，因此需要被通知，或者其他线程中断/结束比如：当执行了LockSupport.unpark(线程A)，或者线程A.join()的线程运行结束/中断时才可以进入Runnable状态Timed Waiting（计时等待）如何转换成其他状态如果超时时间到了，且能够直接获取到锁（比如ReentrantLock）或者join的线程运行结束/被中断/调用了LockSupport.unpark(线程t)，就会直接恢复成Runnable状态如果其他线程调用notify()或notifyAll()来唤醒线程A会发生什么首先唤醒线程A的线程B必须持有monitor锁，所以处于Waiting状态的线程被唤醒时拿不到monitor锁，所以会进入Blocked状态，只有线程B执行完毕并且释放monitor锁，才可能轮到线程A去抢夺monitor锁，如果抢到就会转换到Runnable状态，对于 Timed Waiting（计时等待）也是一样的Terminated（终止）如何进入 Terminated（终止）状态 run() 方法执行完毕，线程正常退出。 出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。线程应该注意的点如上图所示： 线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。 线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。" }, { "title": "EasyExcel的使用", "url": "/posts/EasyExcel%E7%9A%84%E4%BD%BF%E7%94%A8/", "categories": "Office办公软件, Excel", "tags": "", "date": "2022-08-30 00:00:00 +0800", "snippet": "EasyExcel简介对于apache提供的Apache poi，它非常容易造成内存泄露，因为是一次性将Excel文件都读到内存，而EasyExcel是按照一个Sheet的一行一行读取到内存当中，这样便于后期处理，就能避免内存泄露使用EasyExcel导入.xls或.xlsx文件普通导入并输出第一种：稍微复杂的写法，不过很标准public class ReadComplex { public static void main(String[] args) { ExcelReaderBuilder builder = EasyExcel.read(); //读取的文件绝对路径 builder.file(&quot;C:\\\\Users\\\\wangwei\\\\Documents\\\\excel\\\\demo.xlsx&quot;); //读取的表格 builder.sheet(&quot;模板&quot;); builder.autoCloseStream(true); //读取的文件类型 builder.excelType(ExcelTypeEnum.XLSX); //注册读取监听器 builder.registerReadListener(new AnalysisEventListener() { @Override public void invoke(Object o, AnalysisContext analysisContext) { //监听者模式，每读完一行就会调用的方法 System.out.println(o); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { //所有数据读完后调用 System.out.println(&quot;====读取完成====&quot;); } }); //获取读取器 ExcelReader build = builder.build(); build.readAll(); //完成所有的读取，并且关闭流 build.finish(); }}第二种是简便的写法：public class ReadExcel { public static void main(String[] args) { EasyExcel.read(&quot;C:\\\\Users\\\\wangwei\\\\Documents\\\\excel\\\\demo.xlsx&quot;) //如果不指定sheetName，默认读取所有的表格 .sheet(&quot;模板&quot;) .registerReadListener(new AnalysisEventListener() { @Override public void invoke(Object o, AnalysisContext analysisContext) { System.out.println(o.toString()); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { System.out.println(&quot;====读取完成====&quot;); } }) .doRead(); }}这种方法采用链式编程的方式，并且只设置关键的参数：sheet名、文件名和监听器，最后调用doRead方法就可以读取数据了使用JavaBean接收Excel表格每行的数据首先说明，通过debug，我们得知在监听器内部的invoke()的参数O，实际读取时的类型是LinkedHashMap，并且key为Integer，value为String但是通常我们会用JavaBean去接收数据，具体步骤如下：1.首先是我们的Excel文件数据2.然后是JavaBean类@Datapublic class ExcelData { @ExcelProperty(&quot;排名&quot;) private Integer rank; @ExcelProperty(&quot;选项ID&quot;) private String itemId; @ExcelProperty(&quot;标题&quot;) private String title; @ExcelProperty(&quot;编号&quot;) private Long code; @ExcelProperty(&quot;描述&quot;) private String desc; @ExcelProperty(&quot;得票数&quot;) private Integer voteCount; @ExcelProperty(&quot;活动ID&quot;) private String activityId; @ExcelProperty(&quot;创建时间&quot;) private Date createTime;}3.第三部，开始读取public class ReadExcelByObj { public static void main(String[] args) { //用来保存接收到的数据 ArrayList&amp;lt;ExcelData&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); EasyExcel.read(&quot;C:\\\\Users\\\\wangwei\\\\Documents\\\\excel\\\\demo.xlsx&quot;) //接收数据的JavaBean类型 .head(ExcelData.class) .sheet(&quot;模板&quot;) .registerReadListener(new AnalysisEventListener&amp;lt;ExcelData&amp;gt;() { @Override public void invoke(ExcelData excelData, AnalysisContext analysisContext) { list.add(excelData); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { System.out.println(&quot;====读取完成====&quot;); } }) .doRead(); for (ExcelData excelData : list) { System.out.println(excelData); } }}也很简单，相比于简便写法，就多出了用head()指定JavaBean的类型使用EasyExcel导出Excel文件写数据也非常简单，这里就演示如何将JavaBean导出到Excel，直接上代码：public class WriteExcel { public static void main(String[] args) { List dataList = getExcelDataList(); EasyExcel.write(&quot;C:\\\\Users\\\\wangwei\\\\Documents\\\\excel\\\\demo_副本.xlsx&quot;) .head(ExcelData.class) .excelType(ExcelTypeEnum.XLSX) .sheet(&quot;list&quot;) .doWrite(dataList); } public static List getExcelDataList(){ ArrayList&amp;lt;ExcelData&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); EasyExcel.read(&quot;C:\\\\Users\\\\wangwei\\\\Documents\\\\excel\\\\demo.xlsx&quot;) //接收数据的JavaBean类型 .head(ExcelData.class) .sheet(&quot;模板&quot;) .registerReadListener(new AnalysisEventListener&amp;lt;ExcelData&amp;gt;() { @Override public void invoke(ExcelData excelData, AnalysisContext analysisContext) { list.add(excelData); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { System.out.println(&quot;====读取完成====&quot;); } }) .doRead(); return list; }}从代码中看出，写出文件也非常简单，同样用head()指定JavaBean的类型，然后是文件类型、文件保存的位置和Sheet名，最后调用doWrite写出就完成了" }, { "title": "如何正确停止线程", "url": "/posts/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B/", "categories": "多线程", "tags": "", "date": "2022-08-27 00:00:00 +0800", "snippet": "通知线程中断Thread.currentThread().interrupt();子线程被阻塞仍然可以感受到中断当子线程内部被sleep()和wait()阻塞的时候，仍然可以感受到中断信号并且抛出java.lang.InterruptedException异常子线程如何正确响应中断对下面的子线程内部方法，如何让子线程正确响应中断：void subTas() { try { Thread.sleep(1000); } catch (InterruptedException e) { // 在这里不处理该异常是非常不好的 }}向上面这样，对阻塞逻辑进行try/catch，不过这样子往往是不够的，通常有两种最佳处理方式正确响应中断 第一种方式：子线程抛出异常，让被调用者主动处理异常，或者层层抛，直到在run()中通过try/catch处理异常 第二种方法：在catch语句块中调用Thread.currentThread().interrupt()再次中断线程，因为如果线程在休眠期间被中断，那么会自动清除中断信号。如果这时手动添加中断信号，中断信号依然可以被捕捉到。这样后续执行的方法依然可以检测到这里发生过中断，可以做出相应的处理，整个线程可以正常退出。如果不采用上述方法，我们通常称之为“屏蔽了中断请求”，如果我们盲目地屏蔽了中断请求，会导致中断信号被完全忽略，最终导致线程无法正确停止。为什么用 volatile 标记位的停止方法是错误的stop()，suspend() 和 resume()，这些方法已经被 Java 直接标记为 @Deprecated。它们不再推荐使用 比如stop()会直接停止线程，没有给线程足够时间来处理想要在停止前保存数据的逻辑，任务戛然而止，会导致出现数据完整性等问题。 对于suspend()和resume()而言，suspend会让线程休眠，但不会释放锁，这样就容易造成死锁问题，因为这把锁在线程被 resume() 之前，是不会被释放的。假设线程A调用suspend()是线程B休眠，而线程B恰好持有一把锁，此时假设线程 A 想访问线程 B 持有的锁，但由于线程 B 并没有释放锁就进入休眠了，所以对于线程 A 而言，此时拿不到锁，也会陷入阻塞，那么线程 A 和线程 B 就都无法继续向下执行。在某些情况下，volatile是可以正常中断线程的，因为volatile标记的变量是线程在主存上共享的，所以当线程A改变volatile修饰的变量，线程B中volatile修饰的变量也会改变，因此它可以作为标记位但是当线程遇上阻塞队列，比如生产者，一旦线程阻塞，即使标记位发生变化，线程也没办法去判断了，因为线程已经阻塞了补充 中断是干什么的？中断是为了结束某个线程而发出的信号，中断能够唤醒sleep、wait阻塞下的线程 为了能够捕获到InterruptedException异常，我们应该对阻塞逻辑进行try/catch" }, { "title": "如何让MySQL支持emoji字符", "url": "/posts/%E5%A6%82%E4%BD%95%E8%AE%A9MySQL%E6%94%AF%E6%8C%81emoji%E5%AD%97%E7%AC%A6/", "categories": "数据库, MySQL", "tags": "", "date": "2022-08-23 00:00:00 +0800", "snippet": " 以Windows系统，MySQL5.7.33版本为例第一种方法：修改数据库配置文件（已经实践有效）在MySQL文件目录下，找到mysql.ini配置文件，将其中的内容替换为下面的内容：[client]default-character-set = utf8mb4[mysql]# 设置mysql客户端默认字符集default-character-set = utf8mb4[mysqld]#设置3306端口port = 3306 # 设置mysql的安装目录basedir=C:\\Users\\wangwei\\Documents\\mysql-5.7.33-winx64# 设置mysql数据库的数据的存放目录datadir=C:\\Users\\wangwei\\Documents\\mysql-5.7.33-winx64\\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server = utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODBcharacter-set-client-handshake = FALSEcollation-server = utf8mb4_unicode_ciinit_connect=&#39;SET NAMES utf8mb4&#39;这个配置文件的修改会让MySQL服务端、客户端默认的字符集编程utf8mb4重新启动MySQL，让配置文件生效重启之前需要修改注册表：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MySQL下的ImagePath修改值为：&quot;C:\\Users\\wangwei\\Documents\\mysql-5.7.33-winx64\\bin\\mysqld&quot; --defaults-file=&quot;C:\\Users\\wangwei\\Documents\\mysql-5.7.33-winx64\\mysql.ini&quot; MySQL，其中–defaults-file后面的部分是自己添加上去的，目的是为了让MySQL在启动的时候加载配置文件mysql.ini查看MySQL配置变量使用命令：show variables where variable_name like &#39;character_set_%&#39; or variable_name like &#39;collation%&#39;;，结果如下，说明配置文件加载成功修改原来的库、表、字段的字符集做完上面的步骤，以后自己新建的表、字段的默认字符集就是utfmb4了，但如果自己原来的数据库、表、字段不是utfmb4，则需要手动修改：-- 修改数据库的字符集ALTER DATABASE 数据库名 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;-- 修改表的字符集ALTER TABLE 表名 CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;-- 修改表字段的字符集ALTER TABLE 表名 MODIFY 字段名 字段类型 CHARSET utf8mb4 COLLATE utf8mb4_unicode_ci;按理到这步就应该成了，最后就能在数据库中插入emoji字符了提高MySQL-connector-java驱动版本如上图数据库已经可以插入emoji字符了，但是在程序中却依然插入不了，这时候就是你的mysql-connector-java驱动存在版本问题，我最开始的版本是5.1.8，结果程序插入不了emoji字符，换成更加高的版本6.0.6就可以了第二种方法，改字段级别的字符集字符集规则有下面的优先级：字段 &amp;gt; 表 &amp;gt; 数据库，因此按理仅仅修改某个需要插入emoji字符的字段的字符集就可以了" }, { "title": "动态规划", "url": "/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/", "categories": "算法与数据结构", "tags": "", "date": "2022-08-18 00:00:00 +0800", "snippet": "01背包问题需要注意的问题： 对于01背包问题：每一件物品，要么不放要么只放一次 对于dp二维数组，第一维应该是物品数量，第二维才是体积或者重量 对于物品数量，遍历应该从1开始，并且dp【i】【w】 = Math.max(dp【i-1】【w】, dp【i-1】【w-vw【i】【0】】 + vw【i】【1】)，解释：dp【i】【w】，代表背包容量为w时，物品陈列为0~i-1这几个物品时背包所能装的最大重量，vw【i】【0】代表物品i-1的体积，vw【i】【1】代表物品i-1的重量。思路： 首先对dp数组进行初始化，要想得到最终的结果，我们就要知道子问题的结果，例如上面提到的：如果要求得dp【i】【w】的值首先得知道dp【i-1】【w-vw【i】【0】】的值 对于物品i，实际有两种选择，第一种不放（包括背包容量不足以装下i），对于二维数组来说值就是当前列的上一行dp【i-1】【w】，第二种放：如果容量足够，那么就可以放，这时候的值应该是减掉物品i占用的体积所能放的最大重量加上物品i的重量，而最终还要比较在这种情况下，不放和放哪个大，取最大的哪个，之所以要比是因为：如果两个物品i-1和i，它们体积相同，质量不同，而且背包也只能装一个，那么最后就需要比较放i和不放i哪个大了 最后返回父问题的结果就ok了 当然如果理解起来很困难，那就将二维数组画成一个表格，从左到右，从上到下依次填充，不过实际上没必要这样，因为这种问题有点递归的意思在里面，正如对于递归没必要对每个细节都清楚，我们只需要知道递归做的工作是什么，边界值是什么，返回什么就行了，对于01背包也是，我们不用知道子问题最后的值是什么，我们只要知道父问题是子问题的值比较出来的就行了真题链接：NC145 01背包解答：/** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算01背包问题的结果 * @param V int整型 背包的体积 * @param n int整型 物品的个数 * @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi * @return int整型 */public int knapsack (int V, int n, int[][] vw) { // write code here int[][] dp = new int[n+1][V+1]; //i=0的时候代表没有物品，这时候不管背包的容量为多少，实际背包装的最大重量都应该为0 for(int i = 1; i&amp;lt;=n;i++){ //当背包容量为0的时候，不管有多少物品，背包都装不下，所以也是0 for(int j = 1;j&amp;lt;=V;j++){ if(j&amp;lt;vw[i-1][0]){ dp[i][j] = dp[i-1][j]; }else{ dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-vw[i-1][0]]+vw[i-1][1]); } } } return dp[n][V];}" }, { "title": "JVM基础知识", "url": "/posts/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/", "categories": "JVM", "tags": "", "date": "2022-08-18 00:00:00 +0800", "snippet": "概述JVM基础知识包含下面的内容： 常见的编程语言类型 关于跨平台、运行时（Runtime）与虚拟机（VM） 关于内存管理和垃圾回收（GC）编程语言分类 机器语言：机器语言是直接给机器执行的二进制指令，每种 CPU 平台都有对应的机器语言。 汇编语言：相当于是给机器执行的指令，按照人可以理解的助记符表示，这样代码就非常长，但是性能也很好。 高级语言：是为了方便人来理解，进而快速设计和实现程序代码，一般跟机器语言和汇编语言的指令已经完全没有关系了，代码编写完成后通过编译或解释，转换成汇编码或机器码，之后再传递给计算机去执行。高级语言为何高级机器语言和汇编语言都是跟目标机器的 CPU 架构有直接联系，而高级语言一般就没有关系了，高级语言高级就高级在：不管是X86还是其他CPU，通过编译和解释过程之后都变成实际平台的目标代码，因此开发者不用关心目标平台的差异性高级语言分类 按照虚拟机 有虚拟机：Java、Lua、Ruby… 无虚拟机：C、C++、C#、Golang… 按变量是否有确定的类型，还是类型可以随意变化 静态类型：Java、C、C++… 动态类型：所有的脚本类型的语言 按编译执行，还是解释执行 编译执行：C,C++，Golang，Rust，C#，Java，Scala，Clojure，Kotlin，Swift… 解释执行：JavaScript 的部分实现和 NodeJS，Python，Perl，Ruby… 按语言特点 面向过程：C，Basic，Pascal，Fortran… 面向对象：C++，Java，Ruby，Smalltalk… 函数式编程：LISP、Haskell、Erlang、OCaml、Clojure、F#… 注意：Java其实应该叫做半编译半解释语言，Java编译执行的一般步骤：.java文件经过编译器编译成.class文件 –&amp;gt; .class加载到JVM –&amp;gt; 在JVM上通过解释器，解释成机器代码在JVM上运行其实Java还诞生了即时编译（JIT，just in time）的技术，也就是说对于不经常执行的语句，运行到时就解释执行，而对于热点代码就即时编译，这样能大大提高程序运行的性能跨平台为什么要跨平台我们一般希望自己编写的程序，能在源代码级别或编译后能运行在不同的平台上，而不是面对不同的平台，都要编写不同的实现，同样我们希望自己编写的web程序，既能部署在Windows系统，又能部署到Linux平台，甚至时MacOS系统通过跨平台技术，能够极大节省了开发和维护成本现在的跨平台现状一般来说解释型语言都是跨平台的，同一份脚本代码，可以由不同平台上的解释器解释执行，但是对于编译型语言，存在两种级别的跨平台： 源码跨平台和二进制跨平台。 源码跨平台（C++）： 二进制跨平台（Java）：其中C++的模式要求每个平台都有对应的开发工具和编译器，而且在各个平台所依赖的开发库都需要是一致或兼容的，这样才能正常编译源码，本来C++的口号是：“一次编写，到处（不同平台）编译”，但实际情况上是一编译就报错，变成了“一次编写，到处调试，到处找依赖、改配置”。 大家可以想象，你编译一份代码，发现缺了几十个依赖，到处找还找不到，或者找到了又跟本地已有的版本不兼容，这是一件怎样令人绝望的事情。而Java通过虚拟机解决了这个问题：源码只需要编译一次，然后把编译后的 class 文件或 jar 包，部署到不同平台，就可以直接通过安装在这些系统中的 JVM 上面执行，同时依赖问题也出现了Maven中央库用于下载和管理依赖，这样就实现了让同一个应用程序在不同的平台上直接运行的能力。关于运行时（Runtime）与虚拟机（VM）对于Java来说，JRE就是Java的运行时，包括虚拟机和核心依赖，可以说运行时提供了程序运行的基本环境，JVM 在启动时需要加载所有运行时的核心库等资源，然后再加载我们的应用程序字节码，才能让应用程序字节码运行在 JVM 这个容器里。但一些语言是没有虚拟机的，编译打包时就把依赖的核心库和其他特性支持，一起静态打包或动态链接到程序中，比如 Golang 和 Rust，C#…，这样运行时就和程序指令组合在一起，成为了一个完整的应用程序，好处就是不需要虚拟机环境，坏处是编译后的二进制文件没法直接跨平台了。关于内存管理和垃圾回收内存资源总是有限而又宝贵的，只占用不释放，很快就会用完了。而程序得不到可用内存就会崩溃内存管理内存管理就是内存的生命周期管理，包括内存的申请、压缩、回收等操作，Java的内存管理就是GC，JVM的GC模块不仅管理内存的回收，也负责内存的分配和压缩整理。JVM 在我们创建 Java 对象的时候去分配新内存，并使用 GC 算法，根据对象的存活时间，在对象不使用之后，自动执行对象的内存回收操作。对于Golang和Rust这些语言，它们也有垃圾回收机制，但它们没有虚拟机，处理方式是怎么样的呢？诀窍就在于运行时（Runtime），编译打包的时候，可以把内存使用分析的模块一起打包到应用程序中，在运行期间有专门的线程来分析内存使用情况，进而决定什么时候执行 GC，把不再使用的内存回收掉。 这样就算是没有虚拟机，也可以实现 GC。Rust则更进一步：直接在语言规范层面限制了所有变量的生命周期，如果超出了一个明确的范围，就会不可用，这样在编译期就能直接知道每个对象在什么时候应该分配内存，什么时候应该销毁并回收内存，做到了很精确并且很安全的内存管理。" }, { "title": "常用性能指标", "url": "/posts/%E5%B8%B8%E7%94%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/", "categories": "JVM", "tags": "", "date": "2022-08-16 00:00:00 +0800", "snippet": "JVM调优的目的其实“调优”是一个诊断和处理手段，我们最终的目标是让系统的处理能力，也就是“性能”达到最优化如何进行JVM调优大致过程如下： 量化性能相关指标，然后对系统问题进行排查 排查出问题，如：系统延迟和抖动增加，偶尔宕机，这说明JVM配置不合理 针对问题对症下药，如：针对配置不合理的问题，我们需要对JVM配置进行调整，如果问题比较严重是否进行系统重构和调整，同时提出对日常运维的要求和建议 最后经过我们的调优，系统延迟降低，不在抖动，不再宕机量化性能相关指标量化性能指标是一个标准化判断依据的过程，根据量化性能指标我们能够有效指出那些指标与平常不同存在问题要排查问题，那么我们就要直到哪里出了问题，一般我们需要对下面这些方面进行排查： 分析系统性能问题： 比如是不是达到了我们预期性能指标，判断资源层面有没有问题，JVM 层面有没有问题，系统的关键处理流程有没有问题，业务流程是否需要优化； 通过工具收集系统的状态，日志，包括打点做内部的指标收集，监控并得出关键性能指标数据，也包括进行压测，得到一些相关的压测数据和性能内部分析数据； 根据分析结果和性能指标，进行资源配置调整，并持续进行监控和分析，以优化性能，直到满足系统要求，达到系统的最佳性能状态。计算机系统中，性能相关的资源主要分为这几类: CPU：CPU是系统最关键的计算资源，在单位时间内有限，也是比较容易由于业务逻辑处理不合理而出现瓶颈的地方，浪费了CPU资源和过渡消耗CPU资源都不是理想状态，我们需要监控相关指标； 内存：内存则对应程序运行时直接可使用的数据快速暂存空间，也是有限的，使用过程随着时间的不断的申请内存又释放内存，好在 JVM 的 GC 帮我们处理了这些事情，但是如果 GC 配置的不合理，一样会在一定的时间后，产生包括 OOM 宕机之类的各种问题，所以内存指标也需要关注； IO（存储+网络）：CPU在内存中把业务逻辑计算以后，为了长期保存，就必须通过磁盘存储介质持久化，如果多机环境、分布式部署、对外提供网络服务能力，那么很多功能还需要直接使用网络，这两块的 IO 都会比 CPU 和内存速度更慢，所以也是我们关注的重点。性能优化中常见的套路性能优化一般存在瓶颈问题，而瓶颈问题都遵循80/20原则，即把所有的整个处理过程中比较慢的因素都列一个清单，并按照对性能的影响排序，那么前 20% 的瓶颈问题，至少会对性能的影响占到 80% 比重。换句话说，我们优先解决了最重要的几个问题，那么性能就能好一大半。一般我们像排查性能资源是否称为瓶颈问题，看资源够不够，只要成本允许，加配置可能是最快速的解决方案，还可能是最划算，最有效的解决方案。 与 JVM 有关的系统资源，主要是 CPU 和 内存 这两部分。 如果发生资源告警/不足, 就需要评估系统容量，分析原因。衡量性能的维度 延迟，一般指响应用户请求的平均时间，但是响应时间一般抖动的特别厉害（即部分用户的响应时间特别高）这时我们一般需要保证95线或99线，即保证95%或99%以上的用户在可接收的范围内响应，另外在用户请求量巨大的时候，最大响应时间可能变得非常大，所以最大响应时间这个指标一般不可靠，我们一般不用 吞吐量：一般对于交易类的系统我们使用每秒处理的事务数(TPS)来衡量吞吐能力，对于查询搜索类的系统我们也可以使用每秒处理的请求数（QPS）。 系统容量：也叫做设计容量，可以理解为硬件配置，成本约束一般只要系统架构允许，增加硬件配置一般都能提升性能指标，但随着摩尔定律的失效，增加硬件配置并不能得到线性的性能提升，比如增加一倍的内存容量并不能带来一倍的性能提升，所以目前来说，整体上使用分布式的解决办法，以及局部上对每个系统进行分析调优，是性价比最高的选择。同时性能指标还可以分为两类：业务需求指标：如吞吐量(QPS、TPS)、响应时间(RT)、并发数、业务成功率等。资源约束指标：如 CPU、内存、I/O 等资源的消耗情况。一般批处理/流处理系统更关注吞吐量, 延迟可以适当放宽，而高可用 Web 系统，既关注高并发情况下的系统响应时间，也关注吞吐量性能调优的手段我们可采用的手段和方式包括： 使用 JDWP 或开发工具做本地/远程调试 系统和 JVM 的状态监控，收集分析指标 性能分析: CPU 使用情况/内存分配分析 内存分析: Dump 分析/GC 日志分析 调整 JVM 启动参数，GC 策略等等总结性能调优的第一步是制定指标，收集数据，第二步是找瓶颈，然后分析解决瓶颈问题。通过这些手段，找当前的性能极限值。压测调优到不能再优化了的 TPS 和 QPS，就是极限值。知道了极限值，我们就可以按业务发展测算流量和系统压力，以此做容量规划，准备机器资源和预期的扩容计划。最后在系统的日常运行过程中，持续观察，逐步重做和调整以上步骤，长期改善改进系统性能。注意：过早的优化是万恶之源，不能脱离实际应用场景做优化，虽然目前的性能不是很好，但能满足实际生产，那么就没必要做优化，除此之外当系统的性能优化到 3000TPS 如果已经可以在成本可以承受的范围内满足业务发展的需求，那么再花几个人月优化到 3100TPS 就没有什么意义，同样地如果花一倍成本去优化到 5000TPS 也没有意义。因为考虑到实际生产，那么就要综合考虑成本和性能的平衡" }, { "title": "JVM环境", "url": "/posts/JVM%E7%8E%AF%E5%A2%83/", "categories": "JVM", "tags": "", "date": "2022-08-16 00:00:00 +0800", "snippet": "JDK、JRE和JVM的关系 JDK（Java Development kit）即Java开发工具包，包含了JRE、解释器（java）、编译器（javac）、Java归档（jar）、文档生成器（javadoc）等工具，简单来说如果我们要开发Java程序，就需要某个版本的JDK。 JRE（Java Runtime Environment）即Java运行时环境，提供Java应用程序执行所需的环境，包括JVM、核心类、支持文件等，如果只是要在某个机器上执行Java程序，可以下载JDK，也可以只安装JRE，后者体积更小 JVM（Java Virtual Machine）即Java虚拟机，说到它往往有三种含义： JVM规范要求 满足JVM规范要求的一种具体实现 一个JVM运行实例，在命令提示符下编写Java命令以运行Java类时，都会创建一个JVM实例 我们一般说的都是指第三种范围关系范围：JDK &amp;gt; JRE &amp;gt; JVM： JDK = JRE + 开发工具 JRE = JVM + 类库开发运行Java程序时的交互关系 就是通过 JDK 开发的程序，编译以后，可以打包分发给其他装有 JRE 的机器上去运行。 运行的程序，则是通过 Java 命令启动的一个 JVM 实例，代码逻辑的执行都运行在这个 JVM 实例上。Java程序的开发运行过程：JDK开发Java程序并编译成字节码或打包程序 –&amp;gt; JRE启动一个JVM实例，加载、验证、执行Java字节码以及依赖库，运行Java程序 –&amp;gt; JVM将程序和依赖库的 Java 字节码解析并变成本地代码执行，产生结果。" }, { "title": "shiro总结", "url": "/posts/shiro%E6%80%BB%E7%BB%93/", "categories": "框架, shiro", "tags": "", "date": "2022-08-13 00:00:00 +0800", "snippet": "shiro定义shiro提供了认证（登录校验）、授权（用户权限）、加密、会话管理、与Web集成、缓存等功能shiro简介基本功能 Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限； Session Management：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web 支持，可以非常容易的集成到 Web 环境； Caching：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率； Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：提供测试支持； Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。shiro不会去维护用户和权限，这些需要我们自己设计和提供，然后通过相应的接口注入给shiro即可工作流程可以看到：应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject；其每个 API 的含义：Subject：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；Realm：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。也就是说对于我们而言，最简单的一个 Shiro 应用： 应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager； 我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。shiro的架构 Subject：主体，可以看到主体可以是任何可以与应用交互的 “用户”； SecurityManager：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。 Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了； Authorizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能； Realm：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm； SessionManager：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所以呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）； SessionDAO：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 Cryptography：密码模块，Shiro 提供了一些常见的加密组件用于如密码加密 / 解密的。shiro身份验证身份验证简单来说：就是检验请求对象是否该用户，在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能验证用户身份。 principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名 / 密码 / 手机号。 credentials：证明 / 凭证，即只有主体知道的安全值，如密码 / 数字证书等。 最常见的principals和credentials组合就是用户名 /密码了，而principals和credentials的组合通常就是我们的token了。另外两个相关的概念是之前提到的Subject及Realm，分别是主体及验证主体的数据源。验证的一般步骤： 首先初始化和配置SecurityManager，初始化的工作就是初始化Realm，即数据源（比如真实的用户数据） 客户端携带token前来，解析token获取principals和credentials 验证principals和credentials，判断它们在Realm中是否存在（具体操作：Subject.login(token)） 如果不存在验证失败，否则成功（失败会报AuthenticationException或它的子类）验证流程图： 首先调用 Subject.login(token) 进行登录，其会自动委托给 Security Manager，调用之前必须通过 SecurityUtils.setSecurityManager() 设置； SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证； Authenticator 才是真正的身份验证者，Shiro API 中核心的身份认证入口点，此处可以自定义插入自己的实现； Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证； Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证成功了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。Shiro授权授权方式： 编程式：通过写 if/else 授权代码块完成Subject subject = SecurityUtils.getSubject();if(subject.hasRole(“admin”)) { //有权限} else { //无权限} 注解式：通过在执行的 Java 方法上放置相应的注解完成@RequiresRoles(&quot;admin&quot;)public void hello() { //有权限}授权流程流程如下： 首先调用 Subject.isPermitted/hasRole接口，其会委托给 SecurityManager，而 SecurityManager 接着会委托给 Authorizer； Authorizer 是真正的授权者，如果我们调用如 isPermitted(“user:view”)，其首先会通过 PermissionResolver 把字符串转换成相应的 Permission 实例； 在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限； Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给 ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted/hasRole 会返回 true，否则返回 false 表示授权失败。总的来说三步：1.传入角色/权限（字符串），2.解析角色/权限，3.调用Realm获得相应的角色/权限进行匹配Reamle缓存Shiro 提供了 CachingRealm，其实现了 CacheManagerAware 接口，提供了缓存的一些基础实现；另外 AuthenticatingRealm 及 AuthorizingRealm 分别提供了对 AuthenticationInfo 和 AuthorizationInfo 信息的缓存。Shiro过滤器的执行流程弄懂这个方面shiro的执行机制就非常清楚了，下面将从源码分析：首先在SpringIOC重启时，会初始化所有的Spring Bean，而Shiro的重要的组件ShiroFilterFactoryBean请求过滤器就实现了FactoryBean，实现了这个类的组件会在Spring IOC重启的时候自动初始化，并且是调用ShiroFilterFactoryBean覆盖的getObject()方法进行初始化在getObject()方法中最终会调用createInstance()方法执行初始化，这个方法就是为了创建shiro的请求过滤器实例（SpringShiroFilter），具体做的工作就是：使用我们在ShiroConfig中实例化好的SecurityManager，然后初始化FilterChainManager初始化FilterChainManager的工作具体是：初始化filters和filterChains为LinkedHashMap类型，这种能够保证插入顺序的结构，同时往filters同添加了shiro的默认过滤器，filters的key是过滤器名，value是过滤器实例初始化FilterChainManager完成之后，为过滤器添加全局属性，主要就是为了AuthenticationFilter和AuthorizationFilter添加loginUrl、defaultSuccessUrl、和UnauthorizedUrl完成默认过滤器初始化后，通过ShiroFilterFactoryBean的getFilters()方法获取我们自定义的filter，并且也添加全局属性，然后将我们的自定义过滤器注册到DefaultFilterChainManager的filters中，这下DefaultFilterChainManager的filters里就有了我们自定义的filter和shiro默认的filter了下一步就是遍历filterChainDefinitionMap，这个就是我们在ShiroConfig中配置的路径过滤规则，然后就是根据这个规则创建我们的过滤器执行链filterChains，这个步骤主要执行的是DefaultFilterChainManager的createChain方法，而我们的执行链filterChains的key是过滤路径，value就是为这个路径配置的过滤器的list，因为一个过滤路径可以配置多个过滤器至此FilterChainManager初始化完成，之后在将这个Manager注入到PathMatchingFilterChainResolver中，它是过滤器执行链解析器，它的具体作用就是里面的getChain()方法getChain的具体工作是：我们每次请求服务器都会调用这个方法，根据请求的URL去匹配过滤器执行链中的过滤路径，匹配上了就返回其对应的过滤器进行过滤。下面贴上一段关键代码：for (String pathPattern : filterChainManager.getChainNames()) { // If the path does match, then pass on to the subclass implementation for specific checks: if (pathMatches(pathPattern, requestURI)) { if (log.isTraceEnabled()) { log.trace(&quot;Matched path pattern [&quot; + pathPattern + &quot;] for requestURI [&quot; + requestURI + &quot;]. &quot; + &quot;Utilizing corresponding filter chain...&quot;); } return filterChainManager.proxy(originalChain, pathPattern); }}其中filterChainManager.getChainNames()就是我们定义的过滤路径集合，注意由于filterChains的结构是LinkedHashMap，因此过滤规则添加的顺序是保留的，所以如果我们把/**，配置在最前面，那么后面的过滤路径就永远都匹配不到了，这也是为什么我们要把规则越详细的过滤路径配置在前面到这shiro的请求过滤配置就已经完成了，那么最后这些过滤规则是如何被执行的呢？这个就取决于Tomcat的filter调用规则了，下面就来分析：从前面可知我们的过滤最终开始与getChain()方法，那么这个方法又是怎么调用的呢？既然是HTTP请求那肯定是从Tomcat过来的，当一个请求到达Tomcat时，Tomcat以责任链的形式调用了一系列Filter，OncePerRequestFilter就是众多Filter中的一个。它所实现的doFilter()方法，如果请求未过滤，就会调用自身的抽象方法doFilterInternal()，而这个方法在它的子类AbstractShiroFilter中被实现了。AbstractShiroFilter会调用executeChain方法，在这个方法中就会调用PathMatchingFilterChainResolver的getChain()方法返回过滤器链，然后过滤器被一个个执行，然后调用它们的doFilter()方法现在我们就可以聚焦我们自定义的ShiroFilter，看看它的方法是如何执行的doFilter方法是实现的Filter接口，这个接口被AbstractFilter实现，同时doFilter在OncePerRequestFilter中被实现，最终会调用doFilterInternal方法，而这个方法在AdviceFilter中得到实现在doFilterInternal里先执行preHandle()，如果返回true，执行executeChain()，然后执行postHandle()对于preHandle()，它总是在过滤器链实际执行之前被调用，这个方法默认返回true，并且如果我们得自定义过滤器没有实现这个方法的话，实际上会执行PathMatchingFilter的onPreHandle方法，而这个方法也默认返回true，其实就是等待被子类覆盖而正好在shiro的认证过滤器中，AccessControlFilter就实现了这个方法，在这个方法里会调用isAccessAllowed()，如果返回false，则会调用onAccessDenied()，而这两个方法都是抽象方法，等待子类实现，如果我们的自定义子类没有覆盖，最终会调用subject.isAuthenticated()，也就是说如果这个方法返回true，请求会被放行，否则就被阻塞了其实到这里就差不多分析完了，subject.isAuthenticated()这个方法就是判断我们的当前用户是否通过身份验证，如果未认证会继续执行isLoginRequest()和isPermissive方法isLoginRequest()在BasicHttpAuthenticationFilter中会继续调用isLoginAttempt()，这个方法会判断Authorization请求头是否为空，如果不为空，会继续调用重载方法isLoginAttempt()，这个方法会判断Authorization请求头的值是否以BASIC开头，如果不是isLoginAttempt()就会返回false，最后就会调用isPermissive()，而它会判断过滤器中有没有permissive这个过滤器，没有返回false，然后整个subject.isAuthenticated()就返回了false如果最终onPreHandle()返回false，就不会执行过滤器链了" }, { "title": "Redis是如何执行的", "url": "/posts/Redis%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/", "categories": "数据库, Redis", "tags": "", "date": "2022-08-08 00:00:00 +0800", "snippet": "一条Redis命令是如何执行的我们从客户端输入一条命令到服务端执行这条命令究竟发生了什么，今天就来探讨这个问题转换命令为Redis协议客户端并不会把我们输入的命令直接发送给服务端，任何客户端服务端之间的通信都遵循某种协议，这种协议方便服务端对命令进行解析，例如判断命令拼写是否错误Redis客户端会将命令转换为RESP格式，RESP（REdis Serialization Protocol）然后发送给客户端 当然在这之前客户端会和服务端建立Socket连接，每个Socket被创建，会分配两个缓冲区：输入缓冲区和输出缓冲区， 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。注意：Redis 使用的是 I/O 多路复用功能来监听多 socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。用户空间和内核空间以Linux系统为例，各种发行版包括：Ubuntu、CentOS，通常会包含它的应用程序和内核，一般内核是没有区别的，Linux内核就相当与Window操作系统，它通常与各种硬件驱动配合操作各种计算机硬件资源（CPU、内存、网卡），而用户应用如果要访问系统资源就必须使用Linux内核封装后提供的API（我们毕竟不能让用户应用直接访问系统资源，这样存在巨大的安全问题以及冲突），所以我们有必要将Linux内核和用户应用进行分离以32位的计算机来说，内存总空间是2^32位，也就是4GB，通常内核空间会占用1GB，用户空间会占用3GB这样用户进程和内核进程在寻址时（进程的寻址空间其实就映射到了磁盘空间）就会完全隔离，同时Linux对各种命令进行分级，有两个级别：r0和r3，其中r3级别最低，用户进程能够执行的命令一般就是r3级别的，而r0是级别最高的，只有内核才能执行，这样对命令分配权限就限制了用户进程对系统资源的随意访问但是用户进程有时又必须访问系统资源，这个时候就需要进行状态切换，也就是用户态 —&amp;gt; 内核态我们以磁盘操作为例，用户进程在写数据和读数据是都会操作缓存空间，写的时候先把数据写到缓存区，读的时候就从缓存区读，具体的状态切换的过程如下图：网络IO同磁盘操作，总结来说IO操作的时间消耗主要体现在： 进程等待数据就绪 数据从内核空间拷贝到用户空间而后面将要提到的五种IO模型都是从这两方面去进行优化的五种IO模型阻塞IO 用户进程调用系统API-recvfrom 内核会检查内核缓冲区数据是否准备就绪 如果数据没有就绪，就会一直等待直到数据就绪 数据就绪后还没完，进程还需等待数据从内核缓冲区拷贝到用户缓冲区 当这个完成recvfrom返回OK的信息，整个调用就完成了总结来看阻塞IO在数据等待和数据拷贝这两个阶段一直处于阻塞状态（除了等待操作完成，它什么都没干，cup处于闲置状态，所以阻塞IO效率很低）非阻塞IO对比阻塞IO，非阻塞IO就不等待 如果数据没有就绪，直接返回错误结果 然后一直盲轮询询问数据是否就绪， 直到数据真正就绪，便等待数据拷贝 拷贝完成后，整个操作就完成了总结来说：非阻塞IO在数据等待阶段确实是非阻塞的，但这段时候它做的操作只是盲轮询，并没有做什么更有意义的操作，这样它性能不仅没有提高还会导致cpu空转，cpu使用率暴增，而且在数据拷贝阶段它依然是阻塞的虽然非阻塞IO看起来非常废，但是在IO多路复用需要结合它发挥作用IO多路复用总结阻塞IO和非阻塞IO，我们能够发现：在调用系统API之后性能问题总是出现在数据等待阶段，这段时期阻塞IO会一直等待、非阻塞IO不等待但会一直轮询使得cpu空转利用率暴增，这些操作都导致了性能问题所以为了避免这种问题，我们就提前询问内核那些系统数据准备好了，然后再去调用系统API问题就是我们如何得知系统数据准备好了呢？ 文件描述符在调用recvfrom之前调用select监听fd是否就绪，如果所有fd都没有就绪就会阻塞等待否则就会返回就绪的fd，此时调用recvfrom就会直接执行拷贝数据阶段对比于阻塞IO和非阻塞IO，IO多路复用避免了可能存在已经就绪的fd被阻塞而进行无效的等待 不同的监听fd以及通知的方式 select poll epollselect和epoll的操作大致一致，epoll的性能最好，通常高性能网络服务器一般操作epoll这种方式，如果epoll这种方式在操作系统上不支持就会采用select，因为select通用性更好，基本所有系统都支持它们的具体差异体现在： select和poll只会返回已就绪fd的数量，实际操作fd的时候需要遍历，而epoll会直接返回已经就绪的fd epoll会在通知用户进程fd就绪的同时，就把就绪的fd写入了用户空间总结来说：IO多路复用就是利用单个线程来同时监听多个fd，并在某个fd可读、可写时得到通知，从而避免无效的等待，充分利用cpu资源IO多路复用-select实现方案IO的三种可能事件Linux系统把一个IO可能发生的事件分为三类：读事件、写事件、异常事件解析select源码 nfds是要监听的fd_set的最大fd+1，其实就是fd数量的上限 timeout是超时时间，单位是秒，如果为null，当没有fd就绪时，内核线程就会一直等待，直到fd就绪 fd_set类型，首先它是一个结构体，并且是一个数组长度为32的结构体，但是__fd_mask类型占用4个字节，所以fd_set的总长度是1024个bit，而每个fd占用1bit，因此fd_set最大可以存储1024fdselect的流程用户空间：1.1.创建fd_set rfds，此时fd_set的所有的bit都会被初始化为0，这里假设只有IO读事件1.2.假设要监听fd=1，2，5，此时会从低位往右遍历，将需要监听的fd的bit位置为1，即1，2，5下标（从1开始）对应的值为11.3.执行select(5+1, rfds, null, null, 3)，监听所有的fd，同时会将rfds，拷贝到内核空间，因此从这一步开始，由用户态转换为内核态2.4.遍历拷贝回来的rfds，找到就绪的fd，读取其中的数据内核空间：2.1.此时rfds已经拷贝到内核空间，开始监听，从低位遍历fd_set，直到遍历到nfds2.2.判断bit位值为1的fd是否就绪，如果没有就绪，则休眠2.3.等待数据就绪被唤醒或超时，假设此时fd=1数据就绪2.4.内核再次遍历，将fd=1的保留，其余的置为0，然后select返回fd就绪的数量，同时内核态又会将rfds拷贝回用户态就绪的fd处理完成后，就会继续从1.2开始执行，然后循环往复select方案的缺点 需要将整个fd_set从用户空间拷贝到内核空间，select结束还要继续拷贝回用户空间，涉及到多次数据拷贝和用户态和内核态的切换，开销大 select无法得知具体哪个fd就绪，依然需要遍历整个fd_set fd_set监听的数量最大为1024个，在如今的高并发的场景下，已经远远达不到要求IO多路复用-poll实现方案poll对select进行了简单的改进，监听的fd不再限制为1024个，理论上可以是无限个源码分析 相比与select的fd_set存储监听的fd，poll使用结构体pollfd来存储一个个的fd，所以我们在传递参数的时候理论上是一个pollfd的数组 pollfd内部由三个属性组成，分别是fd，events，revents，在初始化时，只会初始化前两个属性poll流程 创建pollfd数组，初始化每个pollfd，数组大小自定义 调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限 内核遍历fd，判断是否就绪 数据就绪或者超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n 在用户进程中判断n是否大于0，大于0说明由就绪的fd 大于0就遍历pollfd数组，找到就绪的fd对比select方案 select模式中fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限 监听fd越多，每次遍历消耗的时间也越久，性能反而下降IO多路复用-epoll实现方案epoll模式是对select和poll的改进，它提供的三个函数：epoll源码分析 epoll_create(int size)，会创建eventpoll结构体，里面包含一颗红黑树rbr，一条链表rdlist，创建起初都为空；函数执行完毕回返回一个epfd的句柄，这个可以看作eventpoll的唯一标识，也就是说eventpoll可以由多个，而在监听fd时，我们要通过这个句柄，明确要使用的是哪个eventpoll select做的工作包括监听fd和等待fd就绪，而epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)只是将需要监听的fd添加到红黑树当中，并且会为每个添加的fd及其对应的事件设置一个回调函数ep_poll_callback，每当fd就绪，就会触发，回调函数会把fd加入到链表当中 函数epoll_wait回对监听的fd进行等待，同时会传入一个空的数组events用来接收就绪的fd，epoll_wait不会直接遍历红黑树去检查fd是否就绪，而是直接检查链表，如果链表长度大于0，说明有fd就绪，然后返回就绪fd的数量如果没有，等待，如果超时还是没有fd就绪，直接返回0epoll流程epoll是如何解决select中出现的三种问题的IO多路复用-事件通知机制这里主要是针对epoll的epoll_wait接收到的通知，也就是说在epoll_wait等待期间，如果有fd就绪，epoll_wait就会接收到通知两种事件通知模式 LevelTriggered：简称LT。当FD有数据可读时，会重复通知多次，直至数据处理完成。是Epoll的默认模式 EdgeTriggered：简称ET。当FD有数据可读时，只会被通知一次，不管数据是否处理完成。两种事件通知机制的不同我们知道当fd就绪时，会触发回调，回调函数会见就绪的fd添加到聊表当中，当我们调用epoll_wait时，会得到通知，然后返回就绪的fd个数，并且将就绪的fd添加到events数组中，其实在这一步还有一些工作：在拷贝之前，内核线程会将就绪fd从链表中移除，然后再执行拷贝，这里我们假设就绪fd还有数据没有读取完成，那么从这开始，两种通知模式就会有区别了：对于LT模式：LT模式下，拷贝过后，会把fd重新添加进入链表，那么当下次执行epoll_wait操作时，链表里就有原来未读完数据的fd对于ET模式：不会进行判断，直接结束，当下次执行epoll_wait操作时，未读完的fd已经从链表中移除了明明LT看起来比较好，为什么还需要ET呢首先反复的通知是非常消耗性能的，因为要不断的将fd从内核态拷贝到用户态，而对于ET有下面两种改进方法： 手动调用epoll_ctl()，将未读取完成的fd，修改它们在红黑树中的状态，这样会触发eventpoll对这些fd进行检查，判断它们是否真的数据没有读完，如果是的，将它们添加进入链表，这样就实现了手动添加fd，当这样就更LT没有区别了，因为如果数据没有读完，fd就会反复拷贝 为了不让fd反复拷贝，我们希望能够一次性读完数据，这样我们就应该采用非阻塞IO，在数据未读完时，就会不断请求fd，知道读完，非阻塞IO就会返回，而不会向阻塞IO一样继续等待LT模式存在的问题 效率问题，fd数据不断在内核空间和用户空间之间拷贝 惊群现象，如果有多个进程同时监听某个fd，当这个fd就绪，那么所有的进程都会被唤醒，因为对于LT来说，每次拷贝过后会把fd重新添加进入链表，所以每当进程调用epoll_wait，都会收到通知，而fd其实在前几个进程中数据可能就读完了，也就是说唤醒后面的进程是没有意义的总结 ET模式避免了LT模式可能出现的惊群现象 ET模式最好结合非阻塞IO读取FD数据，相比LT会复杂一些，但性能会更好IO多路复用-web服务流程信号驱动IO和异步IO" }, { "title": "为何说只有一种实现线程的方法", "url": "/posts/%E4%B8%BA%E4%BD%95%E8%AF%B4%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/", "categories": "多线程", "tags": "", "date": "2022-08-04 00:00:00 +0800", "snippet": "进程是什么，线程是什么进程是运行在内存中的程序，线程是进程中程序执行的基本单元为什么有了进程，还要引入线程呢？进程的上下文切换成本过高，为了降低并发导致的进程切换成本，提出了线程，线程几乎不占资源，因此线程切换的成本较少，后来就换用线程抢占cpu执行权线程的创建方式继承Thread类public class ThreadDemo1 extends Thread { public static void main(String[] args) { // ThreadDemo1继承了Thread类，并重写run() ThreadDemo1 t = new ThreadDemo1(); // 开启线程：t线程得到CPU执行权后会执行run()中的代码 t.start(); } @Override public void run() { System.out.println(&quot;Thread is running&quot;); }}该种方法继承Thread类，并重写run()方法实现Runnable接口public class ThreadDemo2 implements Runnable{ public static void main(String[] args) { // ThreadDemo2实现Runnable接口，并实现run() ThreadDemo2 target = new ThreadDemo2(); // 调用Thread构造方法，传入TreadDemo2的实例对象，创建线程对象 Thread t = new Thread(target); // 开启线程：t线程得到CPU执行权后会执行run()中的代码 t.start(); } public void run() { System.out.println(&quot;Thread is running&quot;); }}这种方法需要实现Runnable接口（Runnable接口只有一个run()方法）将实现类对象传递给Thread构造函数，有Thread对象调用Runnable实现类中的run方法相较于直接继承Thread类覆盖run方法，我们常使用第二种方法线程池创建线程static class DefaultThreadFactory implements ThreadFactory { private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() { SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;; } public Thread newThread(Runnable r) { Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; }}这段代码是java.util.concurrent下的一段源代码： 对于线程池而言，本质上是通过线程工厂创建线程的，默认采用 DefaultThreadFactory 会给线程池创建的线程设置一些默认值，比如：线程的名字、是否是守护线程，以及线程的优先级等 但是无论怎么设置这些属性，最终它还是通过 new Thread() 创建线程的 ，只不过这里的构造函数传入的参数要多一些，由此可以看出通过线程池创建线程并没有脱离最开始的那两种基本的创建方式，因为本质上还是通过 new Thread() 实现的。有返回值的 Callable 创建线程class CallableTask implements Callable&amp;lt;Integer&amp;gt; { @Override public Integer call() throws Exception { return new Random().nextInt(); }}//创建线程池ExecutorService service = Executors.newFixedThreadPool(10);//提交任务，并用 Future提交返回结果Future&amp;lt;Integer&amp;gt; future = service.submit(new CallableTask());这种线程创建方式是通过有返回值的 Callable 创建线程，Runnable 创建线程是无返回值的，而 Callable 和与之相关的 Future、FutureTask，它们可以把线程执行的结果作为返回值返回，如代码所示，实现了 Callable 接口，并且给它的泛型设置成 Integer，然后它会返回一个随机数。但是，无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。它们可以放到线程池中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的实现线程只有一种方式 首先，启动线程需要调用 start() 方法，而 start() 方法最终还会调用 run() 方法 而不管是实现Runnable接口还是基础Thread类，最终都需要调用new Thread().start()方法启动线程，而start()方法最终也会调用已经被重写或者说接口中实现的的run()方法来执行它的任务所以说，事实上创建线程只有一种方式：就是构造一个Thread类，这是创建线程的唯一方式为什么实现Runnable接口是创建线程的常用方法 限制Thread构造函数的参数类型，如果使用这种方法就必须向Thread构造函数传递Runnable实现类对象 解耦，将被执行的run方法视作资源，Thread对象视作执行者，第二种方法就是为了将执行者和资源进行解耦，第一种方法资源依然在Thread类中，而第二种方法资源是在Runnable的实现类中，这样就方便其他线程共享该资源总结无论是继承Thread类还是实现Runnable接口，线程的入口都是Thread类（因为Thread类的run方法在线程启动时一定会执行），下面的Thread类run方法的源码：" }, { "title": "二叉树", "url": "/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/", "categories": "算法与数据结构", "tags": "", "date": "2022-08-03 00:00:00 +0800", "snippet": "二叉树节点结构递归序什么是递归序 递归序是二叉树递归遍历的一种套路 按照递归序，每个节点会经过3次，第一次是初次进入节点，第二次是左树返回节点，第三次是右树返回节点例如，存在下面的树：那么按照头节点、左树、有树的遍历顺序，一定有这样的递归序：1 2 3 3 3 2 4 4 4 2 1 5 6 6 6 5 7 7 7 5 1，根据递归序，我们可以轻松得到前序遍历、中序遍历、后续遍历的序列： 前序遍历，第一次经过节点的序列：1 2 3 4 5 6 7 中序遍历，第二次经过节点的序列：3 2 4 1 6 5 7 后序遍历，第三次经过节点的序列：3 4 2 6 7 5 1递归序是一种思想，它便于我们更加容易的写出二叉树递归的code，像下面这样：public class Solution { public static class Node{ private int value; private Node left; private Node right; } public void f(Node head){ if (head == null){ return; } // 这里是第一次进入head节点 f(head.left); // 这里是从左树返回后，第二次进入head节点 f(head.right); // 这里是从右树返回后，第三次进入head节点 }}如果是前序遍历，就在第一次进入节点的时候打印value，中序遍历、后序遍历同理非递归遍历二叉树任何递归都可被改成非递归，二叉树递归也不例外，只要我们不使用系统压栈，而是自己手动压栈就行了先序遍历准备好一个栈： 先入头节点 弹出并输出节点value，如果节点有左右孩子节点，先压入右节点，再压入左节点 重复1、2操作，直到栈为空中序遍历准备一个栈： 先压入头节点，再依次压入左边界（每棵树的左节点） 弹出节点并打印value，如果有右节点，压入右节点，再依次压入右节点所在子树的左边界 重复1、2操作，直到栈为空后序遍历准备两个栈，s1压入栈，s2收集栈： 先压入头节点 弹出节点，不打印保存到收集栈，如果有左右孩子，先左孩子后右孩子压入栈 重复1、2操作，直到压入栈为空，然后弹出收集栈，直至收集栈为空，弹出的序列就是后续遍历总结非递归中，难度最大应该就是中序遍历了，因为说是非递归其实做法里面都体现的递归思想，下面对三种非递归方式进行总结： 先序遍历比较简单，就不重复总结了 中序遍历：从序列来将：左树 –&amp;gt; 父节点 –&amp;gt; 右树，为了按照这个顺序打印出来，我们需要对左树不断递归，将左树一个个存入栈直到左树为空，这时从栈中弹出节点cur，此时cur就是最左树，因此优先存储它的val，然后对cur的右树重复需要最左树的操作，如果右树为空，从栈中继续弹出，重复操作直至栈为空，并且cur为null，此时当前节点的左树val都已存储，并且右树为空，所以停止打印 后序遍历需要准备两个栈，st1弹出的顺序为： 父节点 –&amp;gt; 右节点 –&amp;gt; 左节点，以弹出的顺序存入另外一个栈st2，那么st2的出栈顺序就是：左节点 –&amp;gt; 右节点 –&amp;gt; 父节点，那么经推测最先存入st1的顺序是：父节点 –&amp;gt; 左节点 –&amp;gt; 右节点，注意是先弹出父节点，再压入左节点和右节点真题链接：144. 二叉树的前序遍历94. 二叉树的中序遍历145. 二叉树的后序遍历如何直观的打印一棵树这类题目通常是设计题宽度优先遍历（层序遍历）准备一个队列（在Java中，LinkedList虽然底层结构是双向链表但也可以作为队列使用）： 先压入头节点 队列弹出节点并打印，如果存在左右孩子节点，先左后右压入队列 重复1、2操作，直到队列为空注意：因为队列是先进先出的特点，所以不用一次性把该层的节点全部弹出，但再某些情况下，比如BFS求树的深度，最好通过队列容量一次性弹出所有的节点真题链接：102. 二叉树的层序遍历二叉树的递归套路该套路可以解决大部分的树形DP问题，并且思路和递归特别像，其实呢就是动态规划：父类问题由子类（条件）推出，套路如下： base条件：即当节点为空时应该返回什么？ 左右子树的递归应该返回什么结果（左右子树的结果应该是形式相同的）给当前节点，当前节点根据左右子树的返回条件判断以当前节点为根节点的树的状态，下面列出的各个问题大多可以使用这个思路，少数题目则不适合判断二叉树是否是二叉搜索树什么是二叉搜索树？左树总小于根节点，右树总大于根节点，同时树内没有相同的元素，因为二叉搜索树在构建的时候相同的数据不会重复插入思路： 中序遍历二叉树，如果数值一直升序，说明是BST，否则不是，注意：需要一个全局变量用于存储前序节点，这个方法可以使用递归的方式，也可以使用迭代+栈的方式 利用递归套路： 如果左树或右树不是BST，那么整棵树就不是BST 如果左树和右树都是BST，但（左树的最大值大于当前节点的值）或者（当前节点的值大于右树的最小值） 如何将以上信息整理返回给父亲节点呢？public class ReturnResult{ public int max; public int min; public boolean is; public ReturnResult(){} public ReturnResult(Integer mi, Integer ma, boolean is){ min = mi; max = ma; this.is = is; }}我们定义上面的类作为节点返回值，当： 当前节点如果为空，直接返回null 当前节点所在树不是BST，is为false，最大最小值其实已经无所谓了 如果当前节点所在树是BST，那么返回new ReturnResult(leftResult.min, rightResult.max, true)这样当前节点按照左右子树返回的结果就能判断自己所在的树是不是BST了真题链接：98. 验证二叉搜索树判断二叉树是否是完全二叉树思路： 如果当前节点有右树但没有左树，肯定不是完全二叉树 如果左右节点不双全，那么之后遍历到的节点都应该是叶子节点另外这个题目不适合使用二叉树的递归套路，主要我想不到统一返回的条件，至少实现起来比较困难求二叉树的高度 使用递归方法求，整棵树的高度等于左右子树的最大值+1（dfs） 层序遍历，二叉树的高度就是层数，注意：每次层序遍历，我们要保证当前层的所有数据都从队列中弹出，这样层次才是有效的，当队列为空时，说明每层都已经遍历完成，此时的计数遍历ans就是二叉树高度难点在于如何让每层的数据全部从队列中弹出呢？ 由于每次队列中的数据都是该层的，所以记录队列的容量size，直到size==0，说明该层的数据都已经被遍历并弹出真题链接：104. 二叉树的最大深度判断是否满二叉树思路： 节点数N和深度l满足 N = 2^l - 1 左右子树应该返回给当前节点的信息中包括节点的个数和深度判断二叉树是否为平衡二叉树思路： 平衡二叉树满足的条件是：左右子树的高度差小于2 左右子树应该返回的信息包括：是否是平衡二叉树，高度多少给定两个二叉树的节点Node1和Node2，找到它们的最低公共祖先节点思路： Map保存所有的节点与父节点的 尝试保存Node1的遍历轨迹，将其保存在set集合中 尝试判断Node2的轨迹节点是否在Node1的set集合中，那么第一次判断在的就是它两的最低公共祖先节点另外还有一种思路：Node1和Node2可能出现在树中的情况： 如果左右子树既没有Node1也没有Node2，那么应该返回null， 如果左右子树返回值都不为空，那么返回当前节点， 如果左右子树不全为空，即一个为空一个不为空，那么返回不为空的那个找一个节点的后继节点后继节点就是中序遍历一个节点的后一个节点，前驱节点就是中序遍历中一个节点的前一个节点思路： 遍历一遍中序，并保存，然后在里面找第二种思路： 令当前节点为x，它的后继节点为y，那么当x无右树的时候判断当前节点是否是父节点的左树，是返回父节点，否则不断向上遍历 x有右树的时候，它的后继节点是右树最左节点二叉树的序列化和反序列化 二叉树序列化：将一个棵树转换成唯一的字符串 二叉树反序列化：将字符串还原成树折纸问题折痕的凹凸对应二叉树的左右树，而它的遍历序列其实就是二叉树的中序遍历" }, { "title": "链表", "url": "/posts/%E9%93%BE%E8%A1%A8/", "categories": "算法与数据结构", "tags": "", "date": "2022-08-01 00:00:00 +0800", "snippet": "hash表简单介绍 hash表可以理解为一种集合结构，在java中对应的数据结构是：HashSet和HashMap 有无伴随数据是HashSet和HashMap的唯一区别，底层都是按照key依照某种实现组织的 CURD操作都是O(1)级别的，但相比于数据寻址的O(1)要大的多，也就是说常数更大 HashMap的key和value都不能是基本数据类型，如果是基本数据类型的包装类和String，数据的保存方式是深拷贝，即值传递，如果是引用数据类型就是浅拷贝，保存的都是引用地址而且占用空间统一是8个字节有序表简单介绍 在java中的实现是：TreeSet和TreeMap 相比于hash表结构，有序表是按照key通过某种排序规则进行排序的，另外hash表它是无序的，同时有序表的数据操作是O(logN)级别的 如果key是引用数据类型必须提供比较器Comparator，这点同优先队列PriorityQueue 由于有序的加成，除了CURD操作，有序表还有很多额外操作额外操作单链表和双链表一般结构链表类的题目如何解决反转单链表和双链表思路：将前一个节点存储，遍历后续节点时指向前一个节点例题链接：剑指 Offer 24. 反转链表反转单链表递归解法反转链表 II思路，头插法： 我们的目的是将[left,right]的节点反转 而从left开始，我们每次反转一个 准备三个指针，pre、cur、next 初始化next = cur.next，然后cur.next = next.next这是为了迭代能够继续到right next.next = pre.next，因为pre总是指向被反转链表的头节点，而反转一个节点A后，A就应该成为头节点 pre.next = next，修改pre的指向，让他指向反转链表的头节点 继续循环直到循环完right-left次注意：链表这类题目通常做法是先设置一个虚头节点，ListNode dumNode = new ListNode(-1, head)，返回链表头节点的时候，通常就返回dumNode.next删除链表的倒数第 N 个结点真题链接思路： 栈，先把包括虚结点在内的所有链表节点存入栈中，然后从栈中弹出n个节点，栈顶就是前驱节点了 双指针，quick先走n个节点，然后同时遍历直到quick==null，slow会在倒数第n个节点的位置，不过为了方便我们应该让慢指针在第n个节点的前驱节点，然后使用pre.next = pre.next.next就可以完成节点的删除，因此可以让slow从dummy节点开始，dummy节点是我们的虚结点合并两个有序链表思路： 按照归并排序的merge过程的模式可以顺利合并两个有序链表 递归：在一次循环内只需要选出最小的节点A，然后就可以让A.next执行下次合并的结果，并且返回A真题链接：21. 合并两个有序链表打印两个链表的公共部分思路：分别遍历两个链表（前提是链表有序或者升序），相等输出，值小的向下遍历直至其中一个链表到达末尾判断链表是否是回文结构思路：对于这类链表的题目，我们往往会加一个虚节点插入到头节点之前，这样就能够避免链表长度的检查，也会少很多边界条件的判断（当然这是经验得出的，具体需要自己在实践中验证） （这种方法没必要设置虚结点）第一次遍历，将链表元素存入栈中，第二次遍历：栈中弹出一个遍历一个，如果栈最终为空返回true，如果某次比较不等返回false （设置虚结点后）快慢指针同时从虚结点开始找中间节点，其中慢指针每次走一步，快指针每次走两步，当pQ.next == null || pQ.next.next != null(pQ指的是快指针)将慢指针（不包括慢指针）后面的元素存入栈中，重复1的弹出比较操作如上图的这种解法它没有设置虚结点，一次快慢指针起点不同，慢指针从head.next开始，快指针从head开始，而且在慢指针后面的节点入栈时包括慢指针本身 （设置虚结点感觉要方便很多，因为不用多设置变量）同样找中间节点，慢指针指向null，快指针后面的元素反转，然后用指针保存开始和结尾的位置，向中间遍历，进行比较操作例题链接：234. 回文链表将单向链表划分成左边小、中间相等、右边大的形式思路： 将链表节点遍历放入数组、对数组进行partition操作，最后连起来 准备6个指针，小于区域头指针和尾指针两个、等于区域头指针和尾指针两个、大于区域头指针和尾指针两个，如果小于pivot，且是第一个，头指针尾指针都指向它，如果不是，尾指针指向新的，头指针指向尾指针，其余区域同；然后小于区域的尾指针指向等于区域的头指针，等于区域的尾指针指向大于区域的头指针，像下面这样然后判断某个区域是否为空（即没有节点），像下面这样操作：复制含有随机指针节点的链表思路： 第一种方法：最后返回首节点，code实现： 第二种方法：当然还要将新节点的next节点连好，然后从新老链表中分离出来两个单链表相交的一系列问题有环链表的特点：有环链表的遍历会陷入循环、无环遍历会走到null思路：（一）判断是否有环并返回入环节点否者返回null： 利用set集合，遍历链表，当某个节点在集合中存在时，它就是入环节点 快慢指针：如果有环快慢指针会相遇，否则快指针先到达null，如果FN代表快指针那么（FN.next == null || FN.next.next == null 表示无环），第一次相遇时，快指针回到起点（header），此时快慢指针都走一步最后会在入环节点相遇，code如下：注意：快慢指针必须从同一起点出发，否则最后是无法相遇的（二）如果都无环，那么结构一定是下面这样的：所以它们的末尾节点一定是相等的，另外长链表的长度减去短链表长度的差值，让长链表向遍历差值的距离，然后长短链表一起遍历最后会在第一个相交节点处相遇（三）如果一个有环一个无环那么不可能相交（四）如果都有环 那么可能是下面的结构：这种情况下先求出入环节点，如果入环节点相同就是这种情况，然后求出两条链表到入环节点的长度然后求出长度差值，让长链表向遍历差值的距离，然后长短链表一起遍历最后会在第一个相交节点处相遇 也有可能是下面的结构：如果入环节点不相同就是这种情况，那么如果从A开始遍历直到回到A节点之前，如果遇到B节点那么两条链表有相交点返回A（也可以返回B，此时A，B都算第一个相交点），如果没有遇到那么没有相交点真题链接：142. 环形链表 II141. 环形链表160. 相交链表思路： HashSet 双指针，分别从两个链表触发，当任意一个为null时，该指针指向原先不同的链表，最终会使得两个指针到链表的末尾距离相等总结 链表这种题目往往都有迭代和递归两种解法，对于递归我们要记住，链表的长度尽量不要超过5000，超过5000极易造成堆栈溢出 解决链表这种题目我们往往设置一个虚结点dummy，有了虚结点就能减少对head头节点的判断，最终我们只要返回dummy.next就行了 链表的常用的节省空间的办法是快慢指针，通常需要调整快慢指针的距离" }, { "title": "在Spring和SpringBoot中优雅的进行参数校验", "url": "/posts/%E5%9C%A8Spring%E5%92%8CSpringBoot%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/", "categories": "框架, SpringBoot", "tags": "", "date": "2022-07-21 00:00:00 +0800", "snippet": "前言数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。最普通的做法就像下面这样。我们通过 if/else 语句对请求的每一个参数一一校验。@RestController@RequestMapping(&quot;/api/person&quot;)public class PersonController { @PostMapping public ResponseEntity&amp;lt;PersonRequest&amp;gt; save(@RequestBody PersonRequest personRequest) { if (personRequest.getClassId() == null || personRequest.getName() == null || !Pattern.matches(&quot;(^Man$|^Woman$|^UGM$)&quot;, personRequest.getSex())) { } return ResponseEntity.ok().body(personRequest); }}这样的代码，小伙伴们在日常开发中一定不少见，很多开源项目都是这样对请求入参做校验的。但是，不太建议这样来写，这样的代码明显违背了 单一职责原则。大量的非业务代码混杂在业务代码中，非常难以维护，还会导致业务层代码冗杂！实际上，我们是可以通过一些简单的手段对上面的代码进行改进的！这也是本文主要要介绍的内容！注意：本文主要讲解基于Sping Boot的注解校验，Spring Boot版本依赖如下：&amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.7.1&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;&amp;lt;/parent&amp;gt;添加相关依赖基于 Spring Boot 的话，只需要给项目添加上下面这些依赖：&amp;lt;dependencies&amp;gt; &amp;lt;!--参数校验依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-validation&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--测试依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Spring Web依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok工具--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;在Spring Boot 2.3 1 之前，spring-boot-starter-validation 包括在了 spring-boot-starter-web 中，但如果你使用的Spring Boot版本大于2.3.1，比如我当前使用的是2.7.1，那么就必须手动添加依赖spring-boot-starter-validation验证 Controller 的输入验证请求体验证请求体即是验证被 @RequestBody 注解标记的方法参数。我们在需要验证的参数上加上了@Valid注解，如果验证失败，它将抛出MethodArgumentNotValidException。默认情况下，Spring 会将此异常转换为 HTTP Status 400（错误请求）。PersonController@RestController@RequestMapping(&quot;/api/person&quot;)public class PersonController { @PostMapping public ResponseEntity&amp;lt;PersonRequest&amp;gt; save(@RequestBody @Valid PersonRequest personRequest) { return ResponseEntity.ok().body(personRequest); }}注意：这里开启Spring数据校验使用@Validated也可以PersonRequest我们使用校验注解对请求的参数进行校验！@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class PersonRequest { @NotNull(message = &quot;classId 不能为空&quot;) private String classId; @Size(max = 33) @NotNull(message = &quot;name 不能为空&quot;) private String name; @Pattern(regexp = &quot;(^Man$|^Woman$|^UGM$)&quot;, message = &quot;sex 值不在可选范围&quot;) @NotNull(message = &quot;sex 不能为空&quot;) private String sex;}正则表达式说明： ^string : 匹配以 string 开头的字符串 string$ ：匹配以 string 结尾的字符串 ^string$ ：精确匹配 string 字符串 (^Man$|^Woman$|^UGM$) : 值只能在 Man,Woman,UGM 这三个值中选择自定义全局异常处理器捕获数据校验异常自定义异常处理器可以帮助我们捕获异常，并进行一些简单的处理。GlobalExceptionHandler@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler { /** * 处理参数校验失败异常 * @param exception 异常类 * @return 响应 */ @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) public ResultBean exceptionHandler(MethodArgumentNotValidException exception){ //我们主要获取这个接口BindingResult的数据，它就包含了我们使用@RequestBody绑定的参数的所有信息，无论是校验异常错误信息还是JavaBean参数的属性信息 BindingResult bindingResult = exception.getBindingResult(); Map&amp;lt;String, String&amp;gt; errorMap = new HashMap&amp;lt;&amp;gt;(); StringBuffer buffer = new StringBuffer(); if(bindingResult.getFieldErrors() != null){ for (FieldError fieldError : bindingResult.getFieldErrors()) { String field = fieldError.getField(); Object rejectedValue = fieldError.getRejectedValue(); String defaultMessage = fieldError.getDefaultMessage(); errorMap.put(field, defaultMessage); String msg = String.format(&quot;错误字段：%s, 错误值：%s, 原因：%s&quot;, field, rejectedValue, defaultMessage); buffer.append(msg); log.warn(&quot;错误字段：[{}], 错误值：[{}], 原因：[{}]&quot;, field, rejectedValue, defaultMessage); } } return ResultBean.error(buffer.toString(), errorMap, 400); }}通过Postman测试验证验证成功的情况验证失败的情况顺便一提，如何在PostMan发送请求体json数据，也就是说后端用@RequestBody接收的参数： 设置请求头Content-Type:application/json，content-type首字母小写也是可行的 传递json参数验证请求参数这些参数通常被 @PathVariable 以及 @RequestParam标记，并且相对于JavaBean的参数，我们往往将其称为平铺参数注意：这里适用@Valid注解是不行的，因为它要求待校验的入参是JavaBean，所以如果需要校验平铺参数，请使用@Validated开启Spring自动参数校验PersonController@RestController@RequestMapping(&quot;/api/person&quot;)@Validatedpublic class PersonController { @GetMapping(&quot;/{id}&quot;) public ResponseEntity&amp;lt;Integer&amp;gt; getPersonByID(@PathVariable(&quot;id&quot;) @Max(value = 5, message = &quot;超过 id 的范围了&quot;) Integer id) { return ResponseEntity.ok().body(id); } @PutMapping(&quot;/{name}&quot;) public ResponseEntity&amp;lt;String&amp;gt; getPersonByName(@RequestParam(&quot;name&quot;) @Size(max = 6, message = &quot;超过 name 的范围了&quot;) String name) { return ResponseEntity.ok().body(name); }}ExceptionHandler/*** 处理平铺参数校验失败*/@ExceptionHandler(ConstraintViolationException.class)public ResultBean exceptionHandler(ConstraintViolationException exception){ log.warn(exception.getMessage()); return ResultBean.error(exception.getMessage(), 400);}通过Postman测试验证验证成功的情况验证失败的情况验证 Service 中的方法我们不仅可以使用@Validated和@Valid验证Controller组件，也可以验证其他Spring管理的组件，比如Service，不过Controller一般不提供接口，而Service一般是面向接口编程，而这个地方有坑，需要注意下面几点： 在实现类中重定义接口方法的参数校验配置会失败且会报错：javax.validation.ConstraintDeclarationException: HV000151: A method overriding another method must not redefine the parameter constraint configuration，这个异常信息也告诉我们：参数的校验配置应该写在接口方法中，并且实现类不能修改配置，要么保持一样，要么可以不用写参数校验配置 在非Controller组件中，像Service，必须组合使用@Validated和@Valid，其中@Validated作为类注解、@Valid作为方法参数注解javaBean，这样参数校验才会生效，并且它产生的异常是ConstraintViolationException，这个跟之前Controller中的平铺参数校验产生的异常是相同的，这个异常没有继承BindException接口，相对而言它的错误不好像BindException和MethodArgumentNotValidException那样处理 如果方法参数是平铺参数，那么只要加@Validated就行了```java@Service@Validatedpublic class PersonServiceImpl implements PersonService {@Override public PersonRequest insertPerson(@NotNull @Min(10) Integer id, @NotNull String name) { return null; }}4. @Validated可以放在接口中，也可以放在实现类中，不过我一般放在实现类中**PersonService**```javapublic interface PersonService { PersonRequest insertPerson(@Valid PersonRequest person);}PersonServiceImpl@Service@Validatedpublic class PersonServiceImpl implements PersonService { @Override public PersonRequest insertPerson(PersonRequest person) { return person; }}ExceptionHandler@ExceptionHandler(ConstraintViolationException.class)public ResultBean exceptionHandler(ConstraintViolationException exception){ log.warn(exception.getMessage()); return ResultBean.error(exception.getMessage(), 400);}通过Postman测试验证参数校验失败级联校验级联校验关键点在于@Valid，级联校验的意思是JavaBean内部有其他JavaBean需要验证，那么这个JavaBean就需要加@Valid注解，并且只能用@Valid，因为它可以标记字段，@Validatd不行PersonRequest@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class PersonRequest { @NotNull(message = &quot;classId 不能为空&quot;) private String classId; @Pattern(regexp = &quot;(^Man$|^Woman$|^UGM$)&quot;, message = &quot;sex 值不在可选范围&quot;) @NotNull(message = &quot;sex 不能为空&quot;) private String sex; @Valid //让InnerChild的属性也参与校验 @NotNull private InnerChild child; //内部的JavaBean @Getter @Setter @ToString public static class InnerChild { @Size(max = 33) @NotNull(message = &quot;name 不能为空&quot;) private String name; @NotNull(message = &quot;年龄不能为空&quot;) @Positive(message = &quot;年龄只能为正数&quot;) private Integer age; }}Validator 编程方式手动进行参数验证某些场景下可能会需要我们手动校验并获得校验结果。我们通过 Validator 工厂类获得的 Validator 示例。另外，如果是在 Spring Bean 中的话，还可以通过 @Autowired 直接注入的方式。@AutowiredValidator validate具体使用情况如下：/** * 手动校验对象 */@Testpublic void check_person_manually() { ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); Validator validator = factory.getValidator(); PersonRequest personRequest = PersonRequest.builder().sex(&quot;Man22&quot;) .classId(&quot;82938390&quot;).build(); Set&amp;lt;ConstraintViolation&amp;lt;PersonRequest&amp;gt;&amp;gt; violations = validator.validate(personRequest); violations.forEach(constraintViolation -&amp;gt; System.out.println(constraintViolation.getMessage()));}输出结果如下：sex 值不在可选范围name 不能为空自定义 Validator(实用)如果自带的校验注解无法满足你的需求的话，你还可以自定义实现注解。案例一:校验特定字段的值是否在可选范围比如我们现在多了这样一个需求：PersonRequest 类多了一个 Region 字段，Region 字段只能是China、China-Taiwan、China-HongKong这三个中的一个。第一步，你需要创建一个注解 Region。@Target({FIELD})@Retention(RUNTIME)@Constraint(validatedBy = RegionValidator.class)@Documentedpublic @interface Region { String message() default &quot;Region 值不在可选范围内&quot;; Class&amp;lt;?&amp;gt;[] groups() default {}; Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};}第二步，你需要实现 ConstraintValidator接口，并重写isValid 方法。public class RegionValidator implements ConstraintValidator&amp;lt;Region, String&amp;gt; { @Override public boolean isValid(String value, ConstraintValidatorContext context) { HashSet&amp;lt;Object&amp;gt; regions = new HashSet&amp;lt;&amp;gt;(); regions.add(&quot;China&quot;); regions.add(&quot;China-Taiwan&quot;); regions.add(&quot;China-HongKong&quot;); return regions.contains(value); }}现在你就可以使用这个注解：@Regionprivate String region;通过测试验证PersonRequest personRequest = PersonRequest.builder() .region(&quot;Shanghai&quot;).build();mockMvc.perform(post(&quot;/api/person&quot;) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(personRequest))) .andExpect(MockMvcResultMatchers.jsonPath(&quot;region&quot;).value(&quot;Region 值不在可选范围内&quot;));使用 Postman 验证案例二:校验电话号码校验我们的电话号码是否合法，这个可以通过正则表达式来做，相关的正则表达式都可以在网上搜到，你甚至可以搜索到针对特定运营商电话号码段的正则表达式。PhoneNumber.java@Documented@Constraint(validatedBy = PhoneNumberValidator.class)@Target({FIELD, PARAMETER})@Retention(RUNTIME)public @interface PhoneNumber { String message() default &quot;Invalid phone number&quot;; Class[] groups() default {}; Class[] payload() default {};}PhoneNumberValidator.javapublic class PhoneNumberValidator implements ConstraintValidator&amp;lt;PhoneNumber, String&amp;gt; { @Override public boolean isValid(String phoneField, ConstraintValidatorContext context) { if (phoneField == null) { // can be null return true; } // 大陆手机号码11位数，匹配格式：前三位固定格式+后8位任意数 // ^ 匹配输入字符串开始的位置 // \\d 匹配一个或多个数字，其中 \\ 要转义，所以是 \\\\d // $ 匹配输入字符串结尾的位置 String regExp = &quot;^[1]((3[0-9])|(4[5-9])|(5[0-3,5-9])|([6][5,6])|(7[0-9])|(8[0-9])|(9[1,8,9]))\\\\d{8}$&quot;; return phoneField.matches(regExp); }}搞定，我们现在就可以使用这个注解了。@PhoneNumber(message = &quot;phoneNumber 格式不正确&quot;)@NotNull(message = &quot;phoneNumber 不能为空&quot;)private String phoneNumber;通过测试验证PersonRequest personRequest = PersonRequest.builder() .phoneNumber(&quot;1816313815&quot;).build();mockMvc.perform(post(&quot;/api/person&quot;) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(personRequest))) .andExpect(MockMvcResultMatchers.jsonPath(&quot;phoneNumber&quot;).value(&quot;phoneNumber 格式不正确&quot;));使用验证组验证组我们基本是不会用到的，也不太建议在项目中使用，理解起来比较麻烦，写起来也比较麻烦。简单了解即可！当我们对对象操作的不同方法有不同的验证规则的时候才会用到验证组。我写一个简单的例子，你们就能看明白了！1.先创建两个接口，代表不同的验证组public interface AddPersonGroup {}public interface DeletePersonGroup {}2.使用验证组@Datapublic class Person { // 当验证组为 DeletePersonGroup 的时候 group 字段不能为空 @NotNull(groups = DeletePersonGroup.class) // 当验证组为 AddPersonGroup 的时候 group 字段需要为空 @Null(groups = AddPersonGroup.class) private String group;}@Service@Validatedpublic class PersonService { @Validated(AddPersonGroup.class) public void validatePersonGroupForAdd(@Valid Person person) { // do something } @Validated(DeletePersonGroup.class) public void validatePersonGroupForDelete(@Valid Person person) { // do something }}通过测试验证： @Test(expected = ConstraintViolationException.class) public void should_check_person_with_groups() { Person person = new Person(); person.setGroup(&quot;group1&quot;); service.validatePersonGroupForAdd(person); } @Test(expected = ConstraintViolationException.class) public void should_check_person_with_groups2() { Person person = new Person(); service.validatePersonGroupForDelete(person); }验证组使用下来的体验就是有点反模式的感觉，让代码的可维护性变差了！尽量不要使用！常用校验注解总结JSR303 定义了 Bean Validation（校验）的标准 validation-api，并没有提供实现。Hibernate Validation是对这个规范/规范的实现 hibernate-validator，并且增加了 @Email、@Length、@Range 等注解。Spring Validation 底层依赖的就是Hibernate Validation。JSR 提供的校验注解: @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式Hibernate Validator 提供的校验注解： @NotBlank(message =) 验证字符串非 null，且长度必须大于 0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内拓展 “@NotNull 和 @Column(nullable = false) 两者有什么区别？” @NotNull是 JSR 303 Bean 验证批注,它与数据库约束本身无关。 @Column(nullable = false) : 是 JPA 声明列为非空的方法。 总结来说就是即前者用于验证，而后者则用于指示数据库创建表的时候对表的约束。 对校验进行分类 基础校验，空字符串，null，字符串长短，数值大小等 业务校验，比如传了用户id要检查该用户是否存在，购买的数量是否超库存。是有业务逻辑的。 权限校验，比如有没有权限给用户添加订单 对于基础校验，建议在Controller做对于业务校验应该放在Service中做，Service应该是集中业务逻辑的对于权限校验，要看权限是怎么设计的。我一般是在controller做的。 总结@Validated和@Valid的区别 @Valid：标准JSR-303规范的标记型注解，用来标记验证属性和方法返回值，进行级联和递归校验 @Validated：Spring的注解，是标准JSR-303的一个变种（补充），提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制 在Controller中校验方法参数时，使用@Valid和@Validated并无特殊差异（若不需要分组校验的话） 相比于@Validated，@Valid可以用在字段级别约束，用来表示级联校验。 相比与@Valid，@Validated可以用于提供分组功能 在非Controller组件中校验方法参数时，@Valid和@Validated必须配合使用，其中@Validated标记组件类，@Valid标记方法参数，如果方法参数是平铺参数，那么只需要用@Validated标记类组件就行了 @Valid和@Validated作为类注解都有一个共同作用：开启Spring自动参数校验；但@Valid作为类注解只能标记Controller组件，而@Validated可以标记除Controller组件的其他组件比如@Service特别注意 @NotNull(message = “您还未上传任何图像”) MultipartFile multipartFile，校验MultipartFile是否为空，因为@NotNull直接对它进行标记，某种意义上它应该算平铺参数，所以最终的异常信息是ConstraintViolationException，所以应该使用@Validated参考链接 @Validated和@Valid的区别？校验级联属性（内部类） Spring方法级别数据校验：@Validated + MethodValidationPostProcessor优雅的完成数据校验动作 如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！" }, { "title": "PageHelper与LayUI分页组件的组合使用", "url": "/posts/PageHelper%E4%B8%8ELayUI%E5%88%86%E9%A1%B5%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8/", "categories": "项目, 牛客网讨论区", "tags": "", "date": "2022-07-19 00:00:00 +0800", "snippet": "同步分页相比与异步分页，同步分页的数据是和页面一起返回给前端的，它的特点是：每次页面切换会刷新页面，因此它的体验比不上异步分页，但是我们依然需要掌握PageHelper的使用 导入依赖&amp;lt;!-- MyBatis 分页插件 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.3&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;这是pageHelper的Spring Boot依赖，无需做任何配置，只要引入该依赖就可以使用，另外pageHelper的配合MyBatis使用的如果自定义Page类如果不使用pageHelper，我们就需要自定义Page类，像下面这样：/** * page 分页模型 * @param &amp;lt;T&amp;gt; 具体模块的 JavaBean */@Datapublic class Page&amp;lt;T&amp;gt; { public static final int PAGE_CAPACITY = 4; private Integer pageNo; //当前页码 private Integer pagesTotal; //总页码 private Integer pageCapacity = PAGE_CAPACITY; //当前页显示数量 private Integer itemTotalCount; //总记录数 private List&amp;lt;T&amp;gt; items; //当前页数据 private Integer from; //分页条页码的起点 private Integer to; //分页条页码的终点 private String url; //处理页面的前后台 url}从属性来看，我们分页需要用到这些数据：1.当前页码，2.总页码，3.每页的记录数，4.总记录数，5.分页条页码的起点，6.分页条页码的终点，这些数据的作用： 当前页码和每页的记录数，是分页查询的条件 总页码需要用总记录数和每页记录数计算 from和to是为了简化分页条的生成，如果分页条的功能要做完整的话，需要的分页条算法还是蛮复杂的 url就是为了复用，同时前端不好获取应用上下文，这个属性存在让分页切换的url更加容易获取可见如果自己设计的话需要考虑的东西还蛮多的，并且还不太方便，因此我们使用pageHelper上手pageHelperpageHelper的上手非常简单：PageHelper.startPage(pageNum, pageSize); //开启分页查询PageInfo&amp;lt;DiscussPost&amp;gt; discussPostPageInfo = new PageInfo&amp;lt;&amp;gt;(discussPostMapper.selectDiscussPosts()); //pageHelper自动分页 开启分页，PageHelper.startPage(pageNum, pageSize);，pageNum是当前页码，pageSize是每页的记录数 pageInfo封装需要分页的数据，selectDiscussPosts对应的SQL如下：&amp;lt;sql id=&quot;Base_Column_List&quot; &amp;gt;id, user_id, title, type, status, create_time, comment_count, score&amp;lt;/sql&amp;gt;&amp;lt;sql id=&quot;Blob_Column_List&quot; &amp;gt;content&amp;lt;/sql&amp;gt;&amp;lt;select id=&quot;selectDiscussPosts&quot; resultType=&quot;DiscussPost&quot;&amp;gt;select&amp;lt;include refid=&quot;Base_Column_List&quot; /&amp;gt;,&amp;lt;include refid=&quot;Blob_Column_List&quot; /&amp;gt;from `discuss_post`where `status` != 2order by `type` desc&amp;lt;/select&amp;gt;从这里就能看出pageHelper与自定义Page的不同点了： 不需要自定义分页查询，我们只需要查询需要分页的所用数据，并用PageInfo类封装，然后pageHelper就会自动生成分页查询的SQL，还有查询总数据量的SQL，就像下面这样：这两条SQL都是在我们最初的SQL的基础之上自动生成的，这样我们就少写了几句SQL，但是真正让我们方便的是这个PageInfo类：像这样有了pageInfo，只需把它传给前端，前端就可以通过pageInfo里面的属性，像total（总数据量）、pageNum（当前页码）、pageSize（每页的记录数）自动生成分页条了，需要注意的是： 前端不需要处理当前页，pageHelper会自动处理页码-1，执行分页查询 后端应该向前端传递的是pageInfo的JSON字符串而不是Java对象 如果你使用的是Thymeleaf模板渲染引擎，可能会直接通过Model向它传递java对象，这样通过模板获取到的数据是无法被js解析的，你也无法提取到需要的属性， 但如果是通过json工具像fastjson、gson将Java对象转换成json字符串，前端将json字符串解析成json对象就可以顺利提取属性了 由于js提取模板引擎的数据比较困难，我们可以使用表单的隐藏域来实现&amp;lt;input type=&quot;hidden&quot; name=&quot;pageInfo&quot; th:value=&quot;${pageInfo}&quot;&amp;gt;$(&#39;input[name=&quot;pageInfo&quot;]&#39;).val() //js通过这条语句就可以获取value了LayUI分页组件使用 引入依赖&amp;lt;link rel=&quot;stylesheet&quot; th:href=&quot;@{/layui/css/layui.css}&quot;&amp;gt;&amp;lt;script th:src=&quot;@{/layui/layui.js}&quot;&amp;gt;&amp;lt;/script&amp;gt; 在分页条容器中加载分页条/** * 分页条渲染函数，在页面加载时执行 */layui.use([&#39;laypage&#39;, &#39;layer&#39;], function () { var laypage = layui.laypage, layer = layui.layer; var pageInfo = getPageInfoJsonObject() // elem和count是必须项，elem是挂载的容器Id，注意不需要加#，count是需要分页的数据量 laypage.render({ elem: &#39;pagination&#39;, count: pageInfo.total, //数据总数 limit: pageInfo.pageSize, //每页的数量 curr: pageInfo.pageNum, theme: &#39;pagination&#39;, //自定义样式 jump: function (laypage, first) { //切换分页的回调 if (!first) { //如果不加这个条件判断，回调会反复触发执行 window.location.href = getUrl() + &quot;?pageNum=&quot; + laypage.curr } } });})LayUI分页组件的特点 相比与 pagination.js ，laypage不需要以页面数据为数据源 如果我们使用的是pagination.js，那么我们需要从后端获取所有的分页数据，这样和pagehelper的结合使用就会显得及其不优雅，而且由于是同步分页，那么每次页面刷新都会执行庞大的数据查询，效率很低 而LayUI有了分页的数据量就能生成分页条，这样就省了不少事 自动生成的分页条的html代码 自定义样式由theme属性指定，theme属性的可选值： theme: ‘#c00’，定义每个切换按钮的背景颜色，这时它的位置在a标签中 theme: ‘xxx’，将会生成 class=”layui-laypage-xxx” 的CSS类，以便自定义主题，这时它的位置在分页条的div中 laypage组件使用的注意点laypage能为我们自动生成分页条，但是不能帮我们设定页面切换的请求url，需要我们手动设置，目前有两种方法： laypage的jump参数定义了页面切换的回调，在该函数中我们可以通过window.location，替换地址栏的url，但是使用它，需要注意url不能写死，下面是window.location的用法： window.location.href （当前url）—— http://www.myurl.com:8866/test?id=123&amp;amp;username=xxx window.location.protocol（协议）—— http: window.location.host（域名 + 端口）—— www.myurl.com:8866 window.location.hostname（域名）—— www.myurl.com window.location.port（端口）—— 8866 window.location.pathname（路径）—— /test window.location.search （请求的参数）—— ?id=123&amp;amp;username=xxx window.location.origin（路径前面的url）—— http://www.myurl.com:8866 通过上面的特性就可以动态获取url，这样在不同的开发环境下，就算url发生变化，程序也能正常运行 第二种就是为我们的元素绑定点击事件，在点击事件中我们可以发送ajax请求，请求获取到的数据在通过html拼接成html字符串，加载到html中就可以实现了，当然也可以同样调用window.location请求页面和数据，这样能够避免html拼接的痛苦，当然ajax请求应该也可以直接接收页面内容，只不过这个我还没有尝试过（不过使用Thymeleaf之后感觉vue还是方便太多）" }, { "title": "零碎笔记", "url": "/posts/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/", "categories": "生活, 闲聊", "tags": "", "date": "2022-07-15 00:00:00 +0800", "snippet": "反射clazz.getDeclaredConstructor().newInstance() 优于 clazz.newInstance()需要注意的是，如果你想调用的构造函数是 public 的，那么可以直接使用 clazz.newInstance(args) 来创建实例，它与 clazz.getDeclaredConstructor().newInstance(args) 的效果是一样的。但是如果构造函数是 protected、private 或默认的（即没有修饰符），那么就必须使用 getDeclaredConstructor() 方法来获取构造函数，否则会抛出 NoSuchMethodException 异常。Java 8LocalDateTime/LocalDate 加减运算// 在 Java 8 中，可以使用 plus 和 minus 方法实现 LocalDateTime 和 LocalDate 的加减运算。// 例如，计算 7 天后的 LocalDateTime，可以使用以下代码：LocalDateTime now = LocalDateTime.now();LocalDateTime later = now.plusDays(7);// 类似地，如果要计算 7 天前的 LocalDate，可以使用以下代码：LocalDate today = LocalDate.now();LocalDate before = today.minusDays(7);除了 plusDays() 和 minusDays()，还可以使用类似的方法 plusHours()、plusMinutes()、plusSeconds()等，来进行加减运算。Java 并发什么叫做线程自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行地非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。线程阻塞涉及到用户态和内核态切换阻塞线程会释放cpu资源，因而会由内核态切换到用户态，当需要抢占cpu资源的时候就会进入内核态Linuxcurl命令curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。进入用户主目录cd ~获取root权限su，然后输入密码；exit，退出root切换到更目录cd /Linux中的隐藏文件默认以’.’开头请求方式和postman postman发送Ajax——post请求：headers设置：X-Requested-With：XMLHttpRequest，Content-Type：application/x-www-form-urlencoded，在x-www-form-urlencoded中填写数据系统设计 业务往往伴随着参数校验后端与数据库交互 数据库的日期类型是date，后端参数为String时也可以存入，取数据的时候，也可以直接赋值给String，范围查询也可以直接使用日期字符串作为参数，总结似乎存在一个转换器能自动将String转换成数据库类型Date，和将数据库类型Date转换成String，同时月或日只有一位时，数据库会自动补零日期的格式化// SpringBoot提供的日期格式化注解,经测试这个不起作用@DateTimeFormat// jackson提供的注解，如果前后端传的数据都是json格式，那么后台接数据，传数据都可以用@JsonFormat ;@JsonFormat// fastjson提供的注解，兼具上面两个注解的功能@JSONField目前这三个注解还没测试数据库sql default约束不能使用函数 enum枚举类型的用法，字段名 enum(&#39;0&#39;,&#39;1&#39;);，枚举类型不能够起到严格的校验，，但可以保证不会有范围外的数据入库，可参考博文： enum的使用 from后面的派生表必须有别名，否则报错，像下面这段：delete from Person where id not in( select t.id from # from后面的派生表必须有别名，否则报错 ( select min(id) as id from Person group by Email ) t)Spring事务锁 悲观锁：数据库的默认是心啊 共享锁：A事务加了共享锁，其他事务也只能加共享锁，能够读但不能改 排他锁：A事务加了排他锁，其他事务不能加任何锁，所以既不能读也不能写 乐观锁 在更新数据前，判断他人是否修改，如果修改放弃更新否则提交 通常通过版本号判断数据是否修改，如果被修改版本号+1 传播机制编程式事务Spring邮件服务 Spring Boot application.yml邮件服务配置：Spring参数校验 @Validated和@Valid只会在父方法中生效，在实现方法中覆盖方法的参数校验规则会失败且会报错：javax.validation.ConstraintDeclarationException: HV000151: A method overriding another method must not redefine the parameter constraint configuration，所以写参数校验时应该在父方法中定义配置，子类继承就好了，不用修改 在Service中使用参数校验，需要用@Validated和@Valid组合使用，@Validated的作用是：提示Spring为组件开启数据校验功能，相比与@Valid，Validated能为@Controller、@Service、@Component等标注的组件开启数据校验功能、而@Valid只能为Controller组件开启数据校验，但是@Validated不支持嵌套验证import com.flameking.community.entity.User;import org.springframework.validation.annotation.Validated;import javax.validation.Valid;/** * service接口 */@Validatedpublic interface UserService { /** * 根据用户id查询用户信息 * @param id * @return 帖子对应的发帖人的信息 */ User selectUserById(Integer id); /** * 注册用户信息 * @param user * @return */ int register(@Valid User user);}import lombok.Data;import javax.validation.constraints.NotBlank;import java.util.Date;@Datapublic class User { private Integer id; @NotBlank private String username; @NotBlank private String password; private String salt; @NotBlank private String email; private Integer type; private Integer status; private String activationCode; private String headerUrl; private Date createTime;}Spring Boot测试配置 SpringBoot2.4.x之后，改为默认仅集成JUnit5，干掉了兼容JUnit4，所以如果想使用Junit4可以选择使用低版本的（低版本同时兼容Junit5和Junit4），当然也可以直接引入Junit4的依赖Spring Boot数据库配置 数据库配置问题：java.sql.SQLException: No timezone mapping entry for &#39;HongKong&#39;，将其修改为serverTimezone=Asia/Shanghai 数据库serverTimezone配置的不一样可能会使得数据库日期类查询与我们当前时间有差别，比如可能差8个小时，但我们一般设置为serverTimezone=Asia/Shanghai是没有问题的，另外MySQL8.0+版本不写serverTimezone好像会报错，虽然我用的是5.7.33Spring Boot Bean的问题 IDEA，注入的mapper类总是报错：Spring Boot mybatis配置的问题type-aliases-package的作用：sql 输出日志配置：# 如果是 mybatis，mybatis-plus =&amp;gt; mybatismybatis-plus: mapper-locations: classpath:/mapper/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImplSpring Boot Thymeleaf引擎 Thymeleaf命名空间：xmlns:th=”http://www.thymeleaf.org” Thymeleaf的公共页面复用：注意：复用的原理是直接用公共部分替换原来的元素，所以其实原来的元素标签与复用的公共部分标签不同也没问题，样式不同也没问题，因为最后都会替换成公共部分Spring Boot 日志java web 下有好几种日志框架，比如：logback，log4j，log4j2（slj4f 并不是一种日志框架，它相当于定义了规范，实现了这个规范的日志框架就能够用 slj4f 调用）。其中性能最高的应该是 logback 了，而且 springboot 默认使用的也是 logback 日志，在application.yml中我们可以定义日志：在application中我们只能对日志进行简单的配置，实际业务需求中我们可能需要：将不同级别的日志放在不同的文件中，每个项目的日志放在项目文件下；要进行这样复杂的配置就需要使用到xml文件：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;contextName&amp;gt;community&amp;lt;/contextName&amp;gt; &amp;lt;property name=&quot;LOG_PATH&quot; value=&quot;E:/log/&quot;/&amp;gt; &amp;lt;property name=&quot;APPDIR&quot; value=&quot;community&quot;/&amp;gt; &amp;lt;!--日志最终会被存在D:/work/data/community下--&amp;gt; &amp;lt;!-- error file --&amp;gt; &amp;lt;appender name=&quot;FILE_ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt; &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_error.log&amp;lt;/file&amp;gt; &amp;lt;!--该日志命名为log_error.log--&amp;gt; &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt; &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/error/log-error-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt; &amp;lt;!--新生成日志存放的地址--&amp;gt; &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt; &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt; &amp;lt;!--日志内容最大不能超过5MB，否则会另外生成新的文件存储--&amp;gt; &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt; &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt; &amp;lt;!--日志文件的最大存储期限是30天，超过会自动删除--&amp;gt; &amp;lt;/rollingPolicy&amp;gt; &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt; &amp;lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt; &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt; &amp;lt;!--日志输出格式--&amp;gt; &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt; &amp;lt;!--日志字符集utf-8支持中文--&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt; &amp;lt;!-- 在 appender 中设置 filter 子节点，在默认级别上再此过滤，配置 onMatch，onMismatch 可实现只输出单个级别，当前配置只会在文件中输出 error 级别的日志--&amp;gt; &amp;lt;level&amp;gt;error&amp;lt;/level&amp;gt; &amp;lt;!--过滤级别是error--&amp;gt; &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt; &amp;lt;!--如果匹配就接受否则拒绝--&amp;gt; &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- warn file --&amp;gt; &amp;lt;appender name=&quot;FILE_WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt; &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_warn.log&amp;lt;/file&amp;gt; &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt; &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/warn/log-warn-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt; &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt; &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt; &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt; &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt; &amp;lt;/rollingPolicy&amp;gt; &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt; &amp;lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt; &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt; &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt; &amp;lt;level&amp;gt;warn&amp;lt;/level&amp;gt; &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt; &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- info file --&amp;gt; &amp;lt;appender name=&quot;FILE_INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt; &amp;lt;file&amp;gt;${LOG_PATH}/${APPDIR}/log_info.log&amp;lt;/file&amp;gt; &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt; &amp;lt;fileNamePattern&amp;gt;${LOG_PATH}/${APPDIR}/info/log-info-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt; &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt; &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt; &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt; &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt; &amp;lt;/rollingPolicy&amp;gt; &amp;lt;append&amp;gt;true&amp;lt;/append&amp;gt; &amp;lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt; &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt; &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt; &amp;lt;level&amp;gt;info&amp;lt;/level&amp;gt; &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt; &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- console --&amp;gt; &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt; &amp;lt;encoder&amp;gt; &amp;lt;pattern&amp;gt;%d %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt; &amp;lt;charset&amp;gt;utf-8&amp;lt;/charset&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt; &amp;lt;level&amp;gt;debug&amp;lt;/level&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;logger name=&quot;com.flameking.community&quot; level=&quot;debug&quot;/&amp;gt; &amp;lt;!--com.nowcoder.community包下的日志级别是debug，sql 语句的打印结果是 debug 级别，所以这里 level 如果设置 debug 以上的级别，如 info，就不会显示结果，只会有 sql 语句--&amp;gt; &amp;lt;root level=&quot;info&quot;&amp;gt; &amp;lt;!--整个项目下所有的jar包日志级别是info，低于info的debug、trace都不会输出--&amp;gt; &amp;lt;appender-ref ref=&quot;FILE_ERROR&quot;/&amp;gt; &amp;lt;appender-ref ref=&quot;FILE_WARN&quot;/&amp;gt; &amp;lt;appender-ref ref=&quot;FILE_INFO&quot;/&amp;gt; &amp;lt;!--日志级别从大到小：error、warn、info、debug、trace--&amp;gt; &amp;lt;appender-ref ref=&quot;STDOUT&quot;/&amp;gt; &amp;lt;/root&amp;gt;&amp;lt;/configuration&amp;gt;首先这个文件是被Spring Boot自动识别的，我们只需要将其放在resources文件夹下，并将其命名为logback-spring.xml，当然根据不同的环境这些命名都是可以的 logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy，其中 logback-spring.xml、logback.xml 在 Spring Boot 环境的下都是可以的，然后在代码中我们就可以使用 @slf4j 来打印日志了当然也可自定义命名，想要自定义文件名可配置：logging.config 指定配置文件名:logging: config: classpath:logging-config.xml像上面我们的自定义命名是：logging-config.xml什么时候改打印什么日志程序中什么时候打印什么级别的日志logback.xml 获取到 spring boot yaml 文件中的配置SpringMVC转发和重定向 我们在使用重定向的时候往往是为了解耦两个不相关的业务，比如登录和注册、删除记录和查询记录 转发关键词：forward，重定向：redirect 两个不同类型的请求互相转发会报错 请求转发后存入model的参数在目标请求的model中是不存在的，此时需要使用@RequestAttribute注解获取对应的参数 请求转发后依然会进入拦截器SpringMVC请求注解 @RequestBody，这个是专门用来接收前端json数据的，这些数据放在请求体中SpringMVC接收参数 对于checkbox的输入框，在是否选择时，如果后端使用Boolean类型接收，当没选中时，Boolean接收值总是null，而用boolean就没问题 application/x-www-form-urlencoded 的参数，后端使用 JavaBean 接收会出现属性值为空的情况，这时推荐直接用 @RequestParam 配合属性参数接收，而不是 Javabean，同时也可使用原生的 HttpServletRequest 进行接收，好像还可以使用 Map（paramMap） 类型进行接收。SpringMVC拦截器 如果任何一个拦截器的preHandle方法返回false或者抛出异常，或者handler方法中抛出异常都不会执行postHandle方法。mybatis，mapper.xml和mapper.java需要注意的问题使用注解@Param的时机： 在动态SQL中用到了参数作为判断条件，就算SQL对应的的方法有且只有这一个参数，如果不加@Param就会报错，比如使用 if 和 when 动态参数&amp;lt;select id=&quot;getUserById&quot; resultType=&quot;com.flameking.community.User&quot;&amp;gt; select * from user &amp;lt;if test=&quot;id!=null&quot;&amp;gt; where id=#{id} &amp;lt;/if&amp;gt;&amp;lt;/select&amp;gt;@Mapperpublic interface UserMapper { List&amp;lt;User&amp;gt; getUserById(@Param(&quot;id&quot;)Integer id);} 需要为参数指定别名 有多个参数时 mapper.xml中的SQL使用了$，那么参数中也需要@Param注解，$ 会有注入漏洞的问题，但是有的时候你不得不使用$ 符号，例如要传入列名或者表名的时候，这个时候必须要添加 @Param 注解，例如：@Mapperpublic interface UserMapper { List&amp;lt;User&amp;gt; getAllUsers(@Param(&quot;order_by&quot;)String order_by);}&amp;lt;select id=&quot;getAllUsers&quot; resultType=&quot;com.flameking.community.User&quot;&amp;gt; select * from user &amp;lt;if test=&quot;order_by!=null and order_by!=&#39;&#39;&quot;&amp;gt; order by ${order_by} desc &amp;lt;/if&amp;gt;&amp;lt;/select&amp;gt;ajax请求var jsonconst target = $.getJSON(&quot;/power/electron/&quot; + getDateByOffset(offset), (res)=&amp;gt;{ console.log(res) //这里是可以得到JSon数据的 json = res})console.log(json) //但是就算再回调函数中赋值了json，函数外输出时值依然是undefined，因为函数里面的数据是异步加载的json = target.responseJSon因为ajax异步加载的原因，responsJSon我们再函数之外是获取不到的关闭异步的方法：$.ajaxSettings.async = false;但是执行过后记得重新开启起步$.ajaxSettings.async = true;，避免影响到其他的ajax异步请求前缀树过滤敏感词前缀树的特点 根节点为null 除了根节点其余节点只存储一个字符，且每个子节点包含的字符互不相同，如果相同则合并 根节点的子节点到叶节点连起来的字符是一个敏感词 会标记节点是否为叶节点 存在三个指针、指针一遍历前缀树，指针2和指针3作为开始指针和结尾指针遍历字符串前缀树为什么块某种意义上树的分支越多，查询效率越快Redis key只允许String类型 基本数据类型：String、Hash、List、Set、SortedSet Redis为什么这么快：把所有数据存储在内存中，内存操作远比磁盘IO快，采用的IO多路复用技术（多个连接复用同一个线程） 数据持久化： 快照（RDB）：一次性把数据存入磁盘、适合数据体积小，以及每小时备份一次 AOF，存储操作日志，并且对操作日志进行追加存，缺点比较占用空间，数据回复比较慢（取出日志文件并重新执行一遍，比从磁盘中直接取出数据要慢），优点实时较号（因为存日志的操作比较快） Redis学习简单使用简单（主要学会命令操作） 常见应用场景：缓存、排行榜、计数器、社交网络（点赞、点踩、关注、收藏） SortedSet可以使用Range进行分页查询Vue计算属性computed推荐使用计算属性来描述依赖响应式状态的复杂逻辑，我们在计算属性中定义某个方法A，这个方法里面就是复杂的计算逻辑，使用的时候就像调用属性一样直接就行了，注意不用加()占位符特指router中的path定义：/profile/:username，即:username就是占位符，是用来传参的beforeRouteEnterbeforeRouteEnter 函数内部的 this 为 undefined，这是因为 beforeRouteEnter 是在页面创建前就执行的，先执行 beforeRouteEnter，再执行生命周期钩子函数 beforeCreate、created 等。beforeRouteEnter 有三个参数，to、from、nextto：里面是当前页面的路由对象。from：里面是上一个页面的路由对象。next：表示进入当前页面，beforeRouteEnter 内必须执行 next() ，否则无法进入页面，可以传入参数 vm 访问组件实例，相当于 thisbeforeRouteUpdate使用场景：组件复用，路由跳转；beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是该组件被复用时调用（即路由参数不同） // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this`},beforeRouteLeavebeforeRouteLeave (to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this`}全局事件总线this.$bus.$emit(&#39;方法名&#39;, data)，其中data是传递的数据，这个方法会触发某个组件绑定在bus上的方法，然后该组件的方法就会在组件内部触发执行this.$bus.$on(&#39;方法名&#39;, this.method)，第二个参数就是组件在method中定义的方法，第一个参数就是emit触发方法时传递的第一个参数" }, { "title": "Spring概述", "url": "/posts/Spring%E6%A6%82%E8%BF%B0/", "categories": "框架, Spring", "tags": "", "date": "2022-07-13 00:00:00 +0800", "snippet": "一、什么是Spring？1、什么是spring?（面试题）Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。 注：POJO和JavaBean的区别（1）POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器。 （2）通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范）。2、Spring有哪些优点？（面试题）轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。控制反转(IoC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。容器：Spring包含并管理应用程序对象的配置及生命周期。MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。3、Spring 有两个核心部分：IoC 和AOP（1） IoC：控制反转，把创建对象过程交给 Spring进行管理 （2） AOP：面向切面，不修改源代码进行功能增强4、Spring 特点（1） 方便解耦，简化开发 （2） Aop编程支持 （3） 方便程序测试 （4） 方便和其他框架进行整合 （5） 方便进行事务操作 （6） 降低 API开发难度5、目前使用Spring 版本 5.x6、Spring架构图，Spring由哪些模块组成？（面试题）Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在： 核心容器（Core Container） 、 AOP（Aspect Oriented Programming） 和设备支持（Instrmentation） 、 数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图： 图来源于官网，以下各个模块的介绍： 二、第一个Spring项目1、下载Spring，目前版本5.3.4https://repo.spring.io/release/org/springframework/spring/ 下载完成后，解压如下： 2、打开Idea创建一个Java工程，并新建一个普通的Java Model3、进入下载的Spring压缩包下面的libs目录中，将其中的核心jar包导入项目 并导入一个commons-logging-1.2.jar，下载链接： http://commons.apache.org/proper/commons-logging/download_logging.cgi4、创建一个User.java类/** * @Author m.kong * @Date 2021/2/23 上午11:45 * @Version 1.0 */public class User { public void add(){ System.out.println(&quot;add.......&quot;); }}5、在src目录下创建Spring配置文件，bean1.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt; &amp;lt;!--配置User对象创建--&amp;gt; &amp;lt;bean id=&quot;user&quot; class=&quot;com.micah.spring.User&quot;/&amp;gt;&amp;lt;/beans&amp;gt;6、测试，BeanTest.java@Test public void testAdd() { //1 加载 spring 配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //2 获取配置创建的对象 User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user); user.add(); } 这样就实现了将对象的创建过程，交给了Spring。" }, { "title": "Spring5新特性", "url": "/posts/Spring5%E6%96%B0%E7%89%B9%E6%80%A7/", "categories": "框架, Spring", "tags": "", "date": "2022-07-13 00:00:00 +0800", "snippet": "一、新的功能Spring Framework 5.0是在Spring Framework 4.0之后将近四年内一次重大的升级。 在这个时间框架内，主要的发展之一就是Spring Boot项目的演变。1、概述Spring Framework 5.0的最大特点之一是响应式编程（Reactive Programming）。 响应式编程核心功能和对响应式endpoints的支持可通过Spring Framework 5.0中获得。 重要变动如下列表所示：常规升级 对JDK 9运行时兼容性 在Spring Framework代码中使用JDK 8特性 响应式编程支持 函数式Web框架 Jigsaw的Java模块化 对Kotlin支持 舍弃的特性2、基于Java8兼容Java9整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方法在代码库中删除使用的一些Java 8特性如下： 核心Spring接口中的Java 8 static 方法 基于Java 8反射增强的内部代码改进 在框架代码中使用函数式编程——lambdas表达式和stream流3、支持响应式编程响应式编程是Spring Framework 5.0最重要的功能之一。微服务通常基于事件通信的架构构建。 应用程序被设计为对事件（或消息）做出反应。响应式编程提供了一种可选的编程风格，专注于构建应对事件的应用程序。虽然Java 8没有内置的响应式性编程支持，但是有一些框架提供了对响应式编程的支持：Reactive Streams：尝试定义与语言无关的响应性API。 Reactor：Spring Pivotal团队提供的响应式编程的Java实现。 Spring WebFlux：启用基于响应式编程的Web应用程序的开发。 提供类似于Spring MVC的编程模型。4、函数式Web框架除了响应式特性之外，Spring 5还提供了一个函数式Web框架。函数式Web框架提供了使用函数式编程风格来定义endpoints的功能。二、Spring 5之日志框架1、Spring 5.0 框架自带了通用的日志封装（1） Spring5已经移除 Log4jConfigListener，官方建议使用 Log4j2 （2） Spring5框架整合 Log4j2第一步引入jar 包 第二步：创建log4j2.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&amp;lt;!--日志级别以及优先级排序: OFF&amp;gt; FATAL&amp;gt; ERROR&amp;gt; WARN&amp;gt; INFO&amp;gt; DEBUG&amp;gt; TRACE&amp;gt; ALL--&amp;gt;&amp;lt;!--Configuration后面的 status用于设置 log4j2自身内部的信息输出，可以不设置， 当设置成trace时，可以看到log4j2内部各种详细输出--&amp;gt;&amp;lt;configuration status=&quot;DEBUG&quot;&amp;gt; &amp;lt;!--先定义所有的 appender--&amp;gt; &amp;lt;appenders&amp;gt; &amp;lt;!--输出日志信息到控制台--&amp;gt; &amp;lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt; &amp;lt;!--控制日志输出的格式--&amp;gt; &amp;lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&amp;gt; &amp;lt;/console&amp;gt; &amp;lt;/appenders&amp;gt; &amp;lt;!--然后定义 logger，只有定义 logger并引入的 appender，appender才会生效--&amp;gt; &amp;lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root作为默认的日志输出--&amp;gt; &amp;lt;loggers&amp;gt; &amp;lt;root level=&quot;info&quot;&amp;gt; &amp;lt;appender-ref ref=&quot;Console&quot;/&amp;gt; &amp;lt;/root&amp;gt; &amp;lt;/loggers&amp;gt;&amp;lt;/configuration&amp;gt;2、Spring5 框架核心容器支持@Nullable 注解（1）@Nullable注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空（2）注解用在方法上面，方法返回值可以为空 （3）注解使用在方法参数里面，方法参数可以为空 （4）注解使用在属性上面，属性值可以为空 3、Spring5 核心容器支持函数式风格 GenericApplication Context//函数式风格创建对象，交给 spring 进行管理@Testpublic void testGenericApplicationContext() { //1 创建 GenericApplicationContext 对象 GenericApplicationContext context = new GenericApplicationContext(); //2 调用 context 的方法对象注册 context.refresh(); context.registerBean(&quot;user1&quot;,User.class,() -&amp;gt; new User()); //3 获取在 spring 注册的对象 // User user = (User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;); User user = (User)context.getBean(&quot;user1&quot;); System.out.println(user);}4、Spring5 支持整合 JUnit5（1）整合 JUnit4第一步 引入 Spring 相关针对测试依赖 第二步 创建测试类，使用注解方式完成@RunWith(SpringJUnit4ClassRunner.class) //单元测试框架@ContextConfiguration(&quot;classpath:bean1.xml&quot;) //加载配置文件 public class JTest4 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); }}（2）整合Junit5第一步：引入jar包 第二步： 创建测试类，使用注解方式完成@ExtendWith(SpringExtension.class) @ContextConfiguration(&quot;classpath:bean1.xml&quot;) public class JTest5 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); }}第三步： 使用一个复合注解代替上面2个注解完成整合@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)public class JTest5{ @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); }}三、Spring Web Flux1、Spring Web Flux 介绍(1）是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流程响应式编程出现的框架。 （2）使用传统 web框架，比如 SpringMVC，这些基于 Servlet容器，WebFlux是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet 3.1以后才支持，核心是基于 Reactor的相关 API实现的。（3）解释什么是异步非阻塞 异步和同步 非阻塞和阻塞 上面都是针对对象不一样** 异步和同步针对调用者，调用者发送请求，如果等着对方回应之后才去做其他事情就是同步，如果发送请求之后不等着对方回应就去做其他事情就是异步** 阻塞和非阻塞针对被调用者，被调用者受到请求之后，做完请求任务之后才给出反馈就是阻塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞（4）WebFlux特点：第一 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor为基础实现响应式编程 第二 函数式编程：Spring5框架基于 java8，Webflux使用 Java8函数式编程方式实现路由请求（5）比较 SpringMVC 第一 两个框架都可以使用注解方式，都运行在 Tomet 等容器中 第二 SpringMVC 采用命令式编程，Webflux 采用异步响应式编程2、响应式编程（Java 实现）（1）什么是响应式编程响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变（2）Java8及其之前版本 提供的观察者模式两个类 Observer和 Observablepublic class ObserverDemo extends Observable{ public static void main(String[] args) { ObserverDemo observer = new ObserverDemo();//添加观察者 observer.addObserver((o,arg)-&amp;gt;{ System.out.println(&quot;发生变化&quot;); }); observer.addObserver((o,arg)-&amp;gt;{ System.out.println(&quot;手动被观察者通知，准备改变&quot;); }); observer.setChanged(); //数据变化 observer.notifyObservers(); //通知 }}3、响应式编程（Reactor 实现）（1）响应式编程操作中，Reactor是满足 Reactive规范框架（2）Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作符。Flux对象实现发布者，返回 N个元素；Mono实现发布者，返回 0或者 1个元素（3）Flux和 Mono都是数据流的发布者，使用 Flux和 Mono都可以发出三种数据信号： 元素值，错误信号，完成信号，错误信号和完成信号都代表终止信号，终止信号用于告诉订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者 （4）代码演示 Flux和 Mono第一步 引入依赖&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;reactor-core&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;3.1.5.RELEASE&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;第二步 编程代码public static void main(String[] args) { //just 方法直接声明 Flux.just(1,2,3,4); Mono.just(1);//其他的方法 Integer[] array = { 1,2,3,4}; Flux.fromArray(array); List&amp;lt;Integer&amp;gt; list = Arrays.asList(array); Flux.fromIterable(list); Stream&amp;lt;Integer&amp;gt; stream = list.stream(); Flux.fromStream(stream);}（5）三种信号特点 错误信号和完成信号都是终止信号，不能共存的 如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流 如果没有错误信号，没有完成信号，表示是无限数据流（6）调用 just或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生的 （7）操作符 对数据流进行一道道操作，成为操作符，比如工厂流水线 第一 map 元素映射为新元素 第二 flatMap 元素映射为流 把每个元素转换流，把转换之后多个流合并大的流 4、SpringWebflux 执行流程和核心 APISpring Web Flux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻塞的框架 （1）Netty BIO NIO： （2）Spring WebFlux 执行过程和 SpringMVC 相似的 Spring WebFlux核心控制器 DispatchHandler，实现接口 WebHandler 接口 WebHandler有一个方法 （3）SpringWebflux 里面 DispatcherHandler，负责请求的处理 * HandlerMapping：请求查询到处理的方法 * HandlerAdapter：真正负责请求处理 * HandlerResultHandler：响应结果处理（4）SpringWebflux 实现函数式编程，两个接口：RouterFunction（路由处理） 和 HandlerFunction（处理函数）5、SpringWebflux（基于注解编程模型）SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型 使用注解编程模型方式，和之前 SpringMVC 使用相似的，只需要把相关依赖配置到项目中，SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器（1）第一步 创建 SpringBoot 工程，引入 Webflux 依赖 （2）第二步：设置启动端口号 （3）创建包和相关类 /** * @Author m.kong * @Date 2021/3/2 上午10:37 * @Version 1.0 * @Description 用户操作接口 */public interface UserService { /** * 根据id查询用户 * @param id 主键 * @return 指定id的用户 */ Mono&amp;lt;User&amp;gt; getUserById(int id); /** * 查询所有用户 * @return 用户集合 */ Flux&amp;lt;User&amp;gt; getAllUser(); /** * 添加一个用户 * @param user 插入的用户 * @return 无返回值 */ Mono&amp;lt;Void&amp;gt; saveUserInfo(Mono&amp;lt;User&amp;gt; user);}package com.micah.webflux.service.impl;import com.micah.webflux.entity.User;import com.micah.webflux.service.UserService;import org.springframework.stereotype.Service;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import java.util.HashMap;import java.util.Map;/** * @Author m.kong * @Date 2021/3/2 上午10:43 * @Version 1.0 */@Servicepublic class UserServiceImpl implements UserService { // 创建一个Map集合，来存储模拟数据 private final Map&amp;lt;Integer, User&amp;gt; users = new HashMap&amp;lt;&amp;gt;(); public UserServiceImpl() { this.users.put(1, new User(&quot;Micah&quot;,&quot;男&quot;,22)); this.users.put(2, new User(&quot;Maruko&quot;,&quot;女&quot;,19)); } @Override public Mono&amp;lt;User&amp;gt; getUserById(int id) { return Mono.justOrEmpty(this.users.get(id)); } @Override public Flux&amp;lt;User&amp;gt; getAllUser() { return Flux.fromIterable(this.users.values()); } @Override public Mono&amp;lt;Void&amp;gt; saveUserInfo(Mono&amp;lt;User&amp;gt; userMono) { return userMono.doOnNext(person -&amp;gt; { // 向map中存放值 int id = users.size() + 1; users.put(id, person); }).thenEmpty(Mono.empty()); }}/** * @Author m.kong * @Date 2021/3/2 上午11:20 * @Version 1.0 */@RestControllerpublic class UserController { @Autowired private UserService userService; @GetMapping(&quot;/user/{id}&quot;) public Mono&amp;lt;User&amp;gt; getUserId(@PathVariable int id){ return userService.getUserById(id); } @GetMapping(&quot;/user&quot;) public Flux&amp;lt;User&amp;gt; getUsers(){ return userService.getAllUser(); } @GetMapping(&quot;/save_user&quot;) public Mono&amp;lt;Void&amp;gt; saveUser(@RequestBody User user) { Mono&amp;lt;User&amp;gt; userMono = Mono.just(user); return userService.saveUserInfo(userMono); }}说明： SpringMVC 方式实现，同步阻塞的方式，基于 SpringMVC+Servlet+Tomcat SpringWebFlux 方式实现，异步非阻塞 方式，基于 SpringWebFlux+Reactor+Netty。6、Spring WebFlux（基于函数式编程模型） （1）在使用函数式编程模型操作时候，需要自己初始化服务器 （2）基于函数式编程模型时候，有两个核心接口：RouterFunction（实现路由功能，请求转发给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）。核心任务定义两个函数式接口的实现并且启动需要的服务器。 （3）Spring WebFlux 请 求 和 响 应 不 再 是 ServletRequest 和 ServletResponse ，而是ServerRequest 和 ServerResponse第一步 把注解编程模型工程复制一份 ，保留 entity 和 service 内容 第二步 创建 Handler（具体实现方法）/** * @Author m.kong * @Date 2021/3/9 上午9:51 * @Version 1 * @Description */public class UserHandler { @Autowired private final UserService userService; public UserHandler(UserService userService){ this.userService = userService; } //根据 id 查询 public Mono&amp;lt;ServerResponse&amp;gt; getUserById(ServerRequest request) { //获取 id 值 int userId = Integer.valueOf(request.pathVariable(&quot;id&quot;)); //空值处理 Mono&amp;lt;ServerResponse&amp;gt; notFound = ServerResponse.notFound().build(); //调用 service 方法得到数据 Mono&amp;lt;User&amp;gt; userMono = this.userService.getUserById(userId); //把 userMono 进行转换返回 //使用 Reactor 操作符 flatMap return userMono .flatMap(person -&amp;gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON) .body(fromObject(person))) .switchIfEmpty(notFound); } //查询所有 public Mono&amp;lt;ServerResponse&amp;gt; getAllUsers() { //调用 service 得到结果 Flux&amp;lt;User&amp;gt; users = this.userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(users,User.cl ass); } //添加 public Mono&amp;lt;ServerResponse&amp;gt; saveUser(ServerRequest request) { //得到 user 对象 Mono&amp;lt;User&amp;gt; userMono = request.bodyToMono(User.class); return ServerResponse.ok().build(this.userService.saveUserInfo(userMono)); }}第三步 初始化服务器，编写 Router 创建路由的方法//1、创建 Router 路由 public RouterFunction&amp;lt;ServerResponse&amp;gt; routingFunction() { //创建 hanler 对象 UserService userService = new UserServiceImpl(); UserHandler handler = new UserHandler(userService); //设置路由 return RouterFunctions.route( GET(&quot;/users/{id}&quot;).and(accept(APPLICATION_JSON)),handler::getUserById) .andRoute(GET(&quot;/users&quot;).and(accept(APPLICATION_JSON)),handler::get AllUsers);} 创建服务器，完成适配//2 创建服务器完成适配 public void createReactorServer() { //路由和 handler 适配 RouterFunction&amp;lt;ServerResponse&amp;gt; route = routingFunction(); HttpHandler httpHandler = toHttpHandler(route); ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler); //创建服务器 HttpServer httpServer = HttpServer.create(); httpServer.handle(adapter).bindNow();} 最终调用public static void main(String[] args) throws Exception{ Server server = newServer(); server.createReactorServer(); System.out.println(&quot;enter to exit&quot;); System.in.read();}（4）使用 WebClient 调用public class Client { public static void main(String[] args) { //调用服务器地址 WebClient webClient = WebClient.create(&quot;http://127.0.0.1:5794&quot;); //根据 id 查询 String id = &quot;1&quot;; User userresult = webClient.get().uri(&quot;/users/{id}&quot;, id).accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(User .class) .block(); System.out.println(userresult.getName());//查询所有 Flux&amp;lt;User&amp;gt; results = webClient.get().uri(&quot;/users&quot;) .accept(MediaType.APPLICATION_JSON).retrieve().bodyToFlux(User .class); results.map(stu -&amp;gt; stu.getName()) .buffer().doOnNext(System.out::println).blockFirst(); }}" }, { "title": "Spring 事务管理", "url": "/posts/Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/", "categories": "框架, Spring", "tags": "", "date": "2022-07-13 00:00:00 +0800", "snippet": "什么是事务？事务的定义 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。 案例分析如上述例子，Micah 给 Maruko 转账，只有在转账成功的情况下，Micah 的账户余额才会减少，Maruko 的账户余额增加，不存在 Micah 账户的余额减少了，而Maruko的账户余额却不变。要么转账成功，两边余额都改变；要么转账失败，两边余额都保持不变。事务的四大特性 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所处的业务处于一致的状态，即数据能够对的上。 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。Spring 事务管理编程式事务管理编程式事务管理是侵入性事务管理，使用 TransactionTemplate 或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring 推荐使用 TransactionTemplate。声明式事务管理声明式事务管理建立在 AOP 之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。显然声明式事务管理要优于编程式事务管理，这正是 Spring 倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。搭建事务操作环境创建数据表Service 和 Dao 层逻辑service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource@Servicepublic class UserServiceImpl extends UserService { @Autowired private UserDao userDao; //转账的方法 public void accountMoney() { //lucy 少 100 userDao.reduceMoney(); //mary 多 100 userDao.addMoney(); }}@Repositorypublic class UserDaoImpl implements UserDao { @Autowired private JdbcTemplate jdbcTemplate; //少钱 @Override public void reduceMoney() { String sql = &quot;update t_account set money=money-? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;lucy&quot;); } //多钱 @Override public void addMoney() { String sql = &quot;update t_account set money=money+? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;mary&quot;); }}模拟方法内部出现异常的情况这种情况下就非常适合使用事务管理的方法，操作方法如下：在 Service 层具体的 Code 见下方解析。事务管理在 Spring 进行事务管理操作，有两种方式：编程式事务管理和声明式事务管理（推荐使用）声明式事务管理的实现方式：（1）基于注解方式（使用） （2）基于xml配置方式提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类注解式事务管理操作（1）在Spring配置文件中，添加事务管理器，并开启事务注解这里需要注意，开启事务注解需要使用名称空间txxmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;&amp;lt;!--创建事务管理器--&amp;gt; &amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt; &amp;lt;!--注入数据源--&amp;gt; &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!--开启事务注解--&amp;gt; &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;（2）在service类或者类方法上中添加transactional注解 @Transactional，这个注解添加到类上面，也可以添加方法上面 如果把这个注解添加类上面，这个类里面所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务@Service@Transactional // 事务注解，类上面或者里面的方法上添加注解public class UserService { @Autowired private UserDao userDao;}在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数 事务的传播行为 事务的传播性一般用在事务嵌套的场景，比如一个事务方法里面调用了另外一个事务方法，那么两个方法是各自作为独立的方法提交还是内层的事务合并到外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。事务的传播行为有以下七种：PROPAGATION_REQUIRED：Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行PROPAGATION_REQUES_NEW：该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可PROPAGATION_SUPPORT：如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务 PROPAGATION_NOT_SUPPORT该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码PROPAGATION_NEVER：该传播机制不支持外层事务，即如果外层有事务就抛出异常PROPAGATION_MANDATORY：与NEVER相反，如果外层没有事务，则抛出异常PROPAGATION_NESTED该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。传播规则回答了这样一个问题：一个新的事务应该被启动还是被挂起，或者是一个方法是否应该在事务性上下文中运行。事务的隔离级别概述事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度，可以把事务的隔离级别想象为这个事务对于事物处理数据的自私程度。三个读问题在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：（1）脏读（Dirty read） 脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。 （2）不可重复读（Nonrepeatable read） 不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。不可重复读重点在修改。 （3）幻读（Phantom reads） 幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。幻读重点在新增或删除。隔离级别在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁表）。完全隔离要求事务相互等待来完成工作，会阻碍并发。因此，可以根据业务场景选择不同的隔离级别。 timeout：超时时间（1）事务需要在一定时间内进行提交，如果不提交进行回滚 （2）默认值是 -1，设置时间以秒单位进行计算5、readOnly：是否只读（1）读：查询操作，写：添加修改删除操作 （2）readOnly默认值 false，表示可以查询，可以添加修改删除操作 （3）设置 readOnly值是 true，设置成 true之后，只能查询rollbackFor：回滚设置出现哪些异常进行事务回滚。 @Transactional 不指定 rollbackFor 会怎么样？如果在@Transactional注解中不指定rollbackFor属性，那么默认情况下，当事务执行过程中抛出任何RuntimeException或者Error时，事务都会自动回滚。而当抛出受检异常（checked exception）时，默认情况下是不回滚的。 Error 和 Exception 都是 Throwable的子类。 RuntimeException 和其子类都属于运行时异常。Error 类和其子类都属于错误类。RuntimeException 及其子类 和 Error类及其子类 属于非受检异常，除此之外的 其他 Throwable 子类属于受检异常。举个例子，假设有一个service方法使用了@Transactional注解，但是没有指定rollbackFor属性：@Transactionalpublic void doSomething() throws MyCheckedException { // execute some database operation throw new MyCheckedException();}在上面的代码中，如果MyCheckedException是一个非受检异常，那么在执行doSomething()方法的过程中，如果发生了这个异常，那么这个方法所在的事务不会回滚，即使异常抛出后方法未正常执行完毕，数据库的操作也不会回滚。如果想要让这个方法所在的事务回滚，需要将MyCheckedException添加到rollbackFor属性中：@Transactional(rollbackFor = MyCheckedException.class)public void doSomething() throws MyCheckedException { // execute some database operation throw new MyCheckedException();}当MyCheckedException被添加到rollbackFor属性中后，如果在执行doSomething()方法的过程中抛出了这个异常，那么这个方法所在的事务就会回滚。需要注意的是，如果方法内部捕获了异常并且没有重新抛出，事务也不会回滚，因为在事务管理的方法内部捕获异常会使得异常被处理掉，不会再向外抛出，因此事务也不会回滚。如果需要让事务回滚，可以在捕获异常后使用throw语句重新抛出异常。noRollbackFor：不回滚设置出现哪些异常不进行事务回滚两种事务管理XML声明式事务管理（1）配置事务管理器 （2）配置通知 （3）配置切入点和切面&amp;lt;!--1 创建事务管理器--&amp;gt; &amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt; &amp;lt;!--注入数据源--&amp;gt; &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!--2 配置通知--&amp;gt; &amp;lt;tx:advice id = &quot;tx_advice&quot;&amp;gt; &amp;lt;!--配置事务的一些相关参数--&amp;gt; &amp;lt;tx:attributes&amp;gt; &amp;lt;!--指定哪种规则的方法上添加事务--&amp;gt; &amp;lt;tx:method name=&quot;account*&quot; propagation=&quot;REQUIRED&quot;/&amp;gt; &amp;lt;/tx:attributes&amp;gt; &amp;lt;/tx:advice&amp;gt; &amp;lt;!--3 配置切入点和切面--&amp;gt; &amp;lt;aop:config&amp;gt; &amp;lt;!--配置切入点--&amp;gt; &amp;lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.micah.spring.service.UserService.*(..))&quot;/&amp;gt; &amp;lt;!--配置切面--&amp;gt; &amp;lt;aop:advisor advice-ref=&quot;tx_advice&quot; pointcut-ref=&quot;pt&quot;/&amp;gt; &amp;lt;/aop:config&amp;gt;完全注解声明式事务管理（1）创建配置类，用来替代配置文件/** * @Author m.kong * @Date 2021/3/1 下午2:58 * @Version 1.0 */@Configuration@ComponentScan(basePackages = &quot;com.micah&quot;) // 组建扫描@EnableTransactionManagement //开启事务public class TxConfig { /** * 创建数据库连接池 */ @Bean public DruidDataSource getDruidDataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); druidDataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;); druidDataSource.setUsername(&quot;root&quot;); druidDataSource.setPassword(&quot;jlq000321&quot;); return druidDataSource; } /** * 创建jdbcTemplate对象 */ @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource){ // 到ioc容器中，根据类型找到dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); // 注入dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; } /** * 创建事务管理器 */ @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource){ DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; }}" }, { "title": "Spring JDBC数据访问", "url": "/posts/Spring-JDBC%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/", "categories": "框架, Spring", "tags": "", "date": "2022-07-13 00:00:00 +0800", "snippet": "一、Spring JDBC概述1、什么是JDBC Template？之前我们采用的是手动封装JdbcTemplate，其好处是通过(sql语句+参数)模板化了编程。而真正的JdbcTemplate类，是Spring框架为我们写好的。它是 Spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。除了JdbcTemplate，Spring 框架还为我们提供了很多的操作模板类。操作关系型数据的：JdbcTemplate和HibernateTemplate。 操作 nosql 数据库的：RedisTemplate。 操作消息队列的：JmsTemplate。2、Spring JDBC 能做什么？3、JDBC访问数据的方法 JdbcTemplate：是经典且最受欢迎的Spring JDBC方法。这种“最低级别”的方法以及其他所有方法都在幕后使用JdbcTemplate。 NamedParameterJdbcTemplate：封装JdbcTemplate以提供命名参数，而不是传统的JDBC ‘?’ 占位符。当您有多个SQL语句参数时，此方法可提供更好的文档编制和易用性。 SimpleJdbcInsert和SimpleJdbcCall：优化数据库元数据以限制必要的配置量。这种方法简化了编码，因此您只需要提供表或过程的名称，并提供与列名称匹配的参数映射即可。仅当数据库提供足够的元数据时，此方法才有效。如果数据库不提供此元数据，则必须提供参数的显式配置。 RDBMS对象：（包括MappingSqlQuery，SqlUpdate和StoredProcedure）要求您在数据访问层初始化期间创建可重用且线程安全的对象。此方法以JDO Query为模型，其中您定义查询字符串，声明参数并编译查询。一旦你这样做，execute(…​)，update(…​)，和findObject(…​)方法可以用不同的参数值多次调用。4、Spring框架的JDBC抽象框架由四个不同的软件包组成 core：：org.springframework.jdbc.core程序包包含JdbcTemplate该类及其各种回调接口，以及各种相关类。org.springframework.jdbc.core.simple包含SimpleJdbcInsert和 SimpleJdbcCall类。另一个名为org.springframework.jdbc.core.namedparam的子程序包包含NamedParameterJdbcTemplate 该类和相关的支持类。 datasource：该org.springframework.jdbc.datasource软件包包含一个易于DataSource访问的实用程序类 和各种简单的DataSource实现，可用于在Java EE容器之外测试和运行未修改的JDBC代码。org.springfamework.jdbc.datasource.embedded支持使用Java数据库引擎（例如HSQL，H2和Derby）创建嵌入式数据库。 object：org.springframework.jdbc.object程序包包含将RDBMS查询，更新和存储过程表示为线程安全的可重用对象的类。尽管查询返回的对象自然会与数据库断开连接，但此方法由JDO建模。较高级别的JDBC抽象取决于org.springframework.jdbc.core程序包中的较低级别的抽象。 support：org.springframework.jdbc.support提供了SQLException翻译功能和一些实用程序类。JDBC处理期间引发的异常将转换为org.springframework.dao包中定义的异常。这意味着使用Spring JDBC抽象层的代码不需要实现JDBC或RDBMS特定的错误处理。所有翻译的异常均未选中，这使您可以选择捕获可从中恢复的异常，同时将其他异常传播到调用方。二、使用JBDC Template1、新建Module chapter05_jdbc_template，并引入相关jar包在源代码里提供了相关jar包，源代码： https://github.com/MicahKong/spring_source_code 2、配置数据库链接池新建bean1.xml, 配置数据库连接池，并配置JDBC Template对象，注入datasource；最后开启组件扫描（1）代码配置DriverManagerDataSource dataSource = new DriverManagerDataSource();dataSource.setDriverClassName(&quot;org.hsqldb.jdbcDriver&quot;);dataSource.setUrl(&quot;jdbc:hsqldb:hsql://localhost:&quot;);dataSource.setUsername(&quot;sa&quot;);dataSource.setPassword(&quot;&quot;);（2）xml配置&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt; &amp;lt;!--开启组件扫描--&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.micah&quot;/&amp;gt; &amp;lt;!-- 数据库连接池 --&amp;gt; &amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;root&quot; /&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;root&quot; /&amp;gt; &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!--创建jdbcTemplate对象--&amp;gt; &amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt; &amp;lt;!--注入--&amp;gt; &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt; &amp;lt;/bean&amp;gt;&amp;lt;/beans&amp;gt;3、创建Service和Dao，并在Dao中注入JDBC Template对象/** * @Author m.kong * @Date 2021/2/28 下午9:32 * @Version 1.0 */public class Book { private int userId; private String username; private String userStatus; public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getUserStatus() { return userStatus; } public void setUserStatus(String userStatus) { this.userStatus = userStatus; }}/** * @Author m.kong * @Date 2021/2/28 下午9:19 * @Version 1.0 */@Servicepublic class BookService { @Autowired private BookDao bookDao; public void addBook(Book book){ bookDao.add(book); } public void updateBook(Book book){ bookDao.update(book); } public void deleteBook(String id){ bookDao.deleteBook(id); } public void selectCount(){ int count = bookDao.selectCount(); System.out.println(count); } public void batchAddBook(List&amp;lt;Object[]&amp;gt; books){ bookDao.batchAddBook(books); } public void batchUpdateBook(List&amp;lt;Object[]&amp;gt; books) { bookDao.batchUpdateBook(books); } public void batchDelBook(List&amp;lt;Object[]&amp;gt; ids) { bookDao.batchDelBook(ids); }}/** * @Author m.kong * @Date 2021/2/28 下午9:20 * @Version 1.0 */public interface BookDao { /** * 添加add */ void add(Book book); /** * update */ void update(Book book); /** * delete */ void deleteBook(String id); /** * count(*) */ int selectCount(); /** * batchAddBooks * @param books */ void batchAddBook(List&amp;lt;Object[]&amp;gt; books); void batchUpdateBook(List&amp;lt;Object[]&amp;gt; books); void batchDelBook(List&amp;lt;Object[]&amp;gt; ids);}（1）添加数据 第一个参数：sql语句 第二个参数：@Nullable允许为空，设置SQL语句中的参数值（2）修改数据和删除数据方法同上（3）返回某个具体的值 第一个参数是SQL语句，没什么可多说的，第二个参数是返回值的Class类型，如果是String类型，就是String.class（4）返回一个对象 ⚫ 第一个参数：sql语句 ⚫ 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装 ⚫ 第三个参数：sql语句值（5）查询返回集合 ⚫ 第一个参数：sql语句 ⚫ 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装 ⚫ 第三个参数：sql语句值（6）实现批量操作 第一个参数是SQL语句，第二个参数是要添加的集合数据/** * @Author m.kong * @Date 2021/2/28 下午9:20 * @Version 1.0 */@Repositorypublic class BookDaoImpl implements BookDao{ /** * 批量添加数据 * @param books */ @Override public void batchAddBook(List&amp;lt;Object[]&amp;gt; books) { String sql = &quot;Insert into t_user values(?,?,?)&quot;; int[] res = jdbcTemplate.batchUpdate(sql, books); System.out.println(Arrays.toString(res)); } /** * 批量删除 */ @Override public void batchDelBook(List&amp;lt;Object[]&amp;gt; ids) { String sql = &quot;DELETE FROM t_user WHERE user_id = ?&quot;; int[] res = jdbcTemplate.batchUpdate(sql, ids); System.out.println(Arrays.toString(res)); } /** * 批量更新数据 * @param books */ @Override public void batchUpdateBook(List&amp;lt;Object[]&amp;gt; books) { String sql = &quot;Update t_user set username = ?,ustates = ? where user_id = ?&quot;; int[] res = jdbcTemplate.batchUpdate(sql, books); System.out.println(Arrays.toString(res)); } /** * 注入JdbcTemplate */ @Autowired private JdbcTemplate jdbcTemplate; /** * 添加方法 * @param book 书 */ @Override public void add(Book book) { Object[] args = { book.getUserId(),book.getUsername(),book.getUserStatus()}; int update = jdbcTemplate.update(&quot;insert into t_user values (?,?,?)&quot;, args); System.out.println(&quot;update successful!&quot; + update); } @Override public void update(Book book) { Object[] args = { book.getUsername(),book.getUserStatus(),book.getUserId()}; int update = jdbcTemplate.update(&quot;update t_user set username = ?,ustates = ? where user_id = ?&quot;, args); System.out.println(&quot;update successful!&quot; + update); } @Override public void deleteBook(String id) { int update = jdbcTemplate.update(&quot;delete from t_user where user_id = ?&quot;, id); System.out.println(&quot;delete successful!&quot; + update); } @Override public int selectCount() { String sql = &quot;select count(*) from t_user&quot;; int count = jdbcTemplate.queryForObject(sql,Integer.class); return count; }}" }, { "title": "Spring Beans", "url": "/posts/Spring-Beans/", "categories": "框架, Spring", "tags": "", "date": "2022-07-13 00:00:00 +0800", "snippet": "一、概念与定义1、什么是Spring beans?Bean: 在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是由Spring IoC容器实例化，组装和以其他方式管理的对象。否则，bean仅仅是应用程序中许多对象之一。Bean及其之间的依赖关系反映在容器使用的配置元数据中。 Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IoC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。 在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”, 如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。 2、 一个 Spring Bean 定义包含什么？一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。3、如何给Spring 容器提供配置元数据?这里有三种重要的方法给Spring 容器提供配置元数据。（1）XML配置文件。 （2）基于注解的配置。 （3） 基于Java的配置二、Spring Beans注入属性（XML）1、使用xml配置注入属性，set方式注入属性，有参构造方法注入，下面演示2种方式注入属性Step 1: 创建Book.java，Orders.java类/** * @Author m.kong * @Date 2021/2/23 下午3:07 * @Version 1.0 */public class Book { /** * 创建属性 */ private String bname; private String bauthor; /** * 创建对应的set方法 */ public void setBname(String bname) { this.bname = bname; } public void setBauthor(String bauthor) { this.bauthor = bauthor; } public void testDemo(){ System.out.println(bname + &quot;::&quot; + bauthor ); }}/** * @Author m.kong * @Date 2021/2/23 下午3:50 * @Version 1.0 */public class Orders { private String oname; private String address; public Orders(String oname, String address) { this.oname = oname; this.address = address; } public void orderTest(){ System.out.println(oname + &quot;::&quot; + address); }}Step 2: 配置Book，Order对象创建（创建对象时候，默认也是执行无参数构造方法完成对象创建）&amp;lt;!--配置Book对象创建,并注入属性 id属性：唯一标识 class属性：类全路径（包类路径） set方法注入属性--&amp;gt; &amp;lt;bean id=&quot;book&quot; class=&quot;com.micah.spring.Book&quot;&amp;gt; &amp;lt;!--使用Property来进行属性注入--&amp;gt; &amp;lt;property name=&quot;bname&quot; value=&quot;上海...研究所&quot;/&amp;gt; &amp;lt;property name=&quot;bauthor&quot; value=&quot;Micah&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!--有参构造方法注入属性--&amp;gt; &amp;lt;bean id=&quot;orders&quot; class=&quot;com.micah.spring.Orders&quot;&amp;gt; &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;haha&quot;/&amp;gt; &amp;lt;constructor-arg index=&quot;1&quot; value=&quot;hahhahahahha&quot;/&amp;gt; &amp;lt;/bean&amp;gt;Step 3: 测试类中添加测试方法：@Testpublic void testBookInsert(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); Book book = context.getBean(&quot;book&quot;, Book.class); book.testDemo(); System.out.println(book);}@Test public void testOrderInsert(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); Orders orders = context.getBean(&quot;orders&quot;, Orders.class); orders.orderTest(); System.out.println(orders); } 2、使用P名称空间注入（了解）使用 p 名称空间注入，可以简化基于 xml 配置方式第一步 添加 p 名称空间在配置文件中第一步：引入P名称空间&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;第二步 进行属性注入，在 bean 标签里面进行操作&amp;lt;!--2 set 方法注入属性--&amp;gt;&amp;lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;九阳神功&quot;p:bauthor=&quot;无名氏&quot;&amp;gt;&amp;lt;/bean&amp;gt;3、注入一些特殊类型的属性（1）字面量&amp;lt;!--null 值--&amp;gt;&amp;lt;property name=&quot;address&quot;&amp;gt; &amp;lt;null/&amp;gt;&amp;lt;/property&amp;gt;（2）属性值包含特殊符号&amp;lt;!--属性值包含特殊符号 1 把&amp;lt;&amp;gt;进行转义 &amp;amp;lt; &amp;amp;gt; 2 把带特殊符号内容写到CDATA --&amp;gt;&amp;lt;property name=&quot;address&quot;&amp;gt; &amp;lt;value&amp;gt;&amp;lt;![CDATA[&amp;lt;&amp;lt;南京&amp;gt;&amp;gt;]]&amp;gt;&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;4、注入外部Beana. 创建两个类 service类和 dao类 b. 在 service调用 dao里面的方法/** * @Author m.kong * @Date 2021/2/23 下午8:45 * @Version 1.0 */public class UserService { // 创建UserDao的对象，并设置set()方法 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add(){ System.out.println(&quot;service add...&quot;); // 1、原始方式：创建UserDao对象 /*UserDao userDao = new UserDaoImpl(); userDao.update(); */ }}public interface UserDao { public void update();}public class UserDaoImpl implements UserDao { @Override public void update() { }}c. 在 spring配置文件中进行配置&amp;lt;!--1 service和dao的创建--&amp;gt; &amp;lt;bean id=&quot;userService&quot; class=&quot;com.micah.spring.service.UserService&quot;&amp;gt; &amp;lt;!--注入UserDao的对象 name:属性值，类里面属性名称 ref:属性值，创建UserDao对象bean标签ID值 --&amp;gt; &amp;lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.micah.spring.dao.UserDaoImpl&quot;/&amp;gt;5、注入内部Bean属性（1）一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门部门是一，员工是多 （2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示/** * @Author m.kong * @Date 2021/2/24 下午1:50 * @Version 1.0 */public class Department { private String dname; public void setDname(String dname) { this.dname = dname; } public String getDname() { return dname; } @Override public String toString() { return &quot;Department{&quot; + &quot;dname=&#39;&quot; + dname + &#39;\\&#39;&#39; + &#39;}&#39;; }}/** * @Author m.kong * @Date 2021/2/24 下午1:51 * @Version 1.0 */public class Employee { private String eName; private String gender; // 员工属于一个部门 private Department department; public void setDepartment(Department department) { this.department = department; } // 第二种写法新增 public Department getDepartment() { return department; } public void seteName(String eName) { this.eName = eName; } public void setGender(String gender) { this.gender = gender; } public void show(){ System.out.println(&quot;eName:&quot; + eName + &quot;,department:&quot; + department + &quot;,gender&quot; + gender); }}（3）在 spring配置文件中进行配置 第一种写法：&amp;lt;bean id=&quot;employee&quot; class=&quot;com.micah.spring.bean.Employee&quot;&amp;gt; &amp;lt;!--普通属性--&amp;gt; &amp;lt;property name=&quot;eName&quot; value=&quot;Micah&quot;/&amp;gt; &amp;lt;property name=&quot;gender&quot; value=&quot;男&quot;/&amp;gt; &amp;lt;!--设置对象属性--&amp;gt; &amp;lt;property name=&quot;department&quot;&amp;gt; &amp;lt;bean id=&quot;department&quot; class=&quot;com.micah.spring.bean.Department&quot;&amp;gt; &amp;lt;property name=&quot;dname&quot; value=&quot;安保部门&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt;第二种写法：&amp;lt;!--级联赋值--&amp;gt; &amp;lt;bean id=&quot;employee&quot; class=&quot;com.micah.spring.bean.Employee&quot;&amp;gt; &amp;lt;!--普通属性--&amp;gt; &amp;lt;property name=&quot;eName&quot; value=&quot;Micah&quot;/&amp;gt; &amp;lt;property name=&quot;gender&quot; value=&quot;男&quot;/&amp;gt; &amp;lt;!--级联赋值--&amp;gt; &amp;lt;property name=&quot;department&quot; ref=&quot;department&quot;/&amp;gt; &amp;lt;property name=&quot;department.dname&quot; value=&quot;技术部&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;department&quot; class=&quot;com.micah.spring.bean.Department&quot;&amp;gt; &amp;lt;property name=&quot;dname&quot; value=&quot;财务部&quot;/&amp;gt; &amp;lt;/bean&amp;gt;6、注入集合属性（1）、注入数组类型属性 （2）、注入 List 集合类型属性 （3）、注入 Map 集合类型属性/** * @Author m.kong * @Date 2021/2/24 下午3:15 * @Version 1.0 */public class Student { private String[] courses; private List&amp;lt;String&amp;gt; list; private Map&amp;lt;String,String&amp;gt; map; private Set&amp;lt;String&amp;gt; set; private List&amp;lt;Course&amp;gt; courseList; public void setCourseList(List&amp;lt;Course&amp;gt; courseList) { this.courseList = courseList; } public void setSet(Set&amp;lt;String&amp;gt; set) { this.set = set; } public void setCourses(String[] courses) { this.courses = courses; } public void setList(List&amp;lt;String&amp;gt; list) { this.list = list; } public void setMap(Map&amp;lt;String, String&amp;gt; map) { this.map = map; } public void show(){ System.out.println(Arrays.toString(courses) + list.toString() + map.toString() + set.toString() +courseList.toString()); }}&amp;lt;!--集合类型的数据注入--&amp;gt; &amp;lt;bean id=&quot;student&quot; class=&quot;com.micah.spring.collection.Student&quot;&amp;gt; &amp;lt;!--数据类型属性的注入--&amp;gt; &amp;lt;property name=&quot;courses&quot;&amp;gt; &amp;lt;array&amp;gt; &amp;lt;value&amp;gt;Java&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;DataBase&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;SoftWare Theory&amp;lt;/value&amp;gt; &amp;lt;/array&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&quot;list&quot;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;value&amp;gt;Micah&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;Maruko&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;Mapper&amp;lt;/value&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&quot;map&quot;&amp;gt; &amp;lt;map&amp;gt; &amp;lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&amp;gt;&amp;lt;/entry&amp;gt; &amp;lt;entry key=&quot;DATABASE&quot; value=&quot;database&quot;&amp;gt;&amp;lt;/entry&amp;gt; &amp;lt;entry key=&quot;SOFTWARE THEORY&quot; value=&quot;software theory&quot;&amp;gt;&amp;lt;/entry&amp;gt; &amp;lt;/map&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&quot;set&quot;&amp;gt; &amp;lt;set&amp;gt; &amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;2&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt; &amp;lt;/set&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;!--注入list集合类型，但list元素是对象的属性--&amp;gt; &amp;lt;property name=&quot;courseList&quot;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;ref bean=&quot;course1&quot;/&amp;gt; &amp;lt;ref bean=&quot;course2&quot;/&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt;@Testpublic void testBean(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); Student student = context.getBean(&quot;student&quot;, Student.class); System.out.println(student); student.show();} （4）、在集合里面设置对象类型值&amp;lt;!--创建多个 course对象--&amp;gt;&amp;lt;bean id=&quot;course1&quot; class=&quot;com.micah.spring.collectiontype.Course&quot;&amp;gt;&amp;lt;property name=&quot;cname&quot; value=&quot;Spring5 框架&quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;bean id=&quot;course2&quot; class=&quot;com.micah.spring.collectiontype.Course&quot;&amp;gt;&amp;lt;property name=&quot;cname&quot; value=&quot;MyBatis 框架&quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;!--注入 list 集合类型，值是对象--&amp;gt;&amp;lt;property name=&quot;courseList&quot;&amp;gt;&amp;lt;list&amp;gt;&amp;lt;refbean=&quot;course1&quot;&amp;gt;&amp;lt;/ref&amp;gt;&amp;lt;refbean=&quot;course2&quot;&amp;gt;&amp;lt;/ref&amp;gt;&amp;lt;/list&amp;gt;&amp;lt;/property&amp;gt;（5）把集合注入部分提取出来a. 在 spring配置文件中引入名称空间 util&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&amp;gt;b. 使用 util标签完成 list集合注入提取&amp;lt;!--1、提取list集合类型属性的注入--&amp;gt; &amp;lt;util:list id=&quot;booklist&quot;&amp;gt; &amp;lt;value&amp;gt;Spring&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;Java&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;JVM Machine&amp;lt;/value&amp;gt; &amp;lt;/util:list&amp;gt; &amp;lt;!--2、提取list集合类型属性的注入使用 scope:(1)&quot;prototype&quot;多实例 （2）&quot;singleton&quot;单实例 --&amp;gt; &amp;lt;bean id=&quot;book&quot; class=&quot;com.micah.spring.collection.Book&quot; scope=&quot;prototype&quot;&amp;gt; &amp;lt;property name=&quot;list&quot; ref=&quot;booklist&quot;/&amp;gt; &amp;lt;/bean&amp;gt;&amp;lt;/beans&amp;gt;三、FactoryBean1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） 普通 bean：在配置文件中定义 bean 类型就是返回类型 工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样2、 案例演示 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型/** * @Author m.kong * @Date 2021/2/24 下午4:15 * @Version 1.0 */public class MyBean implements FactoryBean&amp;lt;Course&amp;gt; { /** * 定义返回bean */ @Override public Course getObject() throws Exception { Course course = new Course(); course.setcName(&quot;abc&quot;); return course; } @Override public Class&amp;lt;?&amp;gt; getObjectType() { return null; } @Override public boolean isSingleton() { return false; }}四、Spring Bean作用域1、在 Spring 里面，你怎样定义类的作用域?当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。2、解释Spring支持的几种bean的作用域。Spring框架支持以下五种bean的作用域： singleton : bean在每个Spring ioc 容器中只有一个实例。 prototype：一个bean的定义可以有多个实例。 request：将单个bean定义的范围限定为单个HTTP请求的生命周期； 也就是说，每个HTTP请求都有一个自己的bean实例，它是在单个bean定义的后面创建的。 仅在基于Web的Spring ApplicationContext上下文中有效。 session：将单个bean定义的作用域限定为HTTP会话的生命周期。 仅在web的Spring ApplicationContext上下文中有效。 application:将单个bean定义的作用域限定为ServletContext的生命周期。 仅在基于web的Spring ApplicationContext上下文中有效。 websocket:将单个bean定义的作用域限定为WebSocket的生命周期。 仅在基于web的Spring ApplicationContext上下文中有效。 3、 Spring框架中的单例bean是线程安全的吗?不，Spring框架中的单例bean不是线程安全的。五、Spring Bean生命周期1、Spring框架中bean的生命周期。详细讲解：https://blog.csdn.net/wangxiang1292/article/details/102162890 Spring容器 从XML 文件中读取bean的定义，并实例化bean。 Spring根据bean的定义填充所有的属性。 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。 如果Bean实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory方法。 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。 如果有BeanPostProcessors 和bean关联，这些bean的postProcessAfterInitialization()方法将被调用。 如果bean实现了 DisposableBean，它将调用destroy()方法。2、哪些是重要的bean生命周期方法？ 你能重载它们吗？有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。The bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。六、Spring Bean自动装配1、什么是bean装配?装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。2、什么是bean的自动装配？Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。3、解释不同方式的自动装配 。有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。 byName：通过参数名自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。 byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。 constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。4、自动装配有哪些局限性 ?自动装配的局限性是：重写： 你仍需用 和 配置来定义依赖，意味着总要重写自动装配。 基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。 模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。5、你可以在Spring中注入一个null 和一个空字符串吗？可以。七、Spring注解1、什么是基于Java的Spring注解配置? 给一些注解的例子.基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。2、Spring 针对 Bean 管理中创建对象提供注解（1） @Component （2） @Service （3） @Controller （4） @Repository 上面四个注解功能是一样的，都可以用来创建bean 实例3、什么是基于注解的容器配置?相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。4、怎样开启注解装配？注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 context:annotation-config/元素。5、@Required 注解这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。6、@Autowired 注解@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。7、@Qualifier 注解当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。8、案例演示Step 1: 引入依赖spring-aop-5.2.6.RELEASE.jar Step 2: 开启组件扫描&amp;lt;!--开启组件扫描 1、如果扫描多个包，就用逗号隔开 2、dao和service，扫描包上层目录 --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.micah&quot;/&amp;gt;Step 3: 创建类，在类上面添加创建对象注解/** * @Author m.kong * @Date 2021/2/25 下午11:16 * @Version 1.0 */// value可以不写，默认是首字母小写的类名@Service(value = &quot;userService&quot;) //&amp;lt;bean id=&quot;userService&quot; class=&quot;&quot;/&amp;gt;public class UserService { // 注入普通属性 @Value(value = &quot;Micah&quot;) private String name; /** * 定义dao类型属性，不需要添加set方法，添加注入属性注解 * @Autowired : 根据类型注入 * @Qualifier(value = &quot;userDaoImplOne&quot;) : 和上面@Autowired一起配合使用 */ @Autowired @Qualifier(value = &quot;userDaoImplOne&quot;) // @Resource 根据类型注入 // @Resource(name = &quot;userDaoImplOne&quot;) 根据名称注入 private UserDao userDao; public void add(){ System.out.println(&quot;add...&quot; + name); userDao.add(); }}@Repository(value = &quot;userDaoImplOne&quot;)public class UserDaoImpl implements UserDao{ @Override public void add() { System.out.println(&quot;dao add ... &quot;); }}/** * @Author m.kong * @Date 2021/2/26 下午10:04 * @Version 1.0 */public interface UserDao { public void add();}Step 4: 新建配置类，替代xml文件@Configuration // 作为配置类，替代xml文件@ComponentScan(basePackages = { &quot;com.micah&quot;})public class SpringConfig { }Step 5: 测试// 添加SpringConfig之前@Test public void testService(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); } // 添加SpringConfig之后@Test public void testService2(){ ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); }结果： " }, { "title": "Spring AOP", "url": "/posts/Spring-AOP/", "categories": "框架, Spring", "tags": "", "date": "2022-07-13 00:00:00 +0800", "snippet": "一、什么是AOP？1、AOPAOP（Aspect Oriented Programming），即面向切面编程，是OOP的补充，它也提供了模块化。在面向对象编程中，关键的单元是对象，AOP的关键单元是切面，或者说关注点（可以简单地理解为你程序中的独立模块）。一些切面可能有集中的代码，但是有些可能被分散或者混杂在一起，例如日志或者事务。这些分散的切面被称为横切关注点。一个横切关注点是一个可以影响到整个应用的关注点，而且应该被尽量地集中到代码的一个地方，例如事务管理、权限、日志、安全等。AOP让你可以使用简单可插拔的配置，在实际逻辑执行之前、之后或周围动态添加横切关注点。这让代码在当下和将来都变得易于维护。如果你是使用XML来使用切面的话，要添加或删除关注点，你不用重新编译完整的源代码，而仅仅需要修改配置文件就可以了。 总而言之，AOP就是使用不修改源代码的方式，在主干功能里添加新的功能。2、Spring AOP 中的一些概念 切面(Aspect)：AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。连接点(Join Point)：在程序执行过程中的一点，例如方法的执行或异常的处理。在Spring AOP中，连接点始终代表方法的执行。通知(Advice)：AOP在特定的切入点上执行的增强处理，有before, after, afterReturning, afterThrowing, around切入点（Pointcut）：决定处理如权限校验、日志记录等在何处切入业务代码中（即织入切面）。切点分为execution方式和annotation方式。前者可以用路径表达式指定哪些类织入切面，后者可以指定被哪些注解修饰的代码织入切面。引介（Introduction）：引介让一个切面可以声明被通知的对象实现了任何他们没有真正实现的额外接口，而且为这些对象提供接口的实现使用 @DeclareParaents 注解来生成一个引介。目标对象（Target object）：一个或多个切面通知的对象。也称为通知对象。由于Spring AOP是使用运行时代理实现的，因此该对象将始终是代理对象。AOP代理（AOP proxy）：由AOP框架创建的对象，用于实施Aspect（处理方法执行等）。在Spring Framework中，AOP代理将是JDK动态代理或CGLIB代理。织入（Weaving）：织入，就是通过动态代理，在目标对象方法中执行处理内容的过程。3、通知的类型通知(advice)是你在你的程序中想要应用在其他模块中的横切关注点的实现。Advice主要有以下5种类型： 前置通知(Before Advice): 在连接点之前执行的Advice，不过除非它抛出异常，否则没有能力中断执行流。使用 @Before 注解使用这个Advice。 返回之后通知(After Retuning Advice): 在连接点正常结束之后执行的Advice。例如，如果一个方法没有抛出异常正常返回。通过 @AfterReturning 关注使用它。 抛出（异常）后执行通知(After Throwing Advice): 如果一个方法通过抛出异常来退出的话，这个Advice就会被执行。通过 @AfterThrowing 注解来使用。 后置通知(After Advice): 无论连接点是通过什么方式退出的(正常返回或者抛出异常)都会执行在结束后执行这些Advice。通过 @After 注解使用。 围绕通知(Around Advice): 围绕连接点执行的Advice，就你一个方法调用。这是最强大的Advice。通过@Around 注解使用。**通知执行的顺序：@Around、@Before、@After、@Around、@AfterReturning，如果有异常就会执行@AfterThrowing4、在Spring AOP中关注点和横切关注点有什么不同？关注点：是我们想在应用的模块中实现的行为。关注点可以被定义为：我们想实现以解决特定业务问题的方法。 横切关注点：是贯穿整个应用程序的关注点。像日志、安全和数据转换，它们在应用的每一个模块都是必须的，所以他们是一种横切关注点。二、AOP的底层原理1、AOP底层使用动态代理有2种情况的动态代理(1) 有接口情况使用JDK代理 (2) 没有接口的情况使用CGLIB动态代理 2、使用JDK动态代理使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 方法有三个参数： ClassLoder，类加载器 类&amp;lt;?&amp;gt;[ ] interfaces，增强方法所在的类，这个类实现的接口，支持多个接口 InvocationHandler，实现这个接口 InvocationHandler，创建代理对象，写增强的部分下面编写代码来演示使用JDK动态代理/** * @Author m.kong * @Date 2021/2/27 下午4:27 * @Version 1.0 */public interface UserDao { /** * 2数相加 */ int add(int a, int b); /** * * @param id */ void update(String id);}/** * @Author m.kong * @Date 2021/2/27 下午4:29 * @Version 1.0 */public class UserDaoImpl implements UserDao{ @Override public int add(int a, int b) { System.out.println(&quot;add方法执行了...&quot;); return a+b; } @Override public void update(String id) { System.out.println(&quot;update方法执行了&quot; + id); }}/** * @Author m.kong * @Date 2021/2/27 下午4:31 * @Version 1.0 */public class JDKProxy { public static void main(String[] args) { // 创建接口实现类代理对象 Class[] interfaces = { UserDao.class}; /*第三个参数传入匿名内部类 Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { return null; } });*/ UserDaoImpl userDaoImpl = new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDaoImpl)); int sum = dao.add(1, 8); System.out.println(&quot;sum = &quot; + sum); }}/** * 创建代理对象 */class UserDaoProxy implements InvocationHandler{ private Object obj; // 1、创建的是谁的对象，就把谁传递过来 public UserDaoProxy(Object obj){ this.obj = obj; } /** * 增强的逻辑 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 方法之前 System.out.println(&quot;方法之前执行...&quot; + method.getName() + &quot;:传递的参数&quot; + Arrays.toString(args)); // 被增强的方法执行 Object res = method.invoke(obj, args); // 方法之后 System.out.println(&quot;方法之后执行&quot; + obj); return res; }}三、Spring AOP的实现基于Java的主要AOP实现有：AspectJ Spring AOP JBoss AOPAspectJ和Spring AOP对比： AspectJ是语言级的，它的学习成本大，但是非常强大能够处理AOP的各种问题，并且它是在编译器植入代码 Spring AOP是运行时动态织入代码，代码只能织入目标对象（一般是代理对象）的方法，它是一个性价比最高的解决方案，因为实际项目中往往只是将通知织入方法中1、引入Spring AOP需要的依赖（1）工程中，引入Spring AOP相关的依赖 （2）Spring AOP实现方式：基于xml配置文件实现、注解方式实现（使用）（3）切入点表达式（ Point Cut Expression）切入点表达式作用：知道对哪个类里面的哪个方法进行增强 语法结构：execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) )举例：举例 1：对 com.micah.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..))举例 2：对 com.micah.dao.BookDao 类里面的所有的方法进行增强execution(* com.atguigu.dao.BookDao.* (..))举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强execution(* com.micah.dao.*.* (..))其它切入类型： @Pointcut(&quot;execution(public * *(..))&quot;)private void anyPublicOperation() { }@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)private void inTrading() { }@Pointcut(&quot;anyPublicOperation() &amp;amp;&amp;amp; inTrading()&quot;)private void tradingOperation() { }常见切入点表达式的一些示例在下面给出。the execution of any public method:execution(public * *(..))名称以“ set”开头的任何方法的执行：execution(* set*(..))AccountService接口定义的任何方法的执行：execution(* com.xyz.service.AccountService.*(..))the execution of any method defined in the service package:execution(* com.xyz.service.*.*(..))服务包或子包中定义的任何方法的执行：execution(* com.xyz.service..*.*(..))服务包中的任何连接点（仅在Spring AOP中执行方法）：within(com.xyz.service.*)服务包或子包中的任何连接点（仅在Spring AOP中执行方法）：within(com.xyz.service..*)代理实现AccountService接口的任何连接点（仅在Spring AOP中是方法执行） ：this(com.xyz.service.AccountService)2、创建切面类(1) 创建类，在类里面定义方法，添加@Component注解，创建对象@Componentpublic class User { /** * 前置通知 */ public void add(){ System.out.println(&quot;add......&quot;); }}（2）创建增强类（编写增强逻辑），在增强类里面，创建方法，让不同方法代表不同通知类型@Component@Aspect // 生成代理对象public class UserProxy { /** * 相同切入点抽取 */ @Pointcut(value = &quot;execution(* com.micah.spring.aopnno.User.add(..))&quot;) public void pointCut(){ } /** * 前置通知 * @Before注解表示作为前置通知 */ @Order(3) @Before(value = &quot;pointCut()&quot;) public void before(){ System.out.println(&quot;before...&quot;); } /** * 后置通知（返回通知） */ @AfterReturning(value = &quot;execution(* com.micah.spring.aopnno.User.add(..))&quot;) public void afterReturning(){ System.out.println(&quot;afterReturning...&quot;); } /** * 异常通知 */ @AfterThrowing(value = &quot;execution(* com.micah.spring.aopnno.User.add(..))&quot;) public void afterThrowing(){ System.out.println(&quot;afterThrowing...&quot;); } /** *最终通知 */ @After(value = &quot;execution(* com.micah.spring.aopnno.User.add(..))&quot;) public void after(){ System.out.println(&quot;after...&quot;); } /** * 环绕通知 */ @Around(value = &quot;execution(* com.micah.spring.aopnno.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(&quot;环绕之前...&quot;); // 被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后...&quot;); }（3）添加项目xml配置文件&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt; &amp;lt;!-- 开启注解扫描 --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.micah.spring&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt; &amp;lt;!-- 开启Aspect生成代理对象--&amp;gt; &amp;lt;aop:aspectj-autoproxy&amp;gt;&amp;lt;/aop:aspectj-autoproxy&amp;gt;&amp;lt;/beans&amp;gt;（4）测试以及结果：@Test public void testAopAnno(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); user.add(); } （5）有多个增强类多同一个方法进行增强，设置增强类优先级 在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高@Component@Aspect@Order(1)public class PersonProxy（6）完全使用注解开发 创建配置类，不需要创建 xml 配置文件@Configuration@ComponentScan(basePackages = { &quot;com.micah&quot;}) @EnableAspectJAutoProxy(proxyTargetClass = true) public class ConfigAop { }3、Aspect配置文件在 spring 配置文件中配置切入点&amp;lt;!--配置 aop 增强--&amp;gt;&amp;lt;aop:config&amp;gt; &amp;lt;!--切入点--&amp;gt; &amp;lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(*com.micah.spring.aopxml.Book.buy(..))&quot;/&amp;gt; &amp;lt;!--配置切面--&amp;gt; &amp;lt;aop:aspect ref=&quot;bookProxy&quot;&amp;gt; &amp;lt;!--增强作用在具体的方法上--&amp;gt; &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&amp;gt; &amp;lt;/aop:aspect&amp;gt;&amp;lt;/aop:config&amp;gt;" }, { "title": "IoC和DI", "url": "/posts/IoC%E4%B8%8EDI/", "categories": "框架, Spring", "tags": "", "date": "2022-07-13 00:00:00 +0800", "snippet": "一、IoC概念和原理1、什么是IOC（面试）Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。 ​使用IOC目的：为了降低耦合度2、IOC底层（面试）xml解析、工厂模式、反射 3、IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂，Spring提供的I0C容器实现的两种方式（两个接口）（面试）（1）BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。） （2）ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！[官网描述]：In short, the BeanFactory provides the configuration framework and basic functionality, and the ApplicationContext adds more enterprise-specific functionality. The ApplicationContext is a complete superset of the BeanFactory, and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the BeanFactory instead of the ApplicationContext, refer to The BeanFactory.4、ApplicationContext通常的实现是什么?（面试） FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。 5、IOC的优点是什么？（面试）IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。6、Bean 工厂和 Application contexts 有什么区别？（面试）Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。二、依赖注入(DI: Dependency Injection )1、 什么是Spring的依赖注入？(面试)依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。2、有哪些不同类型的IOC（依赖注入）方式？（面试） 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。3、哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？（面试）你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。" }, { "title": "SpringBoot2基础篇", "url": "/posts/SpringBoot2%E5%9F%BA%E7%A1%80%E7%AF%87/", "categories": "框架, SpringBoot", "tags": "", "date": "2022-07-12 00:00:00 +0800", "snippet": "前言本笔记依照黑马视频链接：黑马SpringBoot我的IDEA版本：IntelliJ IDEA 2020.1(Ultimate Editon)SpringBoot概述SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程新建SpringBoot工程1.创建新模块，选择Spring Initializr，并配置模块相关基础信息2.选择当前模块需要使用的技术集3.开发控制器类//Rest 模式@RestController@RequestMapping(&quot;/books&quot;)public class BookController { @GetMapping public String getById() { System.out.println(&quot;springboot is running...&quot;); return &quot;springboot is running...&quot;; }}4.运行自动生成的Application类5.打开浏览器访问url地址为：http://localhost:8080/books工程文件介绍最简SpringBoot程序所包含的基础文件 (pom.xml文件 和 Application类 )1.pom.xml文件&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.6&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springboot-01-quickstart&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;2.Application类@SpringBootApplicationpublic class Springboot0101QuickstartApplication { public static void main(String[] args) { SpringApplication.run(Springboot0101QuickstartApplication.class, args); }}Spring程序与SpringBoot程序对比注意: 基于idea开发SpringBoot程序需要确保联网且能够加载到程序框架结构IDEA的SpringBoot工程中隐藏不常用的文件如以.mvn、.gitignore、HELP.md、mvnw、mvnw.cmd、.iml为后缀的文件，我们再开发的时候通常不会修改其中的内容，这个时候觉得这些文件碍眼可以选择再IDEA中隐藏它们 处理方法： parent&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.6&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springboot-01-quickstart&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：&amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.6&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt;按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：&amp;lt;properties&amp;gt; &amp;lt;activemq.version&amp;gt;5.15.3&amp;lt;/activemq.version&amp;gt; &amp;lt;antlr2.version&amp;gt;2.7.7&amp;lt;/antlr2.version&amp;gt; &amp;lt;appengine-sdk.version&amp;gt;1.9.63&amp;lt;/appengine-sdk.version&amp;gt; &amp;lt;artemis.version&amp;gt;2.4.0&amp;lt;/artemis.version&amp;gt; &amp;lt;aspectj.version&amp;gt;1.8.13&amp;lt;/aspectj.version&amp;gt; &amp;lt;assertj.version&amp;gt;3.9.1&amp;lt;/assertj.version&amp;gt; &amp;lt;atomikos.version&amp;gt;4.0.6&amp;lt;/atomikos.version&amp;gt; &amp;lt;bitronix.version&amp;gt;2.1.4&amp;lt;/bitronix.version&amp;gt; &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt; &amp;lt;byte-buddy.version&amp;gt;1.7.11&amp;lt;/byte-buddy.version&amp;gt; ... ... ...&amp;lt;/properties&amp;gt;&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; ... ... ... &amp;lt;/dependencies&amp;gt;&amp;lt;/dependencyManagement&amp;gt;&amp;lt;build&amp;gt; &amp;lt;pluginManagement&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.jetbrains.kotlin&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;kotlin-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${kotlin.version}&amp;lt;/version&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.jooq&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jooq-codegen-maven&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${jooq.version}&amp;lt;/version&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/plugin&amp;gt; ... ... ... &amp;lt;/plugins&amp;gt; &amp;lt;/pluginManagement&amp;gt;&amp;lt;/build&amp;gt;从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。小结: 开发SpringBoot程序要继承spring-boot-starter-parent spring-boot-starter-parent中定义了若干个依赖管理 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突 继承parent的形式也可以采用引入依赖的形式实现效果 spring-boot-starter-web.pom 按住Ctrl点击pom.xml中的spring-boot-starter-web，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot; xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starters&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;Spring Boot Web Starter&amp;lt;/name&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-json&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate.validator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;6.0.9.Final&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。 starter SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的 parent 所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的 spring-boot-starter-parent各版本间存在着诸多坐标版本不同 实际开发 使用任意坐标时，仅书写GAV(groupId, artifactId, version)中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V 如发生坐标错误，再指定Version（要小心版本冲突）小结: 开发SpringBoot程序需要导入坐标时通常导入对应的starter 每个不同的starter根据功能不同，通常包含多个依赖坐标 使用starter可以实现快速配置的效果，达到简化配置的目的 启动方式@SpringBootApplicationpublic class Springboot0101QuickstartApplication { public static void main(String[] args) { ConfigurableApplicationContext ctx = SpringApplication.run(Springboot0101QuickstartApplication.class, args); //获取bean对象 BookController bean = ctx.getBean(BookController.class); System.out.println(&quot;bean======&amp;gt;&quot; + bean); }} SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目 SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean小结: SpringBoot工程提供引导类用来启动程序 SpringBoot工程启动后创建并初始化Spring容器 辅助功能 内嵌tomcat 使用maven依赖管理变更起步依赖项&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;!--web 起步依赖环境中，排除 Tomcat 起步依赖 --&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 添加 Jetty 起步依赖，版本由 SpringBoot 的 starter 控制 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-jetty&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; Jetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat），谷歌应用引擎（GAE）已经全面切换为Jetty 内置服务器 tomcat(默认) apache出品，粉丝多，应用面广，负载了若干较重的组件 jetty 更轻量级，负载性能远不及tomcat undertow undertow，负载性能勉强跑赢tomcat小结: 内嵌Tomcat服务器是SpringBoot辅助功能之一 内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理 变更内嵌服务器思想是去除现有服务器，添加全新的服务器总结: 入门案例（4种方式） SpringBoot概述 parent starter 引导类 辅助功能（内嵌tomcat） 什么是 rest ： 1. REST（Representational State Transfer）表现形式状态转换 1. 传统风格资源描述形式 http://localhost/user/getById?id=1 (得到id为1的用户) http://localhost/user/saveUser (保存用户) 1. REST风格描述形式 http://localhost/user/1 (得到id为1的用户) http://localhost/user (保存用户) 优点: 5. 隐藏资源的访问行为， 无法通过地址得知对资源是何种操作 5. 书写简化 按照REST风格访问资源时使用行为动作区分对资源进行了何种操作 GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源 8. http://localhost/users 查询全部用户信息 GET (查询) 8. http://localhost/users/1 查询指定用户信息 GET (查询) 8. http://localhost/users 添加用户信息 POST (新增/保存) 8. http://localhost/users 修改用户信息 PUT (修改/更新) 8. http://localhost/users/1 删除用户信息 DELETE (删除) 注意: 上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范 描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源,而非单个资源，例如: users、 books、 accounts… 根据REST风格对资源进行访问称为RESTful 小结： 15. REST 15. 动作4个 15. RESTful 步骤:①:设定http请求动作(动词)使用 @RequestMapping 注解的 method 属性声明请求的方式使用 @RequestBody 注解 获取请求体内容。直接使用得到是 key=value&amp;amp;key=value…结构的数据。get 请求方式不适用。使用@ResponseBody 注解实现将 controller 方法返回对象转换为 json 响应给客户端。@RequestMapping(value=”/users”,method=RequestMethod.POST)②:设定请求参数(路径变量)使用@PathVariable 用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。 @RequestMapping @PathVariable @RequestBody @RequestParam @PathVariable 使用 @RestController 注解开发 RESTful 风格 使用 @GetMapping @PostMapping @PutMapping @DeleteMapping 简化 @RequestMapping 注解开发 原则 保留工程基础结构 抹掉原始工程痕迹 在IDEA 中点击模块管理添加模块 小结: 在工作空间中复制对应工程，并修改工程名称 删除与Idea相关配置文件，仅保留src目录与pom.xml文件 修改pom.xml文件中的artifactId与新工程/模块名相同 删除name标签（可选） 保留备份工程供后期使用 修改服务器端口 SpringBoot默认配置文件application.properties，通过键值对配置对应属性 修改配置 修改服务器端口# 服务器端口配制server.port=80 小结: SpringBoot默认配置文件application.properties 修改配置 修改服务器端口 server.port=80 关闭运行日志图标（banner） spring.main.banner-mode=off 设置日志相关 logging.level.root=debug # 服务器端口配置server.port=80# 修改banner# spring.main.banner-mode=off# spring.banner.image.location=logo.png# 日志logging.level.root=info SpringBoot内置属性查询 https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties 官方文档中参考文档第一项：Application Propertie小结: SpringBoot中导入对应starter后，提供对应配置属性 书写SpringBoot配置采用关键字+提示形式书写 配置文件格式 SpringBoot提供了多种属性配置方式 application.propertiesserver.port=80 application.ymlserver: port: 81 application.yamlserver: port: 82小结: SpringBoot提供了3种配置文件的格式 properties（传统格式/默认格式） yml（主流格式） yaml SpringBoot配置文件加载顺序 application.properties &amp;gt; application.yml &amp;gt; application.yaml 常用配置文件种类 application.yml小结: 配置文件间的加载优先级 properties（最高） yml yaml（最低） 不同配置文件中相同配置按照加载优先级相互覆盖 (高优先级配置内容会覆盖低优先级配置内容)，不同配置文件中不同配置全部保留 小结: 指定SpringBoot配置文件 Setting → Project Structure → Facets 选中对应项目/工程 Customize Spring Boot 选择配置文件yaml YAML（YAML Ain’t Markup Language），一种数据序列化格式 优点： 1. 容易阅读 1. 容易与脚本语言交互 1. 以数据为核心，重数据轻格式 YAML文件扩展名 5. .yml（**主流**） 5. .yaml yaml语法规则基本语法 key: value -&amp;gt; value 前面一定要有空格 大小写敏感 属性层级关系使用多行描述，每行结尾使用冒号结束 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键） 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔） 表示注释 核心规则：数据前面要加空格与冒号隔开server: servlet: context-path: /hello port: 82数据类型 字面值表示方式 # 字面值表示方式boolean: TRUE #TRUE,true,True,FALSE,false ， False 均可float: 3.14 #6.8523015e+5 # 支持科学计数法int: 123 #0b1010_0111_0100_1010_1110 # 支持二进制、八进制、十六进制# null: ~ # 使用 ~ 表示 nullstring: HelloWorld # 字符串可以直接书写string2: &quot;Hello World&quot; # 可以使用双引号包裹特殊字符date: 2018-02-17 # 日期必须使用 yyyy-MM-dd 格式datetime: 2018-02-17T15:02:31+08:00 # 时间和日期之间使用 T 连接，最后使用 + 代表时区 数组表示方式：在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔 subject: - Java - 前端 - 大数据enterprise: name: zhangsan age: 16subject2: - Java - 前端 - 大数据likes: [王者荣耀,刺激战场] # 数组书写缩略格式users: # 对象数组格式 - name: Tom age: 4 - name: Jerry age: 5users2: # 对象数组格式二 - name: Tom age: 4 - name: Jerry age: 5# 对象数组缩略格式users3: [ { name:Tom , age:4 } , { name:Jerry , age:5 } ]小结:1. yaml语法规则 大小写敏感 属性层级关系使用多行描述，每行结尾使用冒号结束 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键） 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔） # 表示注释2. 注意属性名冒号后面与数据之间有一个空格3. 字面值、对象数据格式、数组数据格式（略） 使用@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……} @Value(&quot;${country}&quot;) private String country1; @Value(&quot;${user.age}&quot;) private String age1; @Value(&quot;${likes[1]}&quot;) private String likes1; @Value(&quot;${users[1].name}&quot;) private String name1; @GetMapping public String getById() { System.out.println(&quot;springboot is running2...&quot;); System.out.println(&quot;country1=&amp;gt;&quot; + country1); System.out.println(&quot;age1=&amp;gt;&quot; + age1); System.out.println(&quot;likes1=&amp;gt;&quot; + likes1); System.out.println(&quot;name1=&amp;gt;&quot; + name1); return &quot;springboot is running2...&quot;; }小结: 使用@Value配合SpEL读取单个数据 如果数据存在多层级，依次书写层级名称即可 在配置文件中可以使用属性名引用方式引用属性 属性值中如果出现转移字符，需要使用双引号包裹小结: 在配置文件中可以使用${属性名}方式引用属性值 如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析 封装全部数据到Environment对象 注意 要导这个 包 import org.springframework.core.env.Environment; 小结: 使用Environment对象封装全部配置信息 使用@Autowired自动装配数据到Environment对象中 自定义对象封装指定数据 自定义对象封装指定数据的作用 # 创建类，用于封装下面的数据# 由spring帮我们去加载数据到对象中，一定要告诉spring加载这组信息# 使用时候从spring中直接获取信息使用datasource: driver: com.mysql.jdbc.Driver url: jdbc:mysql://localhost/springboot_db username: root password: root666123//1.定义数据模型封装yaml文件中对应的数据//2.定义为spring管控的bean@Component//3.指定加载的数据@ConfigurationProperties(prefix = &quot;datasource&quot;)public class MyDataSource { private String driver; private String url; private String username; private String password; //省略get/set/tostring 方法}使用自动装配封装指定数据@Autowired private MyDataSource myDataSource;输出查看System.out.println(myDataSource);小结: 使用@ConfigurationProperties注解绑定配置信息到封装类中 封装类需要定义为Spring管理的bean，否则无法进行属性注入 添加Junit的起步依赖 Spring Initializr 创建时自带&amp;lt;!--测试的起步依赖--&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt; SpringBoot整合JUnit@SpringBootTestclass Springboot07JunitApplicationTests { @Autowired private BookService bookService; @Test public void testSave(){ bookService.save(); }} @SpringBootTest 名称：@SpringBootTest 类型：测试类注解 位置：测试类定义上方 作用：设置JUnit加载的SpringBoot启动类 范例：@SpringBootTestclass Springboot05JUnitApplicationTests { }小结: 导入测试对应的starter 测试类使用@SpringBootTest修饰 使用自动装配的形式添加要测试的对象@SpringBootTest(classes = Springboot04JunitApplication.class)//@ContextConfiguration(classes = Springboot04JunitApplication.class)class Springboot04JunitApplicationTests { //1.注入你要测试的对象 @Autowired private BookDao bookDao; @Test void contextLoads() { //2.执行要测试的对象对应的方法 bookDao.save(); System.out.println(&quot;two...&quot;); }}注意: 如果测试类在SpringBoot启动类的包或子包中，可以省略启动类的设置，也就是省略classes的设定小结: 测试类如果存在于引导类所在包或子包中无需指定引导类 测试类如果不存在于引导类所在的包或子包中需要通过 classes 属性指定引导类①：创建新模块，选择Spring初始化，并配置模块相关基础信息 ②：选择当前模块需要使用的技术集（MyBatis、MySQL） ③：设置数据源参数#DB Configuration:spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_db username: root password: 123456④：创建user表 在 springboot_db 数据库中创建 user 表-- ------------------------------ Table structure for `user`-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `name` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (&#39;1&#39;, &#39;zhangsan&#39;, &#39;123&#39;, &#39;张三&#39;);INSERT INTO `user` VALUES (&#39;2&#39;, &#39;lisi&#39;, &#39;123&#39;, &#39;李四&#39;);⑤：创建实体Beanpublic class User { // 主键 private Long id; // 用户名 private String username; // 密码 private String password; // 姓名 private String name; //此处省略getter,setter,toString方法 .. .. }⑥: 定义数据层接口与映射配置@Mapperpublic interface UserDao { @Select(&quot;select * from user&quot;) public List&amp;lt;User&amp;gt; getAll();}⑦：测试类中注入dao接口，测试功能@SpringBootTestclass Springboot05MybatisApplicationTests { @Autowired private UserDao userDao; @Test void contextLoads() { List&amp;lt;User&amp;gt; userList = userDao.getAll(); System.out.println(userList); }}⑧：运行如下[User{ id=1, username=&#39;zhangsan&#39;, password=&#39;123&#39;, name=&#39;张三&#39;}, User{ id=2, username=&#39;lisi&#39;, password=&#39;123&#39;, name=&#39;李四&#39;}]总结: 勾选MyBatis技术，也就是导入MyBatis对应的starter 数据库连接相关信息转换成配置 数据库SQL映射需要添加@Mapper被容器识别到SpringBoot版本低于2.4.3(不含)，Mysql驱动版本大于8.0时，需要在url连接串中配置时区jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC或在MySQL数据库端配置时区解决此问题1.MySQL 8.X驱动强制要求设置时区 修改url，添加serverTimezone设定 修改MySQL数据库配置（略）2.驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver ①：手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.4.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;注意事项: 由于SpringBoot中未收录MyBatis-Plus的坐标版本，需要指定对应的Version②：定义数据层接口与映射配置，继承BaseMapper@Mapperpublic interface UserDao extends BaseMapper&amp;lt;User&amp;gt; { }③：其他同SpringBoot整合MyBatis （略）④：测试类中注入dao接口，测试功能@SpringBootTestclass Springboot06MybatisPlusApplicationTests { @Autowired private UserDao userDao; @Test void contextLoads() { List&amp;lt;User&amp;gt; users = userDao.selectList(null); System.out.println(users); }}⑤: 运行如下:[User{ id=1, username=&#39;zhangsan&#39;, password=&#39;123&#39;, name=&#39;张三&#39;}, User{ id=2, username=&#39;lisi&#39;, password=&#39;123&#39;, name=&#39;李四&#39;}]注意: 如果你的数据库表有前缀要在 application.yml 添加如下配制#设置Mp相关的配置mybatis-plus: global-config: db-config: table-prefix: tbl_小结: 1.手工添加MyBatis-Plus对应的starter 2.数据层接口使用BaseMapper简化开发 3.需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标 ①: 导入Druid对应的starter&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;②: 指定数据源类型 (这种方式只需导入一个 Druid 的坐标)#DB Configuration:spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource或者 变更Druid的配置方式(推荐) 这种方式需要导入 Druid对应的starterspring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC username: root password: 123456小结:1.整合Druid需要导入Druid对应的starter 2.根据Druid提供的配置方式进行配置 3.整合第三方技术通用方式 导入对应的starter 根据提供的配置格式，配置非默认值对应的配置项案例效果演示:案例实现方案分析与流程解析1. 案例实现方案分析 实体类开发————使用Lombok快速制作实体类 Dao开发————整合MyBatisPlus，制作数据层测试类 Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类 Controller开发————基于Restful开发，使用PostMan测试接口功能 Controller开发————前后端开发协议制作 页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理 列表、新增、修改、删除、分页、查询 项目异常处理 按条件查询————页面功能调整、Controller修正功能、Service修正功能2. SSMP案例制作流程解析 先开发基础CRUD功能，做一层测一层 调通页面，确认异步提交成功后，制作所有功能 添加分页功能与查询功能 pom.xml&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.4.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;tbl_book.sqlDROP TABLE IF EXISTS `tbl_book`;CREATE TABLE `tbl_book` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(20) DEFAULT NULL, `name` varchar(50) DEFAULT NULL, `description` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;-- ------------------------------ Records of tbl_book-- ----------------------------INSERT INTO `tbl_book` VALUES (&#39;1&#39;, &#39;计算机理论&#39;, &#39;Spring实战第5版&#39;, &#39;Spring入门经典教程,深入理解Spring原理技术内幕&#39;);INSERT INTO `tbl_book` VALUES (&#39;2&#39;, &#39;计算机理论&#39;, &#39;Spring 5核心原理与30个类手写实战&#39;, &#39;十年沉淀之作，写Spring精华思想&#39;);INSERT INTO `tbl_book` VALUES (&#39;3&#39;, &#39;计算机理论&#39;, &#39;Spring 5设计模式&#39;, &#39;深入Spring源码剖析Spring源码中蕴含的10大设计模式&#39;);INSERT INTO `tbl_book` VALUES (&#39;4&#39;, &#39;计算机理论&#39;, &#39;Spring MVC+ MyBatis开发从入门到项目实战&#39;, &#39;全方位解析面向Web应用的轻量级框架,带你成为Spring MVC开发高手&#39;);INSERT INTO `tbl_book` VALUES (&#39;5&#39;, &#39;计算机理论&#39;, &#39;轻量级Java Web企业应用实战&#39;, &#39;源码级剖析Spring框架,适合已掌握Java基础的读者&#39;);INSERT INTO `tbl_book` VALUES (&#39;6&#39;, &#39;计算机理论&#39;, &#39;Java核心技术卷|基础知识(原书第11版)&#39;, &#39;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、 11全面更新&#39;);INSERT INTO `tbl_book` VALUES (&#39;7&#39;, &#39;计算机理论&#39;, &#39;深入理解Java虚拟机&#39;, &#39;5个维度全面剖析JVM,面试知识点全覆盖&#39;);INSERT INTO `tbl_book` VALUES (&#39;8&#39;, &#39;计算机理论&#39;, &#39;Java编程思想(第4版)&#39;, &#39;Java学习必读经典殿堂级著作!赢得了全球程序员的广泛赞誉&#39;);INSERT INTO `tbl_book` VALUES (&#39;9&#39;, &#39;计算机理论&#39;, &#39;零基础学Java (全彩版)&#39;, &#39;零基础自学编程的入门]图书，由浅入深，详解Java语言的编程思想和核心技术&#39;);INSERT INTO `tbl_book` VALUES (&#39;10&#39;, &#39;市场营销&#39;, &#39;直播就该这么做:主播高效沟通实战指南&#39;, &#39;李子柒、李佳琦、薇娅成长为网红的秘密都在书中&#39;);INSERT INTO `tbl_book` VALUES (&#39;11&#39;, &#39;市场营销&#39;, &#39;直播销讲实战一本通&#39;, &#39;和秋叶一起学系列网络营销书籍&#39;);INSERT INTO `tbl_book` VALUES (&#39;12&#39;, &#39;市场营销&#39;, &#39;直播带货:淘宝、天猫直播从新手到高手&#39;, &#39;一本教你如何玩转直播的书， 10堂课轻松实现带货月入3W+&#39;);小结: 勾选SpringMVC与MySQL坐标 修改配置文件为yml格式 设置端口为80方便访问server: port: 80 Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发&amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; lombok版本由SpringBoot提供，无需指定版本 常用注解：@Data@Datapublic class Book { private Integer id; private String type; private String name; private String description;} 为当前实体类在编译期设置对应的get/set方法，toString方法，hashCode方法，equals方法等小结:1. 实体类制作2. 使用lombok简化开发 导入lombok无需指定版本，由SpringBoot提供版本 @Data注解 导入MyBatisPlus与Druid对应的starter&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.4.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置数据源与MyBatisPlus对应的基础配置（id生成策略使用数据库自增策略）# druid 数据源配制spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC username: root password: 123456# mybatis-plusmybatis-plus: global-config: db-config: table-prefix: tbl_ id-type: auto # 主键策略 继承BaseMapper并指定泛型@Mapperpublic interface BookDao extends BaseMapper&amp;lt;Book&amp;gt; { /** * 查询一个 * 这是 Mybatis 开发 * @param id * @return */ @Select(&quot;select * from tbl_book where id = #{id}&quot;) Book getById(Integer id);} 制作测试类测试结果@SpringBootTestpublic class BookDaoTestCase { @Autowired private BookDao bookDao; @Test void testGetById() { System.out.println(bookDao.getById(1)); System.out.println(bookDao.selectById(1)); } @Test void testSave() { Book book = new Book(); book.setType(&quot;测试数据123&quot;); book.setName(&quot;测试数据123&quot;); book.setDescription(&quot;测试数据123&quot;); bookDao.insert(book); } @Test void testUpdate() { Book book = new Book(); book.setId(13); book.setType(&quot;测试数据asfd&quot;); book.setName(&quot;测试数据123&quot;); book.setDescription(&quot;测试数据123&quot;); bookDao.updateById(book); } @Test void testDelete() { bookDao.deleteById(13); } @Test void testGetAll() { System.out.println(bookDao.selectList(null)); } @Test void testGetPage() { } @Test void testGetBy() { }}小结: 手工导入starter坐标（2个） 配置数据源与MyBatisPlus对应的配置 开发Dao接口（继承BaseMapper） 制作测试类测试Dao功能是否有效 为方便调试可以开启MyBatisPlus的日志# mybatis-plusmybatis-plus: global-config: db-config: table-prefix: tbl_ id-type: auto # 主键策略 configuration: # 开启MyBatisPlus的日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl小结: 使用配置方式开启日志，设置日志输出方式为标准输出 分页操作需要设定分页对象IPage@Test void testGetPage() { IPage page = new Page(1, 5); bookDao.selectPage(page, null); } IPage对象中封装了分页操作中的所有数据 数据 当前页码值 每页数据总量 最大页码值 数据总量 分页操作是在MyBatisPlus的常规操作基础上增强得到，内部是动态的拼写SQL语句，因此需要增强对应的功能， 使用MyBatisPlus拦截器实现@Configurationpublic class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { //1. 定义 Mp 拦截器 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //2. 添加具体的拦截器 分页拦截器 interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return interceptor; }} 测试@Test void testGetPage() { IPage page = new Page(1, 5); bookDao.selectPage(page, null); System.out.println(page.getCurrent()); System.out.println(page.getSize()); System.out.println(page.getPages()); System.out.println(page.getTotal()); System.out.println(page.getRecords()); } 小结: 使用IPage封装分页数据 分页操作依赖MyBatisPlus分页拦截器实现功能 借助MyBatisPlus日志查阅执行SQL语句 使用QueryWrapper对象封装查询条件，推荐使用LambdaQueryWrapper对象，所有查询操作封装成方法调用@Test void testGetBy2() { LambdaQueryWrapper&amp;lt;Book&amp;gt; lambdaQueryWrapper = new LambdaQueryWrapper&amp;lt;&amp;gt;(); lambdaQueryWrapper.like(Book::getName, &quot;Spring&quot;); bookDao.selectList(lambdaQueryWrapper); }@Test void testGetBy() { QueryWrapper&amp;lt;Book&amp;gt; queryWrapper = new QueryWrapper&amp;lt;&amp;gt;(); queryWrapper.like(&quot;name&quot;, &quot;Spring&quot;); bookDao.selectList(queryWrapper); } 支持动态拼写查询条件@Test void testGetBy2() { String name = &quot;1&quot;; LambdaQueryWrapper&amp;lt;Book&amp;gt; lambdaQueryWrapper = new LambdaQueryWrapper&amp;lt;&amp;gt;(); //if (name != null) lambdaQueryWrapper.like(Book::getName,name); lambdaQueryWrapper.like(Strings.isNotEmpty(name), Book::getName, name); bookDao.selectList(lambdaQueryWrapper); }小结: 使用QueryWrapper对象封装查询条件 推荐使用LambdaQueryWrapper对象 所有查询操作封装成方法调用 查询条件支持动态条件拼装 Service层接口定义与数据层接口定义具有较大区别，不要混用 selectByUserNameAndPassword(String username,String password); 数据层接口 login(String username,String password); Service层接口 接口定义public interface BookService { Boolean save(Book book); Boolean update(Book book); Boolean delete(Integer id); Book getById(Integer id); List&amp;lt;Book&amp;gt; getAll(); IPage&amp;lt;Book&amp;gt; getPage(int currentPage,int pageSize);} 实现类定义@Servicepublic class BookServiceImpl implements BookService { @Autowired private BookDao bookDao; @Override public Boolean save(Book book) { return bookDao.insert(book) &amp;gt; 0; } @Override public Boolean update(Book book) { return bookDao.updateById(book) &amp;gt; 0; } @Override public Boolean delete(Integer id) { return bookDao.deleteById(id) &amp;gt; 0; } @Override public Book getById(Integer id) { return bookDao.selectById(id); } @Override public List&amp;lt;Book&amp;gt; getAll() { return bookDao.selectList(null); } @Override public IPage&amp;lt;Book&amp;gt; getPage(int currentPage, int pageSize) { IPage page = new Page(currentPage, pageSize); bookDao.selectPage(page, null); return page; }} 测试类定义@SpringBootTestpublic class BookServiceTestCase { @Autowired private BookService bookService; @Test void testGetById() { System.out.println(bookService.getById(4)); } @Test void testSave() { Book book = new Book(); book.setType(&quot;测试数据123&quot;); book.setName(&quot;测试数据123&quot;); book.setDescription(&quot;测试数据123&quot;); bookService.save(book); } @Test void testUpdate() { Book book = new Book(); book.setId(14); book.setType(&quot;测试数据asfd&quot;); book.setName(&quot;测试数据123&quot;); book.setDescription(&quot;测试数据123&quot;); bookService.update(book); } @Test void testDelete() { bookService.delete(14); } @Test void testGetAll() { System.out.println(bookService.getAll()); } @Test void testGetPage() { IPage&amp;lt;Book&amp;gt; page = bookService.getPage(2, 5); System.out.println(page.getCurrent()); System.out.println(page.getSize()); System.out.println(page.getPages()); System.out.println(page.getTotal()); System.out.println(page.getRecords()); }}小结: Service接口名称定义成业务名称，并与Dao接口名称进行区分 制作测试类测试Service功能是否有效 快速开发方案 使用MyBatisPlus提供有业务层通用接口（ISerivce）与业务层通用实现类（ServiceImpl&amp;lt;M,T&amp;gt;） 在通用类基础上做功能重载或功能追加 注意重载时不要覆盖原始操作，避免原始提供的功能丢失 接口定义public interface IBookService extends IService&amp;lt;Book&amp;gt; { } 接口追加功能public interface IBookService extends IService&amp;lt;Book&amp;gt; { // 追加的操作与原始操作通过名称区分，功能类似 Boolean delete(Integer id); Boolean insert(Book book); Boolean modify(Book book); Book get(Integer id);} 实现类定义@Servicepublic class BookServiceImpl extends ServiceImpl&amp;lt;BookDao, Book&amp;gt; implements IBookService { } 实现类追加功能@Servicepublic class BookServiceImpl extends ServiceImpl&amp;lt;BookDao, Book&amp;gt; implements IBookService { @Autowired private BookDao bookDao; public Boolean insert(Book book) { return bookDao.insert(book) &amp;gt; 0; } public Boolean modify(Book book) { return bookDao.updateById(book) &amp;gt; 0; } public Boolean delete(Integer id) { return bookDao.deleteById(id) &amp;gt; 0; } public Book get(Integer id) { return bookDao.selectById(id); }} 测试类定义@SpringBootTestpublic class BookServiceTest { @Autowired private IBookService bookService; @Test void testGetById() { System.out.println(bookService.getById(4)); } @Test void testSave() { Book book = new Book(); book.setType(&quot;测试数据123&quot;); book.setName(&quot;测试数据123&quot;); book.setDescription(&quot;测试数据123&quot;); bookService.save(book); } @Test void testUpdate() { Book book = new Book(); book.setId(14); book.setType(&quot;===========&quot;); book.setName(&quot;测试数据123&quot;); book.setDescription(&quot;测试数据123&quot;); bookService.updateById(book); } @Test void testDelete() { bookService.removeById(14); } @Test void testGetAll() { System.out.println(bookService.list()); } @Test void testGetPage() { IPage&amp;lt;Book&amp;gt; page = new Page&amp;lt;&amp;gt;(2, 5); bookService.page(page); System.out.println(page.getCurrent()); System.out.println(page.getSize()); System.out.println(page.getPages()); System.out.println(page.getTotal()); System.out.println(page.getRecords()); }}小结： 使用通用接口（ISerivce）快速开发Service 使用通用实现类（ServiceImpl&amp;lt;M,T&amp;gt;）快速开发ServiceImpl 可以在通用接口基础上做功能重载或功能追加 注意重载时不要覆盖原始操作，避免原始提供的功能丢失 基于Restful进行表现层接口开发 使用Postman测试表现层接口功能表现层开发@RestController@RequestMapping(&quot;/books&quot;)public class BookController { @Autowired private IBookService bookService; @GetMapping public List&amp;lt;Book&amp;gt; getAll() { return bookService.list(); } @PostMapping public Boolean save(@RequestBody Book book) { return bookService.save(book); } @PutMapping public Boolean update(@RequestBody Book book) { return bookService.modify(book); } @DeleteMapping(&quot;{id}&quot;) public Boolean delete(@PathVariable Integer id) { return bookService.delete(id); } @GetMapping(&quot;{id}&quot;) public Book getById(@PathVariable Integer id) { return bookService.getById(id); } @GetMapping(&quot;{currentPage}/{pageSize}&quot;) public IPage&amp;lt;Book&amp;gt; getPage(@PathVariable Integer currentPage, @PathVariable int pageSize) { return bookService.getPage(currentPage, pageSize); }}添加 分页的业务层方法IBookServiceIPage&amp;lt;Book&amp;gt; getPage(int currentPage,int pageSize);BookServiceImpl@Override public IPage&amp;lt;Book&amp;gt; getPage(int currentPage, int pageSize) { IPage page = new Page(currentPage, pageSize); bookDao.selectPage(page, null); return page; }功能测试 小结: 基于Restful制作表现层接口 新增：POST 删除：DELETE 修改：PUT 查询：GET接收参数 实体数据：@RequestBody 路径变量：@PathVariable 之前的格式 增加一个 data 属性，把数据全部封装到 data 里 当数据为 null 可能出现的问题 - 查询id不存在的数据，返回 null - 查询过程中抛出异常，catch 中返回 null 增加 一个状态属性 设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议@Datapublic class R { private Boolean flag; private Object data; public R() { } /** * 不返回数据的构造方法 * * @param flag */ public R(Boolean flag) { this.flag = flag; } /** * 返回数据的构造方法 * * @param flag * @param data */ public R(Boolean flag, Object data) { this.flag = flag; this.data = data; }} 表现层接口统一返回值类型结果@RestController@RequestMapping(&quot;/books&quot;)public class BookController { @Autowired private IBookService bookService; @GetMapping public R getAll() { return new R(true, bookService.list()); } @PostMapping public R save(@RequestBody Book book) { return new R(bookService.save(book)); } @PutMapping public R update(@RequestBody Book book) { return new R(bookService.modify(book)); } @DeleteMapping(&quot;{id}&quot;) public R delete(@PathVariable Integer id) { return new R(bookService.delete(id)); } @GetMapping(&quot;{id}&quot;) public R getById(@PathVariable Integer id) { return new R(true, bookService.getById(id)); } @GetMapping(&quot;{currentPage}/{pageSize}&quot;) public R getPage(@PathVariable Integer currentPage, @PathVariable int pageSize) { return new R(true, bookService.getPage(currentPage, pageSize)); }}小结： 设计统一的返回值结果类型便于前端开发读取数据 返回值结果类型可以根据需求自行设定，没有固定格式 返回值结果模型类用于后端与前端进行数据格式统一，也称为前 后端数据协议使用VUE的方法时提示报错：Method definition shorthands are not supported by current JavaScript version表示：该方法定义的缺陷是不支持当前的JavaScript版本，虽然可以程序可以正常运行，但是这个方法会出现红色的波浪线，很不爽解决： 打开 File -&amp;gt; Settings -&amp;gt; Languages &amp;amp; Frameworks -&amp;gt; Javascript 把JavaScript版本为ECMAScript 6就可以了 前后端分离结构设计中页面归属前端服务器 单体工程中页面放置在resources目录下的static目录中（建议执行clean） 前端发送异步请求，调用后端接口//钩子函数，VUE对象初始化完成后自动执行 created() { //调用查询全部数据的操作 this.getAll(); },//列表 getAll() { //发送异步请求 axios.get(&quot;/books&quot;).then((res)=&amp;gt;{ console.log(res.data); }) }, 小结： 单体项目中页面放置在resources/static目录下 created钩子函数用于初始化页面时发起调用 页面使用axios发送异步请求获取数据后确认前后端是否联通 列表页//列表 getAll() { //发送异步请求 axios.get(&quot;/books&quot;).then((res) =&amp;gt; { //console.log(res.data); this.dataList = res.data.data; }) },小结： 将查询数据返回到页面，利用前端数据双向绑定进行数据展示 弹出添加窗口// 弹出添加窗口handleCreate() { this.dialogFormVisible = true;}, 清除数据//重置表单 resetForm() { this.formData = { }; }, 在弹出添加窗口时 清除数据//弹出添加窗口 handleCreate() { this.dialogFormVisible = true; this.resetForm(); }, 发送添加请求//添加 handleAdd() { axios.post(&quot;/books&quot;, this.formData).then((res) =&amp;gt; { //判断当前操作是否成功 if (res.data.flag) { //1.关闭弹层 this.dialogFormVisible = false; this.$message.success(&quot;添加成功&quot;); } else { this.$message.error(&quot;添加失败&quot;); } }).finally(() =&amp;gt; { //2.重新加载数据 this.getAll(); }) }, 取消添加//取消 cancel() { //1.关闭弹层 this.dialogFormVisible = false; //2.提示用户 this.$message.info(&quot;当前操作取消&quot;); },小结: 请求方式使用POST调用后台对应操作 添加操作结束后动态刷新页面加载数据 根据操作结果不同，显示对应的提示信息 弹出添加Div时清除表单数据 删除// 删除 handleDelete(row) { axios.delete(&quot;/books/&quot; + row.id).then((res) =&amp;gt; { if (res.data.flag) { this.$message.success(&quot;删除成功&quot;); } else { this.$message.error(&quot;删除失败&quot;); } }).finally(() =&amp;gt; { this.getAll(); }); } 加入确认删除对话框// 删除 handleDelete(row) { //1. 弹出提示框 this.$confirm(&quot;些操作永久删除当前信息,是否继续?&quot;, &quot;提示&quot;, { type: &quot;info&quot;}).then(() =&amp;gt; { //2. 做删除业务 axios.delete(&quot;/books/&quot; + row.id).then((res) =&amp;gt; { //判断当前操作是否成功 if (res.data.flag) { this.$message.success(&quot;删除成功&quot;); } else { this.$message.error(&quot;删除失败&quot;); } }).finally(() =&amp;gt; { //2.重新加载数据 this.getAll(); }) }).catch(() =&amp;gt; { //3. 取消删除 this.$message.info(&quot;取消操作&quot;); }); },小结: 请求方式使用Delete调用后台对应操作 删除操作需要传递当前行数据对应的id值到后台 删除操作结束后动态刷新页面加载数据 根据操作结果不同，显示对应的提示信息 删除操作前弹出提示框避免误操作 弹出修改窗口//弹出编辑窗口 handleUpdate(row) { axios.get(&quot;/books/&quot; + row.id).then((res) =&amp;gt; { if (res.data.flag &amp;amp;&amp;amp; res.data.data != null) { // 展示弹层，加载数据 this.dialogFormVisible4Edit = true; this.formData = res.data.data; } else { this.$message.error(&quot;数据同步失败，自动刷新&quot;); } }).finally(() =&amp;gt; { //重新加载数据 this.getAll(); }); }, 删除消息维护// 删除 handleDelete(row) { //1. 弹出提示框 this.$confirm(&quot;些操作永久删除当前信息,是否继续?&quot;, &quot;提示&quot;, { type: &quot;info&quot;}).then(() =&amp;gt; { //2. 做删除业务 axios.delete(&quot;/books/&quot; + row.id).then((res) =&amp;gt; { //判断当前操作是否成功 if (res.data.flag) { this.$message.success(&quot;删除成功&quot;); } else { this.$message.error(&quot;数据同步失败，自动刷新&quot;); } }).finally(() =&amp;gt; { //2.重新加载数据 this.getAll(); }); }).catch(() =&amp;gt; { //3. 取消删除 this.$message.info(&quot;取消操作&quot;); }); },小结: 加载要修改数据通过传递当前行数据对应的id值到后台查询数据 利用前端数据双向绑定将查询到的数据进行回显 修改//修改 handleEdit() { axios.put(&quot;/books&quot;, this.formData).then((res) =&amp;gt; { //判断当前操作是否成功 if (res.data.flag) { //1.关闭弹层 this.dialogFormVisible4Edit = false; this.$message.success(&quot;修改成功&quot;); } else { this.$message.error(&quot;修改失败&quot;); } }).finally(() =&amp;gt; { //2.重新加载数据 this.getAll(); }); }, 取消添加和修改//取消 cancel() { //1.关闭弹层 this.dialogFormVisible = false; this.dialogFormVisible4Edit = false; //2.提示用户 this.$message.info(&quot;当前操作取消&quot;); },小结: 请求方式使用PUT调用后台对应操作 修改操作结束后动态刷新页面加载数据（同新增） 根据操作结果不同，显示对应的提示信息（同新增） 业务操作成功或失败返回数据格式{ &quot;flag&quot;: true, &quot;data&quot;: null}{ &quot;flag&quot;: false, &quot;data&quot;: null} 后台代码BUG导致数据格式不统一性{ &quot;timestamp&quot;: &quot;2021-11-07T12:44:29.343+00:00&quot;, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;path&quot;: &quot;/books&quot;} 对异常进行统一处理，出现异常后，返回指定信息@RestControllerAdvicepublic class ProjectExceptionAdvice { //拦截所有的异常信息 @ExceptionHandler(Exception.class) public R doException(Exception ex) { // 记录日志 // 发送消息给运维 // 发送邮件给开发人员 ,ex 对象发送给开发人员 ex.printStackTrace(); return new R(false, null, &quot;系统错误，请稍后再试！&quot;); }} 修改表现层返回结果的模型类，封装出现异常后对应的信息 flag：false Data: null 消息(msg): 要显示信息@Datapublic class R{ private Boolean flag; private Object data; private String msg; public R(Boolean flag,Object data,String msg){ this.flag = flag; this.data = data; this.msg = msg; }} 页面消息处理，没有传递消息加载默认消息，传递消息后加载指定消息//添加 handleAdd() { axios.post(&quot;/books&quot;, this.formData).then((res) =&amp;gt; { //判断当前操作是否成功 if (res.data.flag) { //1.关闭弹层 this.dialogFormVisible = false; this.$message.success(&quot;添加成功&quot;); } else { this.$message.error(res.data.msg); } }).finally(() =&amp;gt; { //2.重新加载数据 this.getAll(); }) }, 可以在表现层Controller中进行消息统一处理@PostMapping public R save(@RequestBody Book book) throws IOException { //if (book.getName().equals(&quot;123&quot;)) throw new IOException(); boolean flag = bookService.save(book); return new R(flag, flag ? &quot;添加成功^_^&quot; : &quot;添加失败-_-!&quot;); } 页面消息处理//添加 handleAdd() { axios.post(&quot;/books&quot;, this.formData).then((res) =&amp;gt; { //判断当前操作是否成功 if (res.data.flag) { //1.关闭弹层 this.dialogFormVisible = false; this.$message.success(res.data.msg); } else { this.$message.error(res.data.msg); } }).finally(() =&amp;gt; { //2.重新加载数据 this.getAll(); }) },小结: 使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的 异常处理器必须被扫描加载，否则无法生效 表现层返回结果的模型类中添加消息属性用来传递消息到页面 页面使用 el 分页组件添加分页功能&amp;lt;!--分页组件--&amp;gt; &amp;lt;div class=&quot;pagination-container&quot;&amp;gt; &amp;lt;el-pagination class=&quot;pagiantion&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pagination.currentPage&quot; :page-size=&quot;pagination.pageSize&quot; layout=&quot;total, prev, pager, next, jumper&quot; :total=&quot;pagination.total&quot;&amp;gt; &amp;lt;/el-pagination&amp;gt; &amp;lt;/div&amp;gt; 定义分页组件需要使用的数据并将数据绑定到分页组件data: { pagination: { // 分页相关模型数据 currentPage: 1, // 当前页码 pageSize: 10, // 每页显示的记录数 total: 0, // 总记录数 }}, 替换查询全部功能为分页功能getAll() { axios.get(&quot;/books/&quot; + this.pagination.currentPage + &quot;/&quot; + this.pagination.pageSize).then((res) =&amp;gt; { });}, 分页查询 使用路径参数传递分页数据或封装对象传递数据@GetMapping(&quot;{currentPage}/{pageSize}&quot;) public R getPage(@PathVariable Integer currentPage, @PathVariable int pageSize) { return new R(true, bookService.getPage(currentPage, pageSize)); } 加载分页数据//分页查询 getAll() { //发送异步请求 axios.get(&quot;/books/&quot; + this.pagination.currentPage + &quot;/&quot; + this.pagination.pageSize).then((res) =&amp;gt; { //console.log(res.data); this.pagination.currentPage = res.data.data.current; this.pagination.pageSize = res.data.data.size; this.pagination.total = res.data.data.total; this.dataList = res.data.data.records; }) }, 分页页码值切换//切换页码 handleCurrentChange(currentPage) { //修改页码值为当前选中的页码值 this.pagination.currentPage = currentPage; //执行查询 this.getAll(); },小结: 使用el分页组件 定义分页组件绑定的数据模型 异步调用获取分页数据 分页数据页面回显 对查询结果进行校验，如果当前页码值大于最大页码值，使用最大页码值作为当前页码值重新查询@GetMapping(&quot;{currentPage}/{pageSize}&quot;) public R getPage(@PathVariable Integer currentPage, @PathVariable int pageSize) { IPage&amp;lt;Book&amp;gt; page = bookService.getPage(currentPage, pageSize); // 如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值 if (currentPage &amp;gt; page.getPages()) { page = bookService.getPage((int) page.getPages(), pageSize); } return new R(true, page); }小结: 基于业务需求维护删除功能 查询条件数据封装 单独封装 与分页操作混合封装pagination: { //分页相关模型数据 currentPage: 1,//当前页码 pageSize: 10,//每页显示的记录数 total: 0,//总记录数 type: &quot;&quot;, name: &quot;&quot;, description: &quot;&quot; } 页面数据模型绑定&amp;lt;div class=&quot;filter-container&quot;&amp;gt; &amp;lt;el-input placeholder=&quot;图书类别&quot; v-model=&quot;pagination.type&quot; class=&quot;filter-item&quot; /&amp;gt; &amp;lt;el-input placeholder=&quot;图书名称&quot; v-model=&quot;pagination.name&quot; class=&quot;filter-item&quot; /&amp;gt; &amp;lt;el-input placeholder=&quot;图书描述&quot; v-model=&quot;pagination.description&quot; class=&quot;filter-item&quot; /&amp;gt; &amp;lt;el-button @click=&quot;getAll()&quot; class=&quot;dalfBut&quot;&amp;gt;查询&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&quot;primary&quot; class=&quot;butT&quot; @click=&quot;handleCreate()&quot;&amp;gt;新建&amp;lt;/el-button&amp;gt;&amp;lt;/div&amp;gt; 组织数据成为get请求发送的数据//分页查询 getAll() { console.log(this.pagination.type); // /books/1/10?type=???&amp;amp;name=???&amp;amp;decription=?? ; //1. 获取查询条件 , 拼接查询条件 param = &quot;?name=&quot; + this.pagination.name; param += &quot;&amp;amp;type=&quot; + this.pagination.type; param += &quot;&amp;amp;description=&quot; + this.pagination.description; //console.log(&quot;-----------------&quot; + param); //发送异步请求 axios.get(&quot;/books/&quot; + this.pagination.currentPage + &quot;/&quot; + this.pagination.pageSize + param).then((res) =&amp;gt; { //console.log(res.data); this.pagination.currentPage = res.data.data.current; this.pagination.pageSize = res.data.data.size; this.pagination.total = res.data.data.total; this.dataList = res.data.data.records; }) }, 条件参数组织可以通过条件判定书写的更简洁 Controller接收参数@GetMapping(&quot;{currentPage}/{pageSize}&quot;)public R getAll(@PathVariable int currentPage,@PathVariable int pageSize,Book book) { System.out.println(&quot;参数=====&amp;gt;&quot;+book); IPage&amp;lt;Book&amp;gt; pageBook = bookService.getPage(currentPage,pageSize); return new R(null != pageBook ,pageBook);} 业务层接口功能开发/** * 分页的条件查询 * * @param currentPage * @param pageSize * @param book * @return */ IPage&amp;lt;Book&amp;gt; getPage(Integer currentPage, int pageSize, Book book); 业务层接口实现类功能开发@Override public IPage&amp;lt;Book&amp;gt; getPage(Integer currentPage, int pageSize, Book book) { LambdaQueryWrapper&amp;lt;Book&amp;gt; lambdaQueryWrapper = new LambdaQueryWrapper&amp;lt;&amp;gt;(); lambdaQueryWrapper.like(Strings.isNotEmpty(book.getType()), Book::getType, book.getType()); lambdaQueryWrapper.like(Strings.isNotEmpty(book.getName()), Book::getName, book.getName()); lambdaQueryWrapper.like(Strings.isNotEmpty(book.getDescription()), Book::getDescription, book.getDescription()); IPage page = new Page(currentPage, pageSize); bookDao.selectPage(page, lambdaQueryWrapper); return page; } Controller调用业务层分页条件查询接口@GetMapping(&quot;{currentPage}/{pageSize}&quot;) public R getPage(@PathVariable Integer currentPage, @PathVariable int pageSize, Book book) { // System.out.println(&quot;book=&amp;gt;&quot; + book); IPage&amp;lt;Book&amp;gt; page = bookService.getPage(currentPage, pageSize, book); // 如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值 if (currentPage &amp;gt; page.getPages()) { page = bookService.getPage((int) page.getPages(), pageSize, book); } return new R(true, page); } 页面回显数据//分页查询 getAll() { console.log(this.pagination.type); // /books/1/10?type=???&amp;amp;name=???&amp;amp;decription=?? ; //1. 获取查询条件 , 拼接查询条件 param = &quot;?name=&quot; + this.pagination.name; param += &quot;&amp;amp;type=&quot; + this.pagination.type; param += &quot;&amp;amp;description=&quot; + this.pagination.description; //console.log(&quot;-----------------&quot; + param); //发送异步请求 axios.get(&quot;/books/&quot; + this.pagination.currentPage + &quot;/&quot; + this.pagination.pageSize + param).then((res) =&amp;gt; { //console.log(res.data); this.pagination.currentPage = res.data.data.current; this.pagination.pageSize = res.data.data.size; this.pagination.total = res.data.data.total; this.dataList = res.data.data.records; }) },小结: 定义查询条件数据模型（当前封装到分页数据模型中） 异步调用分页功能并通过请求参数传递数据到后台基于SpringBoot的SSMP整合案例 pom.xml 配置起步依赖application.yml 设置数据源、端口、框架技术相关配置等dao 继承BaseMapper、设置@Mapper dao测试类service 调用数据层接口或MyBatis-Plus提供的接口快速开发 service测试类controller 基于Restful开发，使用Postman测试跑通功能页面 放置在resources目录下的static目录中总结: 整合JUint 整合MyBatis 整合MyBatis-Plus 整合Druid 基于SpringBoot的SSMP整合案例后续学习 基础篇 - 能够创建SpringBoot工程 - 基于SpringBoot实现ssm/ssmp整合 实用篇 - 运维实用篇 [Spring Boot 2 运维实用篇学习笔记](https://blog.csdn.net/qq_42324086/article/details/121386859) - 能够掌握SpringBoot程序多环境开发 - 能够基于Linux系统发布SpringBoot工程 - 能够解决线上灵活配置SpringBoot工程的需求 - 开发实用篇 - 能够基于SpringBoot整合任意第三方技术 原理篇内容介绍 打包与运行 配置高级 多环境开发 日志课程目标： 能够掌握SpringBoot程序多环境开发 能够基于Linux系统发布SpringBoot工程 能够解决线上灵活配置SpringBoot工程的需求程序为什么要打包将程序部署在独立的服务器上 SpringBoot项目快速启动（Windows版）步骤①：对SpringBoot项目打包（执行Maven构建指令package） 执行 package 打包命令之前 先执行 mvn clean 删除 target 目录及内容mvn package 打包完成 生成对应的 jar 文件 可能出现的问题: IDEA下 执行 Maven 命令控制台中文乱码 Ctr+Alt+S 打开设置，在Build，Execution ，Deployment找到Build Tools下Maven项下的Runner ，在VM Options 添加 -Dfile.encoding=GB2312 ，点击OK。 ②：运行项目（执行启动指令） java -jar &amp;lt;打包文件名&amp;gt;java –jar springboot.jar注意事项： jar支持命令行启动需要依赖maven插件支持，请确认打包时是否具有SpringBoot对应的maven插件&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 地址栏输入 cmd 回车 执行 java -jar springboot_08_ssmp-0.0.1-SNAPSHOT.jar ③：浏览器访问: http://localhost/pages/books.html打包优化：跳过 test 生命周期 小结: SpringBoot工程可以基于java环境下独立运行jar文件启动服务 SpringBoot工程执行mvn命令package进行打包 执行jar命令：java –jar 工程名.jar如果没有配制spring boot 打包插件可能遇到下面的问题: 使用SpringBoot提供的maven插件可以将工程打包成可执行jar包&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;可执行jar包目录结构jar包描述文件（MANIFEST.MF） 普通工程Manifest-Version: 1.0Implementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Jar Plugin 3.2.0 基于spring-boot-maven-plugin打包的工程Manifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.example.SSMPApplication 启动类Spring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.6Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher jar启动器命令行启动常见问题及解决方案 Windonws端口被占用# 查询端口netstat -ano# 查询指定端口netstat -ano |findstr &quot;端口号&quot;# 根据进程PID查询进程名称tasklist |findstr &quot;进程PID号&quot;# 根据PID杀死任务taskkill /F /PID &quot;进程PID号&quot;# 根据进程名称杀死任务taskkill -f -t -im &quot;进程名称&quot;D:\\code\\Java\\IdeaProjects\\springboot-study\\springboot_08_ssmp\\target&amp;gt;netstat -ano活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 30988 TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1792 TCP 0.0.0.0:443 0.0.0.0:0 LISTENING 9400 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:902 0.0.0.0:0 LISTENING 6188 TCP 0.0.0.0:912 0.0.0.0:0 LISTENING 6188 D:\\code\\Java\\IdeaProjects\\springboot-study\\springboot_08_ssmp\\target&amp;gt;netstat -ano |findstr &quot;80&quot; TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 30988 TCP 0.0.0.0:7680 0.0.0.0:0 LISTENING 4864 TCP 0.0.0.0:8680 0.0.0.0:0 LISTENING 7976 TCP 192.168.1.102:9808 119.96.138.240:443 ESTABLISHED 20604 TCP [::]:80 [::]:0 LISTENING 30988 TCP [::]:7680 [::]:0 LISTENING 4864 UDP 127.0.0.1:65312 *:* 5680 UDP [fe80::2952:170d:f2f2:1464%16]:1900 *:* 2872 UDP [fe80::2952:170d:f2f2:1464%16]:60720 *:* 2872 UDP [fe80::4c2b:9d2f:a625:8b1c%6]:1900 *:* 2872 UDP [fe80::4c2b:9d2f:a625:8b1c%6]:60719 *:* 2872 UDP [fe80::e1e0:a2c9:200:2f34%19]:1900 *:* 2872 UDP [fe80::e1e0:a2c9:200:2f34%19]:60721 *:* 2872 D:\\code\\Java\\IdeaProjects\\springboot-study\\springboot_08_ssmp\\target&amp;gt;tasklist |findstr &quot;30988&quot;java.exe 30988 Console 3 273,388 KD:\\code\\Java\\IdeaProjects\\springboot-study\\springboot_08_ssmp\\target&amp;gt;tasklist映像名称 PID 会话名 会话# 内存使用========================= ======== ================ =========== ============System Idle Process 0 Services 0 8 KSystem 4 Services 0 1,500 KRegistry 172 Services 0 94,584 Ksmss.exe 648 Services 0 1,084 Kcsrss.exe 1080 Services 0 5,888 Kwininit.exe 1320 Services 0 6,868 Kservices.exe 1436 Services 0 9,264 Klsass.exe 1488 Services 0 11,932 Ksvchost.exe 1612 Services 0 17,804 Kfontdrvhost.exe 1648 Services 0 488 KWUDFHost.exe 1688 Services 0 2,660 Ksvchost.exe 1792 Services 0 13,428 KWUDFHost.exe 1840 Services 0 2,628 Ksvchost.exe 1868 Services 0 3,460 KD:\\code\\Java\\IdeaProjects\\springboot-study\\springboot_08_ssmp\\target&amp;gt;taskkill /F /PID &quot;30988&quot;成功: 已终止 PID 为 30988 的进程。小结: spring-boot-maven-plugin插件作用 Windonws端口被占用 基于Linux（CenterOS7） 安装JDK，且版本不低于打包时使用的JDK版本 - 可以使用 yum 安装 安装 MySQL - 可以参考: [https://blog.csdn.net/qq_42324086/article/details/120579197](https://blog.csdn.net/qq_42324086/article/details/120579197) 安装包保存在/usr/local/自定义目录中或$HOME下 其他操作参照Windows版进行启动成功无法访问添加 80 端口 添加 端口firewall-cmd --zone=public --permanent --add-port=80/tcp 重启systemctl restart firewalld后台启动命令nohup java -jar springboot_08_ssmp-0.0.1-SNAPSHOT.jar &amp;gt; server.log 2&amp;gt;&amp;amp;1 &amp;amp;停止服务 ps -ef grep “java -jar” kill -9 PID cat server.log (查看日志)[root@cjbCentos01 app]# ps -ef | grep &quot;java -jar&quot;UID PID PPID C STIME TTY TIME CMDroot 6848 6021 7 14:45 pts/2 00:00:19 java -jar springboot_08_ssmp-0.0.1-SNAPSHOT.jarroot 6919 6021 0 14:49 pts/2 00:00:00 grep --color=auto java -jar[root@cjbCentos01 app]# kill -9 6848[root@cjbCentos01 app]# ps -ef | grep &quot;java -jar&quot;root 7016 6021 0 14:52 pts/2 00:00:00 grep --color=auto java -jar[1]+ 已杀死 nohup java -jar springboot_08_ssmp-0.0.1-SNAPSHOT.jar &amp;gt; server.log 2&amp;gt;&amp;amp;1[root@cjbCentos01 app]#小结: 上传安装包 执行jar命令：java –jar 工程名.jar总结: Boot程序打包依赖SpringBoot对应的Maven插件即可打包出可执行的jar包 运行jar包使用jar命令进行 Windows与Linux下执行Boot打包程序流程相同，仅需确保运行环境有效即可 带属性数启动SpringBootjava -jar springboot_08_ssmp-0.0.1-SNAPSHOT.jar --server.port=8080 携带多个属性启动SpringBoot，属性间使用空格分隔属性加载优先顺序 参看 https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config 小结: 使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性 临时属性添加方式：java –jar 工程名.jar –属性名=值 多个临时属性之间使用空格分隔 临时属性必须是当前boot工程支持的属性，否则设置无效 带属性启动SpringBoot程序，为程序添加运行属性 在启动类中 main 可以通过 System.out.println(Arrays.toString(args)); 查看配制的属性 通过编程形式带参数启动SpringBoot程序，为程序添加运行参数public static void main(String[] args) { String[] arg = new String[1]; arg[0] = &quot;--server.port=8080&quot;; SpringApplication.run(SSMPApplication.class, arg);} 不携带参数启动SpringBoot程序public static void main(String[] args) { //可以在启动boot程序时断开读取外部临时配置对应的入口，也就是去掉读取外部参数的形参 SpringApplication.run(SSMPApplication.class);}小结: 启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性配置文件分类 SpringBoot中4级配置文件 1. 1级：file ：config/application.yml **【最高】** 1. 2级：file ：application.yml 1. 3级：classpath：config/application.yml 1. 4级：classpath：application.yml **【最低】** 作用： 6. 1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控 6. 3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控 思 考: 如果yml与properties在不同层级中共存会是什么效果？ 例：类路径application.properties属性是否覆盖文件系统config目录中application.yml属性 properties文件的优先级大于yml文件 (properties文件会覆盖yml文件的配制) ​小结: 配置文件分为4种 项目类路径配置文件：服务于开发人员本机开发与测试 项目类路径config目录中配置文件：服务于项目经理整体调控 工程路径配置文件：服务于运维人员配置涉密线上环境 工程路径config目录中配置文件：服务于运维经理整体调控 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序 通过启动参数加载配置文件（无需书写配置文件扩展名) –spring.config.name=ebank properties与yml文件格式均支持 ​ 通过启动参数加载指定文件路径下的配置文件 –spring.config.location=classpath:/ebank.yml properties与yml文件格式均支持 通过启动参数加载指定文件路径下的配置文件时可以加载多个配置,后面的会覆盖前面的--spring.config.location=classpath:/ebank.yml,classpath:/ebank-server.yml 注意事项: 多配置文件常用于将配置进行分类，进行独立管理，或将可选配置单独制作便于上线更新维护 ​自定义配置文件——重要说明 单服务器项目：使用自定义配置文件需求较低 多服务器项目：使用自定义配置文件需求较高，将所有配置放置在一个目录中，统一管理 基于SpringCloud技术，所有的服务器将不再设置配置文件，而是通过配置中心进行设定，动态加载配置信息小结: 配置文件可以修改名称，通过启动参数设定 配置文件可以修改路径，通过启动参数设定 微服务开发中配置文件通过配置中心进行设置总结: SpringBoot在开发和运行环境均支持使用临时参数修改工程配置 SpringBoot支持4级配置文件，应用于开发与线上环境进行配置的灵活设置 SpringBoot支持使用自定义配置文件的形式修改配置文件存储位置 基于微服务开发时配置文件将使用配置中心进行管理多环境 多环境开发（YAML版） #应用环境#公共配制spring: profiles: active: dev#设置环境#开发环境---spring: config: activate: on-profile: devserver: port: 81#生产环境---spring: profiles: proserver: port: 80#测试环境---spring: profiles: testserver: port: 82小结: 多环境开发需要设置若干种常用环境，例如开发、生产、测试环境 yaml格式中设置多环境使用—区分环境设置边界 每种环境的区别在于加载的配置属性不同 启用某种环境时需要指定启动时使用该环境多环境开发（YAML版）多配置文件格式 主启动配置文件application.yml#应用环境#公共配制spring: profiles: active: test 环境分类配置文件application-pro.ymlserver: port: 81 环境分类配置文件application-dev.ymlserver: port: 82 环境分类配置文件application-test.ymlserver: port: 83多环境开发配置文件书写技巧（一） 主配置文件中设置公共配置（全局） 环境分类配置文件中常用于设置冲突属性（局部）小结: 可以使用独立配置文件定义环境属性 独立配置文件便于线上系统维护更新并保障系统安全性 主启动配置文件application.propertiesspring.profiles.active=dev 环境分类配置文件application-pro.propertiesserver.port=9081 环境分类配置文件application-dev.propertiesserver.port=9082 环境分类配置文件application-test.propertiesserver.port=9083小结: properties文件多环境配置仅支持多文件格式多环境开发独立配置文件书写技巧（二） 根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下 - application-devDB.yml - application-devRedis.yml - application-devMVC.yml 使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔spring: profiles: active: dev include: devDB,devMVC注意事项: 当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效The following profiles are active: devDB,devMVC,dev 从Spring2.4版开始使用group属性替代include属性，降低了配置书写量 使用group属性定义多种主环境与子环境的包含关系spring: profiles: active: dev group: &quot;dev&quot;: devDB,devMVC &quot;pro&quot;: proDB,proMVC &quot;test&quot;: testDB,testRedis,testMVC注意事项: 使用group属性，会覆盖 主环境dev (active) 的内容，最后加载的环境属性生效The following profiles are active: dev,devDB,devMVC小结： 多环境开发使用group属性设置配置文件分组，便于线上维护管理 Maven与SpringBoot多环境兼容 ①：Maven中设置多环境属性&amp;lt;!--Maven中设置多环境属性--&amp;gt; &amp;lt;profiles&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;dev_env&amp;lt;/id&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;dev&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;activation&amp;gt; &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt; &amp;lt;/activation&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;pro_env&amp;lt;/id&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;pro&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;test_env&amp;lt;/id&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;test&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;/profiles&amp;gt;②：SpringBoot中引用Maven属性spring: profiles: active: @profile.active@ group: &quot;dev&quot;: devDB,devMVC &quot;pro&quot;: proDB,proMVC ③：执行Maven打包指令，并在生成的boot打包文件.jar文件中查看对应信息 问题：修改pom.xml 文件后，启动没有生效 手动 compile 即可 或者 设置 IDEA进行自动编译 小结： 当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@…@占位符读取Maven对应的配置属性值 基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效总结： 多环境开发（YAML版） 多环境开发（Properties版） Maven与SpringBoot多环境冲突现象解决方案日志（log）作用 编程期调试代码 运营期记录信息 2. 记录日常运营重要信息（峰值流量、平均响应时长……） 2. 记录应用报错信息（错误堆栈） 2. 记录运维过程数据（扩容、宕机、报警……） 代码中使用日志工具记录日志 先引入 Lombok 工具类&amp;lt;!--lombok--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;①：添加日志记录操作@RestController@RequestMapping(&quot;/books&quot;)public class BookController { private static final Logger log = LoggerFactory.getLogger(BookController.class); @GetMapping public String getById() { System.out.println(&quot;springboot is running...&quot;); log.debug(&quot;debug ...&quot;); log.info(&quot;info ...&quot;); log.warn(&quot;warn ...&quot;); log.error(&quot;error ...&quot;); return &quot;springboot is running...&quot;; }} 日志级别TRACE：运行堆栈信息，使用率低 DEBUG：程序员调试代码使用 INFO：记录运维过程数据 WARN：记录运维过程报警数据 ERROR：记录错误堆栈信息 FATAL：灾难信息，合并计入ERROR ​②：设置日志输出级别# 开启 debug 模式，输出调试信息，常用于检查系统运行状况debug: true# 设置日志级别， root 表示根节点，即整体应用日志级别logging: level: root: debug③：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别logging: # 设置分组 group: # 自定义组名，设置当前组中所包含的包 ebank: com.example.controller,com.example.service,com.example.dao iservice: com.alibaba level: root: info # 设置某个包的日志级别# com.example.controller: debug # 为对应组设置日志级别 ebank: warn小结： 日志用于记录开发调试与运维过程消息 日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR 可以通过日志组或代码包的形式进行日志显示级别的控制 使用lombok提供的注解@Slf4j简化开发，减少日志对象的声明操作@Slf4j//Rest模式@RestController@RequestMapping(&quot;/books&quot;)public class BookController { @GetMapping public String getById(){ System.out.println(&quot;springboot is running...2&quot;); log.debug(&quot;debug...&quot;); log.info(&quot;info...&quot;); log.warn(&quot;warn...&quot;); log.error(&quot;error...&quot;); return &quot;springboot is running...2&quot;; }}小结： 基于lombok提供的@Slf4j注解为类快速添加日志对象 PID：进程ID，用于表明当前操作所处的进程，当多服务同时记录日志时，该值可用于协助程序员调试程序 所属类/接口名：当前显示信息为SpringBoot重写后的信息，名称过长时，简化包名书写为首字母，甚至直接删除 设置日志输出格式logging: pattern: console: &quot;%d - %m%n&quot;%d：日期 %m：消息 %n：换行 logging: pattern:# console: &quot;%d - %m%n&quot; console: &quot;%d %clr(%5p) --- [%16t] %clr(%-40.40c){cyan} : %m %n&quot;小结： 日志输出格式设置规则 设置日志文件logging: file: name: server.log 日志文件详细配置logging: file: name: server.log logback: rollingpolicy: max-file-size: 4KB file-name-pattern: server.%d{ yyyy-MM-dd}.%i.log小结： 日志记录到文件 日志文件格式设置总结： 日志基础使用规则 编辑日志输出格式 日志文件设置" }, { "title": "MyBatis", "url": "/posts/MyBatis/", "categories": "框架, MyBatis", "tags": "", "date": "2022-07-12 00:00:00 +0800", "snippet": "Mybatis简介MyBatis历史MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到GithubiBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis特性 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 MyBatis 是一个半自动的ORM（Object Relation Mapping）框架MyBatis下载 MyBatis下载地址 和其它持久化层技术对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生产的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于HIbernate，但是完全能够接受 搭建MyBatis开发环境 IDE：idea 2019.2 构建工具：maven 3.5.4 MySQL版本：MySQL 5.7 MyBatis版本：MyBatis 3.5.7创建maven工程 打包方式：jar 引入依赖&amp;lt;dependencies&amp;gt; &amp;lt;!-- Mybatis核心 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- junit测试 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MySQL驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;创建MyBatis的核心配置文件 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息核心配置文件存放的位置是src/main/resources目录下&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;!--设置连接数据库的环境--&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/MyBatis&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;!--引入映射文件--&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt;创建mapper接口 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类package com.atguigu.mybatis.mapper; public interface UserMapper { /** * 添加用户信息 */ int insertUser(); }创建MyBatis的映射文件 相关概念：ORM（Object Relationship Mapping）对象关系映射。 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段/列 对象 记录/行 映射文件的命名规则 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下 MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt; &amp;lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&amp;gt; &amp;lt;!--int insertUser();--&amp;gt; &amp;lt;insert id=&quot;insertUser&quot;&amp;gt; insert into t_user values(null,&#39;张三&#39;,&#39;123&#39;,23,&#39;女&#39;) &amp;lt;/insert&amp;gt; &amp;lt;/mapper&amp;gt;通过junit测试功能 SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂” 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象public class UserMapperTest { @Test public void testInsertUser() throws IOException { //读取MyBatis的核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务 //SqlSession sqlSession = sqlSessionFactory.openSession(); //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 SqlSession sqlSession = sqlSessionFactory.openSession(true); //通过代理模式创建UserMapper接口的代理实现类对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句 int result = userMapper.insertUser(); //提交事务 //sqlSession.commit(); System.out.println(&quot;result:&quot; + result); }} 此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用SqlSession sqlSession = sqlSessionFactory.openSession(true);，传入一个Boolean类型的参数，值为true，这样就可以自动提交加入log4j日志功能1.加入依赖&amp;lt;!-- log4j日志 --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;2.加入log4j的配置文件log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下日志的级别：FATAL(致命) &amp;gt; ERROR(错误) &amp;gt; WARN(警告) &amp;gt; INFO(信息) &amp;gt; DEBUG(调试) 从左到右打印的内容越来越详细&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&amp;lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&amp;gt;&amp;lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&amp;gt; &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&amp;gt; &amp;lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&amp;gt; &amp;lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&amp;gt; &amp;lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n&quot; /&amp;gt; &amp;lt;/layout&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;logger name=&quot;java.sql&quot;&amp;gt; &amp;lt;level value=&quot;debug&quot; /&amp;gt; &amp;lt;/logger&amp;gt; &amp;lt;logger name=&quot;org.apache.ibatis&quot;&amp;gt; &amp;lt;level value=&quot;info&quot; /&amp;gt; &amp;lt;/logger&amp;gt; &amp;lt;root&amp;gt; &amp;lt;level value=&quot;debug&quot; /&amp;gt; &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt; &amp;lt;/root&amp;gt;&amp;lt;/log4j:configuration&amp;gt;核心配置文件详解 核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//MyBatis.org//DTD Config 3.0//EN&quot; &quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&amp;gt; &amp;lt;properties resource=&quot;jdbc.properties&quot;&amp;gt;&amp;lt;/properties&amp;gt; &amp;lt;settings&amp;gt; &amp;lt;!--将表中字段的下划线自动转换为驼峰--&amp;gt; &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;!--开启延迟加载--&amp;gt; &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;/settings&amp;gt; &amp;lt;typeAliases&amp;gt; &amp;lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --&amp;gt; &amp;lt;!--&amp;lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&amp;gt;&amp;lt;/typeAlias&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&amp;gt; &amp;lt;/typeAlias&amp;gt;--&amp;gt; &amp;lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&amp;gt; &amp;lt;package name=&quot;com.atguigu.mybatis.bean&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; &amp;lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&amp;gt; &amp;lt;environments default=&quot;mysql_test&quot;&amp;gt; &amp;lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --&amp;gt; &amp;lt;environment id=&quot;mysql_test&quot;&amp;gt; &amp;lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot; type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理 type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP --&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot; type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建 type=&quot;JNDI&quot;：调用上下文中的数据源 --&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;!--设置驱动类的全类名--&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&amp;gt; &amp;lt;!--设置连接数据库的连接地址--&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&amp;gt; &amp;lt;!--设置连接数据库的用户名--&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&amp;gt; &amp;lt;!--设置连接数据库的密码--&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;!--引入映射文件--&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;!-- &amp;lt;mapper resource=&quot;UserMapper.xml&quot;/&amp;gt; --&amp;gt; &amp;lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --&amp;gt; &amp;lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&amp;gt; &amp;lt;/mappers&amp;gt;&amp;lt;/configuration&amp;gt;默认的类型别名MyBatis的增删改查 添加&amp;lt;!--int insertUser();--&amp;gt;&amp;lt;insert id=&quot;insertUser&quot;&amp;gt; insert into t_user values(null,&#39;admin&#39;,&#39;123456&#39;,23,&#39;男&#39;,&#39;12345@qq.com&#39;)&amp;lt;/insert&amp;gt; 删除&amp;lt;!--int deleteUser();--&amp;gt;&amp;lt;delete id=&quot;deleteUser&quot;&amp;gt; delete from t_user where id = 6&amp;lt;/delete&amp;gt; 修改&amp;lt;!--int updateUser();--&amp;gt;&amp;lt;update id=&quot;updateUser&quot;&amp;gt; update t_user set username = &#39;张三&#39; where id = 5&amp;lt;/update&amp;gt; 查询一个实体类对象&amp;lt;!--User getUserById();--&amp;gt; &amp;lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&amp;gt; select * from t_user where id = 2 &amp;lt;/select&amp;gt; 查询集合&amp;lt;!--List&amp;lt;User&amp;gt; getUserList();--&amp;gt;&amp;lt;select id=&quot;getUserList&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&amp;gt; select * from t_user&amp;lt;/select&amp;gt;注意：1.查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系①resultType：自动映射，用于属性名和表中字段名一致的情况②resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况2.当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值MyBatis获取参数值的两种方式（重点）MyBatis获取参数值的两种方式：${}和#{} ${}的本质就是字符串拼接，#{}的本质就是占位符赋值 ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号单个字面量类型的参数若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号&amp;lt;!--User getUserByUsername(String username);--&amp;gt;&amp;lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user where username = #{username}&amp;lt;/select&amp;gt;&amp;lt;!--User getUserByUsername(String username);--&amp;gt;&amp;lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user where username = &#39;${username}&#39; &amp;lt;/select&amp;gt;多个字面量类型的参数 若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中 以arg0,arg1…为键，以参数为值； 以param1,param2…为键，以参数为值； 因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。 使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的&amp;lt;!--User checkLogin(String username,String password);--&amp;gt;&amp;lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user where username = #{arg0} and password = #{arg1} &amp;lt;/select&amp;gt;&amp;lt;!--User checkLogin(String username,String password);--&amp;gt;&amp;lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user where username = &#39;${param1}&#39; and password = &#39;${param2}&#39;&amp;lt;/select&amp;gt;map集合类型的参数若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号&amp;lt;!--User checkLoginByMap(Map&amp;lt;String,Object&amp;gt; map);--&amp;gt;&amp;lt;select id=&quot;checkLoginByMap&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user where username = #{username} and password = #{password}&amp;lt;/select&amp;gt;@Testpublic void checkLoginByMap() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.put(&quot;usermane&quot;,&quot;admin&quot;); map.put(&quot;password&quot;,&quot;123456&quot;); User user = mapper.checkLoginByMap(map); System.out.println(user);}实体类类型的参数若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号&amp;lt;!--int insertUser(User user);--&amp;gt;&amp;lt;insert id=&quot;insertUser&quot;&amp;gt; insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})&amp;lt;/insert&amp;gt;@Testpublic void insertUser() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); User user = new User(null,&quot;Tom&quot;,&quot;123456&quot;,12,&quot;男&quot;,&quot;123@321.com&quot;); mapper.insertUser(user);}使用@Param标识参数 可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 以@Param注解的value属性值为键，以参数为值； 以param1,param2…为键，以参数为值； 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号&amp;lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&amp;gt; &amp;lt;select id=&quot;CheckLoginByParam&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user where username = #{username} and password = #{password} &amp;lt;/select&amp;gt;@Testpublic void checkLoginByParam() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); mapper.CheckLoginByParam(&quot;admin&quot;,&quot;123456&quot;);}总结 建议分成两种情况进行处理 实体类类型的参数 使用@Param标识参数 MyBatis的各种查询功能 如果查询出的数据只有一条，可以通过 实体类对象接收 List集合接收 Map集合接收，结果{password=123456, sex=男, id=1, age=23, username=admin} 如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过 实体类类型的LIst集合接收 Map类型的LIst集合接收 在mapper接口的方法上添加@MapKey注解 查询一个实体类对象/** * 根据用户id查询用户信息 * @param id * @return */User getUserById(@Param(&quot;id&quot;) int id);&amp;lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&amp;gt;&amp;lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user where id = #{id}&amp;lt;/select&amp;gt;查询一个List集合/** * 查询所有用户信息 * @return */List&amp;lt;User&amp;gt; getUserList();&amp;lt;!--List&amp;lt;User&amp;gt; getUserList();--&amp;gt;&amp;lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&amp;gt; select * from t_user&amp;lt;/select&amp;gt;查询单个数据/** * 查询用户的总记录数 * @return * 在MyBatis中，对于Java中常用的类型都设置了类型别名 * 例如：java.lang.Integer--&amp;gt;int|integer * 例如：int--&amp;gt;_int|_integer * 例如：Map--&amp;gt;map,List--&amp;gt;list */ int getCount();&amp;lt;!--int getCount();--&amp;gt;&amp;lt;select id=&quot;getCount&quot; resultType=&quot;_integer&quot;&amp;gt; select count(id) from t_user&amp;lt;/select&amp;gt;查询一条数据为map集合/** * 根据用户id查询用户信息为map集合 * @param id * @return */ Map&amp;lt;String, Object&amp;gt; getUserToMap(@Param(&quot;id&quot;) int id);&amp;lt;!--Map&amp;lt;String, Object&amp;gt; getUserToMap(@Param(&quot;id&quot;) int id);--&amp;gt;&amp;lt;select id=&quot;getUserToMap&quot; resultType=&quot;map&quot;&amp;gt; select * from t_user where id = #{id}&amp;lt;/select&amp;gt;&amp;lt;!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--&amp;gt;查询多条数据为map集合方法一/** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取 */ List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; getAllUserToMap();&amp;lt;!--Map&amp;lt;String, Object&amp;gt; getAllUserToMap();--&amp;gt; &amp;lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&amp;gt; select * from t_user &amp;lt;/select&amp;gt;&amp;lt;!-- 结果： [{password=123456, sex=男, id=1, age=23, username=admin}, {password=123456, sex=男, id=2, age=23, username=张三}, {password=123456, sex=男, id=3, age=23, username=张三}]--&amp;gt;方法二/** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合 */@MapKey(&quot;id&quot;)Map&amp;lt;String, Object&amp;gt; getAllUserToMap();&amp;lt;!--Map&amp;lt;String, Object&amp;gt; getAllUserToMap();--&amp;gt;&amp;lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&amp;gt; select * from t_user&amp;lt;/select&amp;gt;&amp;lt;!-- 结果： { 1={password=123456, sex=男, id=1, age=23, username=admin}, 2={password=123456, sex=男, id=2, age=23, username=张三}, 3={password=123456, sex=男, id=3, age=23, username=张三} }--&amp;gt;特殊SQL的执行模糊查询/** * 根据用户名进行模糊查询 * @param username * @return java.util.List&amp;lt;com.atguigu.mybatis.pojo.User&amp;gt; * @date 2022/2/26 21:56 */List&amp;lt;User&amp;gt; getUserByLike(@Param(&quot;username&quot;) String username);&amp;lt;!--List&amp;lt;User&amp;gt; getUserByLike(@Param(&quot;username&quot;) String username);--&amp;gt;&amp;lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&amp;gt; &amp;lt;!--select * from t_user where username like &#39;%${mohu}%&#39;--&amp;gt; &amp;lt;!--select * from t_user where username like concat(&#39;%&#39;,#{mohu},&#39;%&#39;)--&amp;gt; select * from t_user where username like &quot;%&quot;#{mohu}&quot;%&quot;&amp;lt;/select&amp;gt; 其中select * from t_user where username like &quot;%&quot;#{mohu}&quot;%&quot;是最常用的批量删除 只能使用${}，如果使用#{}，则解析后的sql语句为delete from t_user where id in (&#39;1,2,3&#39;)，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)/** * 根据id批量删除 * @param ids * @return int * @date 2022/2/26 22:06 */int deleteMore(@Param(&quot;ids&quot;) String ids);&amp;lt;delete id=&quot;deleteMore&quot;&amp;gt; delete from t_user where id in (${ids})&amp;lt;/delete&amp;gt;//测试类@Testpublic void deleteMore() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); int result = mapper.deleteMore(&quot;1,2,3,8&quot;); System.out.println(result);}动态设置表名 只能使用${}，因为表名不能加单引号```java/** 查询指定表中的数据 @param tableName @return java.util.List @date 2022/2/27 14:41 */List getUserByTable(@Param(&quot;tableName&quot;) String tableName);```&amp;lt;!--List&amp;lt;User&amp;gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&amp;gt;&amp;lt;select id=&quot;getUserByTable&quot; resultType=&quot;User&quot;&amp;gt; select * from ${tableName}&amp;lt;/select&amp;gt;添加功能获取自增的主键 使用场景 t_clazz(clazz_id,clazz_name) t_student(student_id,student_name,clazz_id) 添加班级信息 获取新添加的班级的id 为班级分配学生，即将某学的班级id修改为新添加的班级的id 在mapper.xml中设置两个属性 useGeneratedKeys：设置使用自增的主键 keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中 /** * 添加用户信息 * @param user * @date 2022/2/27 15:04 */void insertUser(User user);&amp;lt;!--void insertUser(User user);--&amp;gt;&amp;lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&amp;gt; insert into t_user values (null,#{username},#{password},#{age},#{sex},#{email})&amp;lt;/insert&amp;gt;//测试类@Testpublic void insertUser() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); User user = new User(null, &quot;ton&quot;, &quot;123&quot;, 23, &quot;男&quot;, &quot;123@321.com&quot;); mapper.insertUser(user); System.out.println(user); //输出：user{id=10, username=&#39;ton&#39;, password=&#39;123&#39;, age=23, sex=&#39;男&#39;, email=&#39;123@321.com&#39;}，自增主键存放到了user的id属性中}自定义映射resultMapresultMap处理字段和属性的映射关系 resultMap：设置自定义映射 属性： id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来&amp;lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&amp;gt; &amp;lt;id property=&quot;eid&quot; column=&quot;eid&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;age&quot; column=&quot;age&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;sex&quot; column=&quot;sex&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;email&quot; column=&quot;email&quot;&amp;gt;&amp;lt;/result&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getAllEmp();--&amp;gt;&amp;lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empResultMap&quot;&amp;gt; select * from t_emp&amp;lt;/select&amp;gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 &amp;lt;!--List&amp;lt;Emp&amp;gt; getAllEmp();--&amp;gt; &amp;lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&amp;gt; select eid,emp_name empName,age,sex,email from t_emp &amp;lt;/select&amp;gt; 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解 &amp;lt;settings&amp;gt; &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;/settings&amp;gt; 多对一映射处理 查询员工信息以及员工所对应的部门信息public class Emp { private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等}级联方式处理映射关系&amp;lt;resultMap id=&quot;empAndDeptResultMapOne&quot; type=&quot;Emp&quot;&amp;gt; &amp;lt;id property=&quot;eid&quot; column=&quot;eid&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;age&quot; column=&quot;age&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;sex&quot; column=&quot;sex&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;email&quot; column=&quot;email&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;dept.did&quot; column=&quot;did&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;dept.deptName&quot; column=&quot;dept_name&quot;&amp;gt;&amp;lt;/result&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&amp;gt;&amp;lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;empAndDeptResultMapOne&quot;&amp;gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}&amp;lt;/select&amp;gt;使用association处理映射关系 association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型&amp;lt;resultMap id=&quot;empAndDeptResultMapTwo&quot; type=&quot;Emp&quot;&amp;gt; &amp;lt;id property=&quot;eid&quot; column=&quot;eid&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;age&quot; column=&quot;age&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;sex&quot; column=&quot;sex&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;email&quot; column=&quot;email&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&amp;gt; &amp;lt;id property=&quot;did&quot; column=&quot;did&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;/association&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&amp;gt;&amp;lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;empAndDeptResultMapTwo&quot;&amp;gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}&amp;lt;/select&amp;gt;分步查询1. 查询员工信息 select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件//EmpMapper里的方法/** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);&amp;lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&amp;gt; &amp;lt;id property=&quot;eid&quot; column=&quot;eid&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;age&quot; column=&quot;age&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;sex&quot; column=&quot;sex&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;email&quot; column=&quot;email&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;did&quot;&amp;gt;&amp;lt;/association&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&amp;gt;&amp;lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;empAndDeptByStepResultMap&quot;&amp;gt; select * from t_emp where eid = #{eid}&amp;lt;/select&amp;gt;2. 查询部门信息//DeptMapper里的方法/** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);&amp;lt;!--此处的resultMap仅是处理字段和属性的映射关系--&amp;gt;&amp;lt;resultMap id=&quot;EmpAndDeptByStepTwoResultMap&quot; type=&quot;Dept&quot;&amp;gt; &amp;lt;id property=&quot;did&quot; column=&quot;did&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&amp;gt;&amp;lt;/result&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&amp;gt;&amp;lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultMap=&quot;EmpAndDeptByStepTwoResultMap&quot;&amp;gt; select * from t_dept where did = #{did}&amp;lt;/select&amp;gt;一对多映射处理public class Dept { private Integer did; private String deptName; private List&amp;lt;Emp&amp;gt; emps; //...构造器、get、set方法等}collection collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型&amp;lt;resultMap id=&quot;DeptAndEmpResultMap&quot; type=&quot;Dept&quot;&amp;gt; &amp;lt;id property=&quot;did&quot; column=&quot;did&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&amp;gt; &amp;lt;id property=&quot;eid&quot; column=&quot;eid&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;age&quot; column=&quot;age&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;sex&quot; column=&quot;sex&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;email&quot; column=&quot;email&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;/collection&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&amp;gt;&amp;lt;select id=&quot;getDeptAndEmp&quot; resultMap=&quot;DeptAndEmpResultMap&quot;&amp;gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did}&amp;lt;/select&amp;gt;分步查询1. 查询部门信息/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);&amp;lt;resultMap id=&quot;DeptAndEmpByStepOneResultMap&quot; type=&quot;Dept&quot;&amp;gt; &amp;lt;id property=&quot;did&quot; column=&quot;did&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;collection property=&quot;emps&quot; select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot; column=&quot;did&quot;&amp;gt;&amp;lt;/collection&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&amp;gt;&amp;lt;select id=&quot;getDeptAndEmpByStepOne&quot; resultMap=&quot;DeptAndEmpByStepOneResultMap&quot;&amp;gt; select * from t_dept where did = #{did}&amp;lt;/select&amp;gt;2. 根据部门id查询部门中的所有员工/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List&amp;lt;com.atguigu.mybatis.pojo.Emp&amp;gt; * @date 2022/2/27 22:10 */List&amp;lt;Emp&amp;gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);&amp;lt;!--List&amp;lt;Emp&amp;gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&amp;gt;&amp;lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultType=&quot;Emp&quot;&amp;gt; select * from t_emp where did = #{did}&amp;lt;/select&amp;gt;延迟加载分步查询的优点，可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：1.lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载2.aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=&quot;lazy(延迟加载)|eager(立即加载)&quot;&amp;lt;settings&amp;gt; &amp;lt;!--开启延迟加载--&amp;gt; &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt;&amp;lt;/settings&amp;gt;@Testpublic void getEmpAndDeptByStepOne() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName());} 关闭延迟加载，两条SQL语句都运行了 开启延迟加载，只运行获取emp的SQL语句@Testpublic void getEmpAndDeptByStepOne() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName()); System.out.println(&quot;----------------&quot;); System.out.println(emp.getDept());} 开启后，需要用到查询dept的时候才会调用相应的SQL语句 fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=&quot;lazy(延迟加载)|eager(立即加载)&quot;&amp;lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&amp;gt; &amp;lt;id property=&quot;eid&quot; column=&quot;eid&quot;&amp;gt;&amp;lt;/id&amp;gt; &amp;lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;age&quot; column=&quot;age&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;sex&quot; column=&quot;sex&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;result property=&quot;email&quot; column=&quot;email&quot;&amp;gt;&amp;lt;/result&amp;gt; &amp;lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;did&quot; fetchType=&quot;lazy&quot;&amp;gt;&amp;lt;/association&amp;gt;&amp;lt;/resultMap&amp;gt;动态SQL Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题if if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行 在where后面添加一个恒成立条件1=1 这个恒成立条件并不会影响查询的结果 这个1=1可以用来拼接and语句，例如：当empName为null时 如果不加上恒成立条件，则SQL语句为select * from t_emp where and age = ? and sex = ? and email = ?，此时where会与and连用，SQL语句会报错 如果加上一个恒成立条件，则SQL语句为select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?，此时不报错 &amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;&amp;lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&amp;gt; select * from t_emp where 1=1 &amp;lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&amp;gt; and emp_name = #{empName} &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&amp;gt; and age = #{age} &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;sex != null and sex !=&#39;&#39;&quot;&amp;gt; and sex = #{sex} &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;email != null and email !=&#39;&#39;&quot;&amp;gt; and email = #{email} &amp;lt;/if&amp;gt;&amp;lt;/select&amp;gt;where where和if一般结合使用： 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉 &amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;&amp;lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&amp;gt; select * from t_emp &amp;lt;where&amp;gt; &amp;lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&amp;gt; emp_name = #{empName} &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&amp;gt; and age = #{age} &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;sex != null and sex !=&#39;&#39;&quot;&amp;gt; and sex = #{sex} &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;email != null and email !=&#39;&#39;&quot;&amp;gt; and email = #{email} &amp;lt;/if&amp;gt; &amp;lt;/where&amp;gt;&amp;lt;/select&amp;gt; 注意：where标签不能去掉条件后多余的and/or&amp;lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&amp;gt;&amp;lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&amp;gt;emp_name = #{empName} and&amp;lt;/if&amp;gt;&amp;lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&amp;gt; age = #{age}&amp;lt;/if&amp;gt;trim trim用于去掉或添加标签中的内容 常用属性 prefix：在trim标签中的内容的前面添加某些内容 suffix：在trim标签中的内容的后面添加某些内容 prefixOverrides：在trim标签中的内容的前面去掉某些内容 suffixOverrides：在trim标签中的内容的后面去掉某些内容 若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下select * from t_emp&amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;&amp;lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&amp;gt; select * from t_emp &amp;lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&amp;gt; &amp;lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&amp;gt; emp_name = #{empName} and &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&amp;gt; age = #{age} and &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;sex != null and sex !=&#39;&#39;&quot;&amp;gt; sex = #{sex} or &amp;lt;/if&amp;gt; &amp;lt;if test=&quot;email != null and email !=&#39;&#39;&quot;&amp;gt; email = #{email} &amp;lt;/if&amp;gt; &amp;lt;/trim&amp;gt;&amp;lt;/select&amp;gt;//测试类@Testpublic void getEmpByCondition() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List&amp;lt;Emp&amp;gt; emps= mapper.getEmpByCondition(new Emp(null, &quot;张三&quot;, null, null, null, null)); System.out.println(emps);}choose、when、otherwise choose、when、otherwise相当于if...else if..else when至少要有一个，otherwise至多只有一个&amp;lt;select id=&quot;getEmpByChoose&quot; resultType=&quot;Emp&quot;&amp;gt; select * from t_emp &amp;lt;where&amp;gt; &amp;lt;choose&amp;gt; &amp;lt;when test=&quot;empName != null and empName != &#39;&#39;&quot;&amp;gt; emp_name = #{empName} &amp;lt;/when&amp;gt; &amp;lt;when test=&quot;age != null and age != &#39;&#39;&quot;&amp;gt; age = #{age} &amp;lt;/when&amp;gt; &amp;lt;when test=&quot;sex != null and sex != &#39;&#39;&quot;&amp;gt; sex = #{sex} &amp;lt;/when&amp;gt; &amp;lt;when test=&quot;email != null and email != &#39;&#39;&quot;&amp;gt; email = #{email} &amp;lt;/when&amp;gt; &amp;lt;otherwise&amp;gt; did = 1 &amp;lt;/otherwise&amp;gt; &amp;lt;/choose&amp;gt; &amp;lt;/where&amp;gt;&amp;lt;/select&amp;gt;@Testpublic void getEmpByChoose() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List&amp;lt;Emp&amp;gt; emps = mapper.getEmpByChoose(new Emp(null, &quot;张三&quot;, 23, &quot;男&quot;, &quot;123@qq.com&quot;, null)); System.out.println(emps);} 相当于if a else if b else if c else d，只会执行其中一个foreach 属性： collection：设置要循环的数组或集合 item：表示集合或数组中的每一个数据 separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如 , open：设置foreach标签中的内容的开始符 close：设置foreach标签中的内容的结束符 批量删除&amp;lt;!--int deleteMoreByArray(Integer[] eids);--&amp;gt;&amp;lt;delete id=&quot;deleteMoreByArray&quot;&amp;gt; delete from t_emp where eid in &amp;lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&amp;gt; #{eid} &amp;lt;/foreach&amp;gt;&amp;lt;/delete&amp;gt;@Testpublic void deleteMoreByArray() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); int result = mapper.deleteMoreByArray(new Integer[]{6, 7, 8, 9}); System.out.println(result);} 批量添加&amp;lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&amp;lt;Emp&amp;gt; emps);--&amp;gt;&amp;lt;insert id=&quot;insertMoreByList&quot;&amp;gt; insert into t_emp values &amp;lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&amp;gt; (null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null) &amp;lt;/foreach&amp;gt;&amp;lt;/insert&amp;gt;@Testpublic void insertMoreByList() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Emp emp1 = new Emp(null,&quot;a&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null); Emp emp2 = new Emp(null,&quot;b&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null); Emp emp3 = new Emp(null,&quot;c&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null); List&amp;lt;Emp&amp;gt; emps = Arrays.asList(emp1, emp2, emp3); int result = mapper.insertMoreByList(emps); System.out.println(result);}SQL片段 sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入 声明sql片段：&amp;lt;sql&amp;gt;标签&amp;lt;sql id=&quot;empColumns&quot;&amp;gt;eid,emp_name,age,sex,email&amp;lt;/sql&amp;gt; 引用sql片段：&amp;lt;include&amp;gt;标签&amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;&amp;lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&amp;gt; select &amp;lt;include refid=&quot;empColumns&quot;&amp;gt;&amp;lt;/include&amp;gt; from t_emp&amp;lt;/select&amp;gt;MyBatis的缓存MyBatis的一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问 使一级缓存失效的四种情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 MyBatis的二级缓存 二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 二级缓存开启的条件 在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置 在映射文件中设置标签 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效二级缓存的相关配置 在mapper配置文件中添加的cache标签可以设置一些属性 eviction属性：缓存回收策略 LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新 size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly属性：只读，true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。 false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false MyBatis缓存查询的顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后，一级缓存中的数据会写入二级缓存整合第三方缓存EHCache（了解）添加依赖&amp;lt;!-- Mybatis EHCache整合包 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.caches&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-ehcache&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- slf4j日志门面的一个具体实现 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;各个jar包的功能 jar包名称 作用 mybatis-ehcache Mybatis和EHCache的整合包 ehcache EHCache核心包 slf4j-api SLF4J日志门面包 logback-classic 支持SLF4J门面接口的一个具体实现 创建EHCache的配置文件ehcache.xml 名字必须叫ehcache.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&amp;gt; &amp;lt;!-- 磁盘保存路径 --&amp;gt; &amp;lt;diskStore path=&quot;D:\\atguigu\\ehcache&quot;/&amp;gt; &amp;lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&amp;gt; &amp;lt;/defaultCache&amp;gt;&amp;lt;/ehcache&amp;gt;设置二级缓存的类型 在xxxMapper.xml文件中设置二级缓存类型&amp;lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&amp;gt;加入logback日志 存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件logback.xml，名字固定，不可改变&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;configuration debug=&quot;true&quot;&amp;gt; &amp;lt;!-- 指定日志输出的位置 --&amp;gt; &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt; &amp;lt;encoder&amp;gt; &amp;lt;!-- 日志输出的格式 --&amp;gt; &amp;lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&amp;gt; &amp;lt;pattern&amp;gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n&amp;lt;/pattern&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&amp;gt; &amp;lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&amp;gt; &amp;lt;root level=&quot;DEBUG&quot;&amp;gt; &amp;lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&amp;gt; &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt; &amp;lt;/root&amp;gt; &amp;lt;!-- 根据特殊需求指定局部日志级别 --&amp;gt; &amp;lt;logger name=&quot;com.atguigu.crowd.mapper&quot; level=&quot;DEBUG&quot;/&amp;gt;&amp;lt;/configuration&amp;gt;EHCache配置文件说明 属性名 是否必须 作用 maxElementsInMemory 是 在内存中缓存的element的最大数目 maxElementsOnDisk 是 在磁盘上缓存的element的最大数目，若是0表示无穷大 eternal 是 设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断 overflowToDisk 是 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 timeToIdleSeconds 否 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds 否 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 否 DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 diskPersistent 否 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false diskExpiryThreadIntervalSeconds 否 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作 memoryStoreEvictionPolicy 否 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出 MyBatis的逆向工程 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： Java实体类 Mapper接口 Mapper映射文件 创建逆向工程的步骤 添加依赖和插件&amp;lt;dependencies&amp;gt; &amp;lt;!-- MyBatis核心依赖包 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- junit测试 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MySQL驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.27&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- log4j日志 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;&amp;lt;!-- 控制Maven在构建过程中相关配置 --&amp;gt;&amp;lt;build&amp;gt; &amp;lt;!-- 构建过程中用到的插件 --&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.0&amp;lt;/version&amp;gt; &amp;lt;!-- 插件的依赖 --&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- 逆向工程的核心依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 数据库连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.mchange&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;c3p0&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MySQL驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.27&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;创建MyBatis的核心配置文件&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;properties resource=&quot;jdbc.properties&quot;/&amp;gt; &amp;lt;typeAliases&amp;gt; &amp;lt;package name=&quot;&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;package name=&quot;&quot;/&amp;gt; &amp;lt;/mappers&amp;gt;&amp;lt;/configuration&amp;gt;创建逆向工程的配置文件 文件名必须是：generatorConfig.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt; &amp;lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --&amp;gt;&amp;lt;generatorConfiguration&amp;gt; &amp;lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&amp;gt; &amp;lt;!-- 数据库的连接信息 --&amp;gt; &amp;lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;123456&quot;&amp;gt; &amp;lt;/jdbcConnection&amp;gt; &amp;lt;!-- javaBean的生成策略--&amp;gt; &amp;lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot; targetProject=&quot;.\\src\\main\\java&quot;&amp;gt; &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;/javaModelGenerator&amp;gt; &amp;lt;!-- SQL映射文件的生成策略 --&amp;gt; &amp;lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&amp;gt; &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;/sqlMapGenerator&amp;gt; &amp;lt;!-- Mapper接口的生成策略 --&amp;gt; &amp;lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&amp;gt; &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;/javaClientGenerator&amp;gt; &amp;lt;!-- 逆向分析的表 --&amp;gt; &amp;lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&amp;gt; &amp;lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&amp;gt; &amp;lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&amp;gt; &amp;lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&amp;gt; &amp;lt;/context&amp;gt;&amp;lt;/generatorConfiguration&amp;gt;执行MBG插件的generate目标 如果出现报错：Exception getting JDBC Driver，可能是pom.xml中，数据库驱动配置错误 dependency中的驱动 mybatis-generator-maven-plugin插件中的驱动 两者的驱动版本应该相同 执行结果QBC查询 selectByExample：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据 example.createCriteria().xxx：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系 example.or().xxx：将之前添加的条件通过or拼接其他条件@Test public void testMBG() throws IOException { InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); EmpExample example = new EmpExample(); //名字为张三，且年龄大于等于20 example.createCriteria().andEmpNameEqualTo(&quot;张三&quot;).andAgeGreaterThanOrEqualTo(20); //或者did不为空 example.or().andDidIsNotNull(); List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(example); emps.forEach(System.out::println);}增改 updateByPrimaryKey：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3)); updateByPrimaryKeySelective()：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段 mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3)); 分页插件分页插件使用步骤添加依赖&amp;lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pagehelper&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;配置分页插件 在MyBatis的核心配置文件（mybatis-config.xml）中配置插件 &amp;lt;plugins&amp;gt; &amp;lt;!--设置分页插件--&amp;gt; &amp;lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&amp;gt;&amp;lt;/plugin&amp;gt;&amp;lt;/plugins&amp;gt;分页插件的使用开启分页功能 在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 pageNum：当前页的页码 pageSize：每页显示的条数 @Testpublic void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 PageHelper.startPage(1,4); List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println);}分页相关数据方法一：直接输出@Testpublic void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 Page&amp;lt;Object&amp;gt; page = PageHelper.startPage(1, 4); List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(null); //在查询到List集合后，打印分页数据 System.out.println(page);} 分页相关数据：Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=&#39;admin&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=2, empName=&#39;admin2&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=3, empName=&#39;王五&#39;, age=12, sex=&#39;女&#39;, email=&#39;123@qq.com&#39;, did=3}, Emp{eid=4, empName=&#39;赵六&#39;, age=32, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;, did=1}]方法二使用PageInfo 在查询获取list集合之后，使用PageInfo&amp;lt;T&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(List&amp;lt;T&amp;gt; list, intnavigatePages)获取分页相关数据 list：分页之后的数据 navigatePages：导航分页的页码数 @Testpublic void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); PageHelper.startPage(1, 4); List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(null); PageInfo&amp;lt;Emp&amp;gt; page = new PageInfo&amp;lt;&amp;gt;(emps,5); System.out.println(page);} 分页相关数据：PageInfo{pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, list=Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=&#39;admin&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=2, empName=&#39;admin2&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=3, empName=&#39;王五&#39;, age=12, sex=&#39;女&#39;, email=&#39;123@qq.com&#39;, did=3}, Emp{eid=4, empName=&#39;赵六&#39;, age=32, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;, did=1}], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]} 其中list中的数据等同于方法一中直接输出的page数据常用数据： pageNum：当前页的页码 pageSize：每页显示的条数 size：当前页显示的真实条数 total：总记录数 pages：总页数 prePage：上一页的页码 nextPage：下一页的页码 isFirstPage/isLastPage：是否为第一页/最后一页 hasPreviousPage/hasNextPage：是否存在上一页/下一页 navigatePages：导航分页的页码数 navigatepageNums：导航分页的页码，[1,2,3,4,5]" }, { "title": "SpringMVC", "url": "/posts/SpringMVC/", "categories": "框架, SpringMVC", "tags": "", "date": "2022-07-12 00:00:00 +0800", "snippet": "一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分M：Model，模型层，指工程中的JavaBean，作用是处理数据JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器MVC的工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器2、什么是SpringMVCSpringMVC是Spring的一个后续产品，是Spring的一个子项目SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求二、HelloWorld1、开发环境IDE：idea 2019.2构建工具：maven3.5.4服务器：tomcat7Spring版本：5.3.12、创建maven工程添加web模块打包方式：war引入依赖&amp;lt;dependencies&amp;gt; &amp;lt;!-- SpringMVC --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 日志 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- ServletAPI --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Spring5和Thymeleaf整合包 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.thymeleaf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;thymeleaf-spring5&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;123456789101112131415161718192021222324252627282930注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。3、配置web.xml注册SpringMVC的前端控制器DispatcherServlet默认配置方式此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml&amp;lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&amp;gt;&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;&amp;lt;/servlet&amp;gt;&amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;&amp;lt;/servlet-mapping&amp;gt;1234567891011121314扩展配置方式可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间&amp;lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&amp;gt;&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;!-- contextConfigLocation为固定值 --&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&amp;gt; &amp;lt;param-value&amp;gt;classpath:springMVC.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;&amp;lt;/servlet&amp;gt;&amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;&amp;lt;/servlet-mapping&amp;gt; 注： 标签中使用/和/*的区别：/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法4、创建请求控制器由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器请求控制器中每一个处理请求的方法成为控制器方法因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在@Controllerpublic class HelloController { }12345、创建springMVC的配置文件&amp;lt;!-- 自动扫描包 --&amp;gt;&amp;lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&amp;gt;&amp;lt;!-- 配置Thymeleaf视图解析器 --&amp;gt;&amp;lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&amp;gt; &amp;lt;property name=&quot;order&quot; value=&quot;1&quot;/&amp;gt; &amp;lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&amp;gt; &amp;lt;property name=&quot;templateEngine&quot;&amp;gt; &amp;lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&amp;gt; &amp;lt;property name=&quot;templateResolver&quot;&amp;gt; &amp;lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&amp;gt; &amp;lt;!-- 视图前缀 --&amp;gt; &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&amp;gt; &amp;lt;!-- 视图后缀 --&amp;gt; &amp;lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&amp;gt; &amp;lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&amp;gt; &amp;lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&amp;lt;mvc:annotation-driven/&amp;gt;解决问题 --&amp;gt;&amp;lt;mvc:default-servlet-handler/&amp;gt;&amp;lt;!-- 开启mvc注解驱动 --&amp;gt;&amp;lt;mvc:annotation-driven&amp;gt; &amp;lt;mvc:message-converters&amp;gt; &amp;lt;!-- 处理响应中文内容乱码 --&amp;gt; &amp;lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&amp;gt; &amp;lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&amp;gt; &amp;lt;property name=&quot;supportedMediaTypes&quot;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;value&amp;gt;text/html&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;application/json&amp;lt;/value&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/mvc:message-converters&amp;gt;&amp;lt;/mvc:annotation-driven&amp;gt;6、测试HelloWorld实现对首页的访问在请求控制器中创建处理请求的方法// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径// localhost:8080/springMVC/@RequestMapping(&quot;/&quot;)public String index() { //设置视图名称 return &quot;index&quot;;}通过超链接跳转到指定页面在主页index.html中设置超链接&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;首页&amp;lt;/h1&amp;gt; &amp;lt;a th:href=&quot;@{/hello}&quot;&amp;gt;HelloWorld&amp;lt;/a&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;在请求控制器中创建处理请求的方法@RequestMapping(&quot;/hello&quot;)public String HelloWorld() { return &quot;target&quot;;}7、总结浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面三、@RequestMapping注解1、@RequestMapping注解的功能从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。2、@RequestMapping注解的位置@RequestMapping标识一个类：设置映射请求的请求路径的初始信息@RequestMapping标识一个方法：设置映射请求请求路径的具体信息@Controller@RequestMapping(&quot;/test&quot;)public class RequestMappingController { //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping(){ return &quot;success&quot;; }}3、@RequestMapping注解的value属性@RequestMapping注解的value属性通过请求的请求地址匹配请求映射@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射&amp;lt;a th:href=&quot;@{/testRequestMapping}&quot;&amp;gt;测试@RequestMapping的value属性--&amp;gt;/testRequestMapping&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;a th:href=&quot;@{/test}&quot;&amp;gt;测试@RequestMapping的value属性--&amp;gt;/test&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;12@RequestMapping( value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;})public String testRequestMapping(){ return &quot;success&quot;;}4、@RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported&amp;lt;a th:href=&quot;@{/test}&quot;&amp;gt;测试@RequestMapping的value属性--&amp;gt;/test&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;form th:action=&quot;@{/test}&quot; method=&quot;post&quot;&amp;gt; &amp;lt;input type=&quot;submit&quot;&amp;gt;&amp;lt;/form&amp;gt;1234@RequestMapping( value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;}, method = {RequestMethod.GET, RequestMethod.POST})public String testRequestMapping(){ return &quot;success&quot;;} 注： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射–&amp;gt;@GetMapping 处理post请求的映射–&amp;gt;@PostMapping 处理put请求的映射–&amp;gt;@PutMapping 处理delete请求的映射–&amp;gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到5、@RequestMapping注解的params属性（了解）@RequestMapping注解的params属性通过请求的请求参数匹配请求映射@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系“param”：要求请求映射所匹配的请求必须携带param请求参数“!param”：要求请求映射所匹配的请求必须不能携带param请求参数“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value&amp;lt;a th:href=&quot;@{/test(username=&#39;admin&#39;,password=123456)&quot;&amp;gt;测试@RequestMapping的params属性--&amp;gt;/test&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;1@RequestMapping( value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;} ,method = {RequestMethod.GET, RequestMethod.POST} ,params = {&quot;username&quot;,&quot;password!=123456&quot;})public String testRequestMapping(){ return &quot;success&quot;;} 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}6、@RequestMapping注解的headers属性（了解）@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系“header”：要求请求映射所匹配的请求必须携带header请求头信息“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到7、SpringMVC支持ant风格的路径？：表示任意的单个字符*：表示任意的0个或多个字符**：表示任意的一层或多层目录注意：在使用时，只能使用//xxx的方式8、SpringMVC支持路径中的占位符（重点）原始方式：/deleteUser?id=1rest方式：/deleteUser/1SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参&amp;lt;a th:href=&quot;@{/testRest/1/admin}&quot;&amp;gt;测试路径中的占位符--&amp;gt;/testRest&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;1@RequestMapping(&quot;/testRest/{id}/{username}&quot;)public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username){ System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;;}//最终输出的内容为--&amp;gt;id:1,username:admin四、SpringMVC获取请求参数1、通过ServletAPI获取将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象@RequestMapping(&quot;/testParam&quot;)public String testParam(HttpServletRequest request){ String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;}2、通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参&amp;lt;a th:href=&quot;@{/testParam(username=&#39;admin&#39;,password=123456)}&quot;&amp;gt;测试获取请求参数--&amp;gt;/testParam&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;1@RequestMapping(&quot;/testParam&quot;)public String testParam(String username, String password){ System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;} 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果3、@RequestParam@RequestParam是将请求参数和控制器方法的形参创建映射关系@RequestParam注解一共有三个属性：value：指定为形参赋值的请求参数的参数名required：设置是否必须传输此请求参数，默认值为true若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为nulldefaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为”“时，则使用默认值为形参赋值4、@RequestHeader@RequestHeader是将请求头信息和控制器方法的形参创建映射关系@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam5、@CookieValue@CookieValue是将cookie数据和控制器方法的形参创建映射关系@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam6、通过POJO获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值&amp;lt;form th:action=&quot;@{/testpojo}&quot; method=&quot;post&quot;&amp;gt; 用户名：&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br&amp;gt; 密码：&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br&amp;gt; 性别：&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&amp;gt;男&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&amp;gt;女&amp;lt;br&amp;gt; 年龄：&amp;lt;input type=&quot;text&quot; name=&quot;age&quot;&amp;gt;&amp;lt;br&amp;gt; 邮箱：&amp;lt;input type=&quot;text&quot; name=&quot;email&quot;&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot;&amp;gt;&amp;lt;/form&amp;gt;12345678@RequestMapping(&quot;/testpojo&quot;)public String testPOJO(User user){ System.out.println(user); return &quot;success&quot;;}//最终结果--&amp;gt;User{id=null, username=&#39;张三&#39;, password=&#39;123&#39;, age=23, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;}7、解决获取请求参数的乱码问题解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册&amp;lt;!--配置springMVC的编码过滤器--&amp;gt;&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceResponseEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt;&amp;lt;/filter&amp;gt;&amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&amp;lt;/filter-mapping&amp;gt; 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效五、域对象共享数据1、使用ServletAPI向request域对象共享数据@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request){ request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;}2、使用ModelAndView向request域对象共享数据@RequestMapping(&quot;/testModelAndView&quot;)public ModelAndView testModelAndView(){ /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav;}3、使用Model向request域对象共享数据@RequestMapping(&quot;/testModel&quot;)public String testModel(Model model){ model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;}4、使用map向request域对象共享数据@RequestMapping(&quot;/testMap&quot;)public String testMap(Map&amp;lt;String, Object&amp;gt; map){ map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;;}5、使用ModelMap向request域对象共享数据@RequestMapping(&quot;/testModelMap&quot;)public String testModelMap(ModelMap modelMap){ modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;;}6、Model、ModelMap、Map的关系Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的public interface Model{}public class ModelMap extends LinkedHashMap&amp;lt;String, Object&amp;gt; {}public class ExtendedModelMap extends ModelMap implements Model {}public class BindingAwareModelMap extends ExtendedModelMap {}7、向session域共享数据@RequestMapping(&quot;/testSession&quot;)public String testSession(HttpSession session){ session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;}8、向application域共享数据@RequestMapping(&quot;/testApplication&quot;)public String testApplication(HttpSession session){ ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;;}六、SpringMVC的视图SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户SpringMVC视图的种类很多，默认有转发视图和重定向视图当工程引入jstl的依赖，转发视图会自动转换为JstlView若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView1、ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转@RequestMapping(&quot;/testHello&quot;)public String testHello(){ return &quot;hello&quot;;}2、转发视图SpringMVC中默认的转发视图是InternalResourceViewSpringMVC中创建转发视图的情况：当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转例如”forward:/”，“forward:/employee”@RequestMapping(&quot;/testForward&quot;)public String testForward(){ return &quot;forward:/testHello&quot;;}3、重定向视图SpringMVC中默认的重定向视图是RedirectView当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转例如”redirect:/”，“redirect:/employee”@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect(){ return &quot;redirect:/testHello&quot;;} 注：重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径4、视图控制器view-controller当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示&amp;lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&amp;gt;&amp;lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&amp;gt;&amp;lt;/mvc:view-controller&amp;gt; 注：当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：&amp;lt;mvc:annotation-driven/&amp;gt;七、RESTful1、RESTful简介REST：Representational、State、Transfer，表现层资源状态转移。资源资源是一种看待服务器的方式，即将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。资源的表述资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML、XML、JSON、纯文本、图片、视频、音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。2、RESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。REST风格提倡URL地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为URL地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id=1 get请求方式：user/1 保存操作 saveUser post请求方式：user 删除操作 deleteUser?id=1 delete请求方式：user/1 更新操作 updateUser put请求方式：user 3、HiddenHttpMethodFilter由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？SpringMVC提供了HiddenHttpMethodFilter帮助我们将 POST 请求转换为 DELETE 或 PUT 请求HiddenHttpMethodFilter处理put和delete请求的条件： 当前请求的请求方式必须为post 当前请求必须传输请求参数_method满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式在web.xml中注册HiddenHttpMethodFilter&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;HiddenHttpMethodFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.HiddenHttpMethodFilter&amp;lt;/filter-class&amp;gt;&amp;lt;/filter&amp;gt;&amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;HiddenHttpMethodFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&amp;lt;/filter-mapping&amp;gt; 注：目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter原因：1.在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的2.request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作3.而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：String paramValue = request.getParameter(this.methodParam);八、RESTful案例1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。 搭建环境 准备实体类 package com.atguigu.mvc.bean; public class Employee { private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public Employee(Integer id, String lastName, String email, Integer gender) { super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; } public Employee() { }} 准备dao模拟数据 package com.atguigu.mvc.dao; import java.util.Collection;import java.util.HashMap;import java.util.Map; import com.atguigu.mvc.bean.Employee;import org.springframework.stereotype.Repository; @Repositorypublic class EmployeeDao { private static Map&amp;lt;Integer, Employee&amp;gt; employees = null; static{ employees = new HashMap&amp;lt;Integer, Employee&amp;gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); } private static Integer initId = 1006; public void save(Employee employee){ if(employee.getId() == null){ employee.setId(initId++); } employees.put(employee.getId(), employee); } public Collection&amp;lt;Employee&amp;gt; getAll(){ return employees.values(); } public Employee get(Integer id){ return employees.get(id); } public void delete(Integer id){ employees.remove(id); }} 2、功能清单 功能 URL 地址 请求方式 访问首页√ / GET 查询全部数据√ /employee GET 删除√ /employee/2 DELETE 跳转到添加数据页面√ /toAdd GET 执行保存√ /employee POST 跳转到更新数据页面√ /employee/2 GET 执行更新√ /employee PUT 3、具体功能：访问首页配置view-controller&amp;lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&amp;gt;1创建页面&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; &amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;首页&amp;lt;/h1&amp;gt;&amp;lt;a th:href=&quot;@{/employee}&quot;&amp;gt;访问员工信息&amp;lt;/a&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;12345678910114、具体功能：查询所有员工数据控制器方法@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)public String getEmployeeList(Model model){ Collection&amp;lt;Employee&amp;gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;, employeeList); return &quot;employee_list&quot;;}123456创建employee_list.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Employee Info&amp;lt;/title&amp;gt; &amp;lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/vue.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;text-align: center;&quot; id=&quot;dataTable&quot;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th colspan=&quot;5&quot;&amp;gt;Employee Info&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;id&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;lastName&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;email&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;gender&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;options(&amp;lt;a th:href=&quot;@{/toAdd}&quot;&amp;gt;add&amp;lt;/a&amp;gt;)&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr th:each=&quot;employee : ${employeeList}&quot;&amp;gt; &amp;lt;td th:text=&quot;${employee.id}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td th:text=&quot;${employee.lastName}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td th:text=&quot;${employee.email}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td th:text=&quot;${employee.gender}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; &amp;lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@{&#39;/employee/&#39;+${employee.id}}&quot;&amp;gt;delete&amp;lt;/a&amp;gt; &amp;lt;a th:href=&quot;@{&#39;/employee/&#39;+${employee.id}}&quot;&amp;gt;update&amp;lt;/a&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;5、具体功能：删除创建处理delete请求方式的表单&amp;lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&amp;gt;&amp;lt;form id=&quot;delete_form&quot; method=&quot;post&quot;&amp;gt; &amp;lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&amp;gt;&amp;lt;/form&amp;gt;12345删除超链接绑定点击事件引入vue.js&amp;lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/vue.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;1删除超链接&amp;lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@{&#39;/employee/&#39;+${employee.id}}&quot;&amp;gt;delete&amp;lt;/a&amp;gt;1通过vue处理点击事件&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; var vue = new Vue({ el:&quot;#dataTable&quot;, methods:{ //event表示当前事件 deleteEmployee:function (event) { //通过id获取表单标签 var delete_form = document.getElementById(&quot;delete_form&quot;); //将触发事件的超链接的href属性为表单的action属性赋值 delete_form.action = event.target.href; //提交表单 delete_form.submit(); //阻止超链接的默认跳转行为 event.preventDefault(); } } });&amp;lt;/script&amp;gt;123456789101112131415161718控制器方法@RequestMapping(value = &quot;/employee/{id}&quot;, method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id){ employeeDao.delete(id); return &quot;redirect:/employee&quot;;}123456、具体功能：跳转到添加数据页面配置view-controller&amp;lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&amp;gt;&amp;lt;/mvc:view-controller&amp;gt;1创建employee_add.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Add Employee&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form th:action=&quot;@{/employee}&quot; method=&quot;post&quot;&amp;gt; lastName:&amp;lt;input type=&quot;text&quot; name=&quot;lastName&quot;&amp;gt;&amp;lt;br&amp;gt; email:&amp;lt;input type=&quot;text&quot; name=&quot;email&quot;&amp;gt;&amp;lt;br&amp;gt; gender:&amp;lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&amp;gt;male &amp;lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&amp;gt;female&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;add&quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;1234567891011121314151617187、具体功能：执行保存控制器方法@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)public String addEmployee(Employee employee){ employeeDao.save(employee); return &quot;redirect:/employee&quot;;}123458、具体功能：跳转到更新数据页面修改超链接&amp;lt;a th:href=&quot;@{&#39;/employee/&#39;+${employee.id}}&quot;&amp;gt;update&amp;lt;/a&amp;gt;1控制器方法@RequestMapping(value = &quot;/employee/{id}&quot;, method = RequestMethod.GET)public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id, Model model){ Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;, employee); return &quot;employee_update&quot;;}123456创建employee_update.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Update Employee&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form th:action=&quot;@{/employee}&quot; method=&quot;post&quot;&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;${employee.id}&quot;&amp;gt; lastName:&amp;lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;${employee.lastName}&quot;&amp;gt;&amp;lt;br&amp;gt; email:&amp;lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;${employee.email}&quot;&amp;gt;&amp;lt;br&amp;gt; &amp;lt;!-- th:field=&quot;${employee.gender}&quot;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性 --&amp;gt; gender:&amp;lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;${employee.gender}&quot;&amp;gt;male &amp;lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;${employee.gender}&quot;&amp;gt;female&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;update&quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;1234567891011121314151617181920212223249、具体功能：执行更新控制器方法@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)public String updateEmployee(Employee employee){ employeeDao.save(employee); return &quot;redirect:/employee&quot;;}12345八、HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity1、@RequestBody@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值&amp;lt;form th:action=&quot;@{/testRequestBody}&quot; method=&quot;post&quot;&amp;gt; 用户名：&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br&amp;gt; 密码：&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot;&amp;gt;&amp;lt;/form&amp;gt;12345@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String requestBody){ System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;;}12345输出结果：requestBody:username=admin&amp;amp;password=1234562、RequestEntityRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&amp;lt;String&amp;gt; requestEntity){ System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;;}123456输出结果：requestHeader:[host:“localhost:8080”, connection:“keep-alive”, content-length:“27”, cache-control:“max-age=0”, sec-ch-ua:”” Not A;Brand”;v=“99”, “Chromium”;v=“90”, “Google Chrome”;v=“90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:“1”, origin:“http://localhost:8080”, user-agent:“Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]requestBody:username=admin&amp;amp;password=1233、@ResponseBody@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody(){ return &quot;success&quot;;}12345结果：浏览器页面显示success4、SpringMVC处理json@ResponseBody处理json的步骤：1.导入jackson的依赖&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.12.1&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;123452.在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串&amp;lt;mvc:annotation-driven /&amp;gt;13.在处理器方法上使用@ResponseBody注解进行标识4.将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser(){ return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);}12345浏览器的页面中展示的结果：{“id”:1001,“username”:“admin”,“password”:“123456”,“age”:23,“sex”:“男”}5、SpringMVC处理ajax1.请求超链接：&amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;a th:href=&quot;@{/testAjax}&quot; @click=&quot;testAjax&quot;&amp;gt;testAjax&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;1232.通过vue和axios处理点击事件：&amp;lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/vue.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/axios.min.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; var vue = new Vue({ el:&quot;#app&quot;, methods:{ testAjax:function (event) { axios({ method:&quot;post&quot;, url:event.target.href, params:{ username:&quot;admin&quot;, password:&quot;123456&quot; } }).then(function (response) { alert(response.data); }); event.preventDefault(); } } });&amp;lt;/script&amp;gt;3.控制器方法：@RequestMapping(&quot;/testAjax&quot;)@ResponseBodypublic String testAjax(String username, String password){ System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;;}1234566、@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解7、ResponseEntityResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文九、文件上传和下载1、文件下载使用ResponseEntity实现下载文件的功能@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&amp;lt;byte[]&amp;gt; testResponseEntity(HttpSession session) throws IOException { //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&amp;lt;String, String&amp;gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&amp;lt;byte[]&amp;gt; responseEntity = new ResponseEntity&amp;lt;&amp;gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity;}2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype=“multipart/form-data”SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息上传步骤：1.添加依赖：&amp;lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;1234562.在SpringMVC的配置文件中添加配置：&amp;lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&amp;gt;&amp;lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&amp;gt;&amp;lt;/bean&amp;gt;123.控制器方法：@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException { //获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists()){ file.mkdir(); } String finalPath = photoPath + File.separator + fileName; //实现上传功能 photo.transferTo(new File(finalPath)); return &quot;success&quot;;}十、拦截器1、拦截器的配置SpringMVC中的拦截器用于拦截控制器方法的执行SpringMVC中的拦截器需要实现HandlerInterceptorSpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：&amp;lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;ref bean=&quot;firstInterceptor&quot;&amp;gt;&amp;lt;/ref&amp;gt;&amp;lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&amp;gt;&amp;lt;mvc:interceptor&amp;gt; &amp;lt;mvc:mapping path=&quot;/**&quot;/&amp;gt; &amp;lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&amp;gt; &amp;lt;ref bean=&quot;firstInterceptor&quot;&amp;gt;&amp;lt;/ref&amp;gt;&amp;lt;/mvc:interceptor&amp;gt;&amp;lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&amp;gt;12345678910112、拦截器的三个抽象方法SpringMVC中的拦截器有三个抽象方法：preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法postHandle：控制器方法执行之后执行postHandle()afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()3、多个拦截器的执行顺序1.若每个拦截器的preHandle()都返回true此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行2.若某个拦截器的preHandle()返回了falsepreHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行十一、异常处理器1、基于配置的异常处理SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolverHandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolverSpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：&amp;lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&amp;gt; &amp;lt;property name=&quot;exceptionMappings&quot;&amp;gt; &amp;lt;props&amp;gt; &amp;lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&amp;gt; &amp;lt;prop key=&quot;java.lang.ArithmeticException&quot;&amp;gt;error&amp;lt;/prop&amp;gt; &amp;lt;/props&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&amp;gt; &amp;lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;2、基于注解的异常处理//@ControllerAdvice将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController { //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model){ model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; }}十二、注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能1、创建初始化类，代替web.xml在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer { /** * 指定spring的配置类 * @return */ @Override protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() { return new Class[]{WebConfig.class}; } /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() { return new String[]{&quot;/&quot;}; } /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() { CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]{encodingFilter, hiddenHttpMethodFilter}; }}2、创建SpringConfig配置类，代替spring的配置文件@Configurationpublic class SpringConfig { //ssm整合之后，spring的配置信息写在此类中}12343、创建WebConfig配置类，代替SpringMVC的配置文件@Configuration//扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)//开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer { //使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } //配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver(){ return new CommonsMultipartResolver(); } //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); } //配置视图控制 /*@Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); }*/ //配置异常映射 /*@Override public void configureHandlerExceptionResolvers(List&amp;lt;HandlerExceptionResolver&amp;gt; resolvers) { SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); }*/ //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() { WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; } //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) { SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; } //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) { ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; }}4、测试功能@RequestMapping(&quot;/&quot;)public String index(){ return &quot;index&quot;;}1234十三、SpringMVC执行流程1、SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图作用：将模型数据通过页面展示给用户2、DispatcherServlet初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kphToPhs-1627992919015)(img/img005.png)]初始化WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServletprotected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // A context instance was injected at construction time -&amp;gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -&amp;gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -&amp;gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // No context instance was injected at construction time -&amp;gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); } if (wac == null) { // No context instance is defined for this servlet -&amp;gt; create a local one // 创建WebApplicationContext wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&amp;gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) { // 刷新WebApplicationContext onRefresh(wac); } } if (this.publishContext) { // Publish the context as a servlet context attribute. // 将IOC容器在应用域共享 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); } return wac;}创建WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServletprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) { Class&amp;lt;?&amp;gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#39;&quot; + getServletName() + &quot;&#39;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); } // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) { wac.setConfigLocation(configLocation); } configureAndRefreshWebApplicationContext(wac); return wac;}DispatcherServlet初始化策略FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件所在类：org.springframework.web.servlet.DispatcherServletprotected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);}3、DispatcherServlet调用组件处理请求processRequest()FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)所在类：org.springframework.web.servlet.FrameworkServletprotected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try { // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); } catch (ServletException | IOException ex) { failureCause = ex; throw ex; } catch (Throwable ex) { failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); } finally { resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) { requestAttributes.requestCompleted(); } logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); }}doService()所在类：org.springframework.web.servlet.DispatcherServlet@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&amp;lt;String, Object&amp;gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) { attributesSnapshot = new HashMap&amp;lt;&amp;gt;(); Enumeration&amp;lt;?&amp;gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) { String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) { attributesSnapshot.put(attrName, request.getAttribute(attrName)); } } } // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) { FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) { request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); } request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); } RequestPath requestPath = null; if (this.parseRequestPath &amp;amp;&amp;amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) { requestPath = ServletRequestPathUtils.parseAndCache(request); } try { // 处理请求和响应 doDispatch(request, response); } finally { if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) { restoreAttributesAfterInclude(request, attributesSnapshot); } } if (requestPath != null) { ServletRequestPathUtils.clearParsedRequestPath(request); } }}doDispatch()所在类：org.springframework.web.servlet.DispatcherServletprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; Exception dispatchException = null; try { processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) { noHandlerFound(processedRequest, response); return; } // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) { return; } } // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); } catch (Exception ex) { dispatchException = ex; } catch (Throwable err) { // As of 4.3, we&#39;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); } // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); } catch (Exception ex) { triggerAfterCompletion(processedRequest, response, mappedHandler, ex); } catch (Throwable err) { triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); } finally { if (asyncManager.isConcurrentHandlingStarted()) { // Instead of postHandle and afterCompletion if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else { // Clean up any resources used by a multipart request. if (multipartRequestParsed) { cleanupMultipart(processedRequest); } } }}processDispatchResult()private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception { boolean errorView = false; if (exception != null) { if (exception instanceof ModelAndViewDefiningException) { logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); } else { Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); } } // Did the handler return a view to render? if (mv != null &amp;amp;&amp;amp; !mv.wasCleared()) { // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) { WebUtils.clearErrorRequestAttributes(request); } } else { if (logger.isTraceEnabled()) { logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); } } if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Concurrent handling started during a forward return; } if (mappedHandler != null) { // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); }}4、SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：a) 不存在i. 再判断是否配置了mvc:default-servlet-handlerii. 如果没配置，则控制台报映射查找不到，客户端展示404错误iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误b) 存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。" }, { "title": "想做的事", "url": "/posts/%E6%83%B3%E5%81%9A%E7%9A%84%E4%BA%8B/", "categories": "生活, 闲聊", "tags": "", "date": "2022-07-10 00:00:00 +0800", "snippet": "" }, { "title": "优先队列PriorityQueue", "url": "/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97PriorityQueue/", "categories": "算法与数据结构", "tags": "", "date": "2022-07-08 00:00:00 +0800", "snippet": "优先队列概述优先队列PriorityQueue是Queue接口的实现，可以对其中元素进行排序，可以放基本数据类型的包装类（如：Integer，Long等）或自定义的类，对于基本数据类型的包装器类，优先队列中元素默认排列顺序是升序排列，但对于自己定义的类来说，需要自己定义比较器，虽说它被称为优先队列，但是它的底层数据结构实际上是我们熟知的堆结构，而且默认情况下，即new PriorityQueue&amp;lt;&amp;gt;()是小根堆，所以很多时候我们不用自己手写堆，使用PriorityQueue就可以了常用方法peek()//返回队首元素poll()//返回队首元素，队首元素出队列add()//添加元素offer()//添加元素size()//返回队列元素个数isEmpty()//判断队列是否为空，为空返回true,不空返回false注意：在java1.5中add()实际上调用的offer()优先队列的使用1.队列保存的是基本数据类型的包装类public class PriorityQueueSort { public static void priorityQueueSort(int[] arr){ PriorityQueue&amp;lt;Integer&amp;gt; smallHeap = new PriorityQueue&amp;lt;&amp;gt;(); // 默认小根堆，且升序 for (int num : arr) { smallHeap.add(num); } for (int i = 0; i &amp;lt; arr.length; i++) { // 我们发现PriorityQueue每次需要Poll输出元素，最终的数组序列才是有序的 Integer poll = smallHeap.poll(); System.out.print(poll + &quot; &quot;); } } public static void main(String[] args) { int[] arr = new int[]{38, 43 , 45, 20, 23, 100, 1, 4, 19 }; priorityQueueSort(arr); }}理解优先队列：1.默认情况下的优先队列其实就是小根堆，每次poll的过程其实包含：从堆中去除根元素，然后heapify，在这样反复的poll，输出的元素就是有序的，因为每次输出了小根堆的根元素2.如果让我自己手写小根堆，思路和大根堆一样，不过最后需要排序出来后是倒叙的，所以需要首位交换元素2.队列保存的是自定义类//矩形类class Node{ public Node(int chang,int kuan) { this.chang=chang; this.kuan=kuan; } int chang; int kuan;}public class Test {　　　　//自定义比较类，先比较长，长升序排列，若长相等再比较宽，宽降序 static Comparator&amp;lt;Node&amp;gt; cNode=new Comparator&amp;lt;Node&amp;gt;() { public int compare(Node o1, Node o2) { if(o1.chang!=o2.chang) return o1.chang-o2.chang; else return o2.kuan-o1.kuan; } }; public static void main(String[] args) { Queue&amp;lt;Node&amp;gt; q=new PriorityQueue&amp;lt;&amp;gt;(cNode); Node n1=new Node(1, 2); Node n2=new Node(2, 5); Node n3=new Node(2, 3); Node n4=new Node(1, 2); q.add(n1); q.add(n2); q.add(n3); Node n; while(!q.isEmpty()) { n=q.poll(); System.out.println(&quot;长: &quot;+n.chang+&quot; 宽：&quot; +n.kuan); }　　　　　/**　　　　　　* 输出结果　　　　　　* 长: 1 宽：2　　　　　　* 长: 2 宽：5　　　　　　* 长: 2 宽：3　　　　　　*/ }}" }, { "title": "HashMap遍历的三种方式", "url": "/posts/HashMap%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/", "categories": "算法与数据结构", "tags": "", "date": "2022-07-08 00:00:00 +0800", "snippet": "HashMap的三种遍历方式import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test { public static void main(String[] args) { HashMap&amp;lt;String, String&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;(); hashMap.put(&quot;1&quot;,&quot;value1&quot;); hashMap.put(&quot;2&quot;,&quot;value2&quot;); hashMap.put(&quot;3&quot;,&quot;value3&quot;); hashMap.put(&quot;4&quot;,&quot;value4&quot;); hashMap.put(&quot;5&quot;,&quot;value5&quot;); hashMap.put(&quot;6&quot;,&quot;value6&quot;); /** * 第一种遍历方式，采用for遍历key值，然后通过key去获取hashmap中的数据 */ System.out.println(&quot;*********第一种遍历方式*********&quot;); for (String key:hashMap.keySet()) { System.out.println(&quot;key: &quot; + key + &quot; value: &quot; + hashMap.get(key)); } /** * 第二种遍历方式，采用Iterator 把hashmap中的数据放到迭代器中，然后用while循环把迭代器中的数据都读出来 */ System.out.println(&quot;*********第二种遍历方式*********&quot;); Iterator iterator = hashMap.entrySet().iterator(); while(iterator.hasNext()) { Map.Entry&amp;lt;String, String&amp;gt; entry=(Map.Entry&amp;lt;String, String&amp;gt;) iterator.next(); System.out.println(&quot;Key: &quot;+entry.getKey()+&quot; Value: &quot;+entry.getValue()); } /** * 第三种遍历方式，采用for循环遍历hashmap中的数据，使用方便，但是数据量小时好用，如果数据量大的话非常消耗性能 */ System.out.println(&quot;*********第三种遍历方式*********&quot;); for(Map.Entry&amp;lt;String, String&amp;gt; entry: hashMap.entrySet()) { System.out.println(&quot;Key: &quot;+ entry.getKey()+ &quot; Value: &quot;+entry.getValue()); } }}" }, { "title": "详解桶排序及排序大总结", "url": "/posts/%E8%AF%A6%E8%A7%A3%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%8E%92%E5%BA%8F%E5%A4%A7%E6%80%BB%E7%BB%93/", "categories": "算法与数据结构", "tags": "", "date": "2022-07-06 00:00:00 +0800", "snippet": "二叉树完全二叉树和满二叉树二叉树的高度如果二叉树只有根节点，那么高度为1数组与完全二叉树按照数组的顺序，依次填满完全二叉树：我们发现即对于节点A，下标为n，左孩子对应下标为：2n+1，右孩子对应下标为：2n+2，父节点对应下标为：n-1/2堆、大根堆和小根堆堆本质上就是完全二叉树，大根堆特性：对于任意根节点n都有value(n)&amp;gt;=value(2n+1)&amp;amp;&amp;amp;value(n)&amp;gt;=value(2n+2)，即对于任意父节点所有的子树节点都比它小；小根堆则相反数组与堆像这样大根堆起初的heapSize为0，不断追加数组中的元素，heapSize++，同时会执行heapInsert过程调正大根堆，heapInsert是由子节点不断往上替换小值的过程直到value(n) &amp;lt; value((n-1/2))或n = 0移除堆的根元素首先如何从堆中排除根元素：因为经过heapInsert过程，堆的首元素就是根元素，将根元素与堆末尾元素交换，然后heapSize–就排除了根元素，此时数组长度-堆长度等于1然后heapify：heapify过程大致如下：父元素等于左右子树中较大者比较，如果父元素小，交换，否则不动，直到没有左右子树，即2n+1&amp;gt;=heapSize停止heapify过程；我们发现heapify是一个向下的过程替换堆的某个节点需要先判断是应该执行heapInsert还是heapify过程，如果以该数为根节点的子树依然满足大根堆，说明不用执行heapify过程，如果该数所在的子树也满足大根堆说明也不用heapInsert过程堆排序public class HeapSort { // 大根堆排序 public static void heapSort(int[] arr){ if (arr == null || arr.length &amp;lt; 2) { return; }// for (int i = 0; i &amp;lt; arr.length; i++) {// heapInsert(arr, i);// } for (int i = arr.length-1; i &amp;gt;= 0 ; --i) { // 此时堆的长度就是数组的长度，每次heapify保证子树为大根堆，最终整个是大根堆 heapify(arr, i, arr.length); // 这种写法稍快 } int heapSize = arr.length; swap(arr, 0, --heapSize); while (heapSize &amp;gt; 0){ // 堆是否为空 heapify(arr, 0, heapSize); swap(arr, 0, --heapSize); } } private static void heapify(int[] arr, int index, int heapSize) { int left = index * 2 + 1; while(left &amp;lt; heapSize){ int largest = left + 1 &amp;lt; heapSize &amp;amp;&amp;amp; arr[left + 1] &amp;gt; arr[left] ? // 在这里判断右孩子是否越界 left + 1 : left; largest = arr[largest] &amp;gt; arr[index] ? largest : index; // 求出父与子中较大者的下标 if (largest == index){ // 父就是大，不再heapify break; } swap(arr, largest, index); // 重复while操作 index = largest; left = index * 2 + 1; } } private static void heapInsert(int[] arr, int index) { while(arr[index] &amp;gt; arr[(index-1)/2]){ // index=0,条件=退出 swap(arr, index, (index-1)/2); index = (index-1)/2; } } private static void swap(int[] arr, int a, int b) { int tmp = arr[a]; arr[a] = arr[b]; arr[b] = tmp; }}堆排序总结 如果下标不从0开始，而是1，那么子节点下标A和父节点下标B有：A &amp;gt;&amp;gt; 1 = B 大根堆使用用于排序，小根堆不适合，如果硬要使用小根堆的话最后还要反转，（不过在heapiy阶段不交换尾部和头部的值，采取头部++的操作是不可行的，因为这样不好确认左子节点是否超出界限），所以总结来说小根堆不适合排序（适合排倒序）优先队列与堆优先队列与小根堆public class PriorityQueueSort { public static void priorityQueueSort(int[] arr){ PriorityQueue&amp;lt;Integer&amp;gt; smallHeap = new PriorityQueue&amp;lt;&amp;gt;(); // 默认小根堆，且升序 for (int num : arr) { smallHeap.add(num); } for (int i = 0; i &amp;lt; arr.length; i++) { // 我们发现PriorityQueue每次需要Poll输出元素，最终的数组序列才是有序的 Integer poll = smallHeap.poll(); System.out.print(poll + &quot; &quot;); } } public static void main(String[] args) { int[] arr = new int[]{38, 43 , 45, 20, 23, 100, 1, 4, 19 }; priorityQueueSort(arr); }}理解优先队列：1.默认情况下的优先队列其实就是小根堆，每次poll的过程其实包含：从堆中去除根元素，然后heapify，在这样反复的poll，输出的元素就是有序的，因为每次输出了小根堆的根元素2.如果让我自己手写小根堆，思路和大根堆一样，不过最后需要排序出来后是倒叙的，所以需要首位交换元素优先队列与大根堆一行语句就可以设置优先队列为大根堆：PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;((o1, o2) -&amp;gt; o2 - o1);构造函数传入的参数其实就是比较器Comparator，只不过这里使用的是lambda的写法比较器对于所有的比较器，返回值为-，第一个参数放前面，返回值为+，第二参数放前面，返回0，无所谓返回哪个参数，大致看下比较器的类结构：可见Comparator它是函数式接口，因此我们就可以使用lambda表达式传递Comparator对象优先队列扩容的复杂度和影响 优先队列会如何扩容：默认数组容量不足时，会扩容成原来的2倍，也就是说原来的数组长度是10，经过第一次扩容后长度是20 如果经过多次扩容后数组的长度是N，那么数组扩容的多少次：logN次 每次扩容后原数组和当前数组不是同一个，所以会将原数组的元素拷贝进当前数组，时间复杂度是O(N) 平均到每个元素，平均时间复杂度是：NlogN/N = logN，而堆排序的时间复杂度是O(NlogN)，所以扩容是不会对排序本身的时间复杂度造成影响手写堆的原因虽然我们可以不手写堆，而使用PriorityQueue，但大多数情况下我们是需要手写堆的，原因： 优先队列无法修改堆中的某个元素，并重新堆化 不能直接获取堆中某个下标的值，如果要获取需先将优先队列转化成数组常见例题 小范围排序 思路：小根堆维护k个元素，每再加入一个元素，此时的根元素一定排在数组第一个，因为数组原来的位置与排好序的位置距离不超过k 前 K 个高频元素 首先得计算每个数组元素出现得频次，然后依据频次维护小根堆，并保持size=k，每次有更大的频次就需要add，同时为了保持size=k，需要弹出根元素；该题的难点在于：如何再求出前k个高频次数字后求出其对应的元素，再我的写法中PriorityQueue维护的是Map.Emtry&amp;lt;Integer,Integer&amp;gt;，并且优先队列的比较规则是O1.getValue()-O2.getValue()，也就是小根堆；最后取出元素的时候调用O.getKey()就行了也可使用快排的局部排序法 稳定排序稳定性的意义这里的稳定性指的就是能够继承原来的排序次序，例如如果我原来是按照价格升序排序，现在要按找销量降序，那么如果是稳定排序，如果销量相同，次序依然会保留原来的价格排序，这样商品的次序就可以描述为最物美价廉，如果不是稳定排序，那么次序是不能保证的排序稳定性总结：   时 空 稳 选择 O(N^2) O(1) 否 冒泡 O(N^2) O(1) 是 插入 O(N^2) O(1) 是 归并 O(NlogN) O(N) 是 快排（随机数） O(NlogN) O(logN) 否 堆 O(NlogN) O(1) 否 注意：1.经过实验统计，快排确实最快，所以能尽量用快排就用2.除非对空间有限制用堆排，其余尽量用快排3.目前没有发现时间复杂度是O(logN)，空间复杂度在O(N)以下，又稳定的排序非比较排序像这种排序，必须通过自己分析数据状况，自己设计解法；比较排序只要给定数据比较的规则，放入数据它就会返回给你有序的数据计数排序常见应用场景：按年龄排序 因为年龄最大不会超过200，所以构建一个长度为200的数组，用数组下标代表年龄，数组值代表相同年龄的人的个数，遍历数组，个数*下标填充排序数组后就是正确的序列可见计数排序会受数据的范围影响，因为我们的数组不可能建的无限大这就是计数排序的一个常见的应用场景：词频计数基数排序（桶排序）基数排序的步骤： 按照数组中最大数的位数，将其与不足位数的数用0在前面补齐 准备最多10个桶（0~9） 将每个数从个位数开始一次放入对应的桶，然后按从0~9的次序一次倒出排好序，接下来换十位重复操作 最后倒出来的数据就会有序总结：1.因为每次进桶出桶是按照某一位进行排序的，并且每次排序的次序被继承下来了，最后数据在高位有序，低位也有序，所以最终整体有序2.值得注意的是桶应该是一个先进先出的数据结构3.数据必须有进制，才能使用基数排序public class RadixSort { public static void radixSort(int[] arr){ if (arr == null || arr.length &amp;lt; 2){ return; } radixSort(arr, 0, arr.length-1, maxbits(arr)); } public static int maxbits(int[] arr){ int max = Integer.MIN_VALUE; for (int i = 0; i &amp;lt; arr.length; i++) { max = Math.max(max, arr[i]); } int res = 0; // 计算最大数的位数 while(max != 0){ res++; max /= 10; } return res; } public static void radixSort(int[] arr, int L, int R, int digit){ //[L, R]，可以是局部排序也可以是整体排序 final int radix = 10; //十进制是这个数 int i = 0, j = 0; int[] bucket = new int[R - L + 1]; //准备与数组长度相同的辅助空间 for (int d = 1; d &amp;lt;= digit; d++) { //有多少位就进出几次（个位d=1，十位d=2，百位d=3） //10个空间 // count[0] 当前位（d位）是0的数字有多少个 // count[1] 当前位（d位）是1的数组有多少个 // ..... // count[i] 当前位是（0~i）的数字有多少个 int[] count = new int[radix]; //count[0....9] for (i = L; i &amp;lt;= R; i++) { //从左到右分析词频：在d位上相等的数据计数 j = getDigit(arr[i], d); count[j]++; } for (i = 1; i &amp;lt; radix; i++) { //将词频分析完毕后的count数组处理：i下标的值等于i-1下标的值+自身，注意count数组初始化是数据均为0 count[i] = count[i] + count[i - 1]; // 经过处理后的count[i]表示：d位上为i的数有多少个 } for (i = R; i &amp;gt;= L; i--) { //为什么是从R~L：为了继承上一次进桶出桶得到的排序，注意最初的数组顺序也是保留的 j = getDigit(arr[i], d); bucket[count[j] - 1] = arr[i]; // 因为排序被继承，原先最右的，在第二次排序时也应该时同级别大小数据的最右，所以在辅助数组中的下标是count[j]-1，其中count[j]是同级别数据的个数，所以-1才是下标 count[j]--; } for (i = L; i &amp;lt;= R; i++) { //在将赋值数组的数据复制回原数组，这样一次进桶出桶完成 arr[i] = bucket[i]; } } } public static int getDigit(int x, int d){ return ((x / ((int) Math.pow(10, d - 1))) % 10); }}" }, { "title": "定位设置元素居中", "url": "/posts/%E5%AE%9A%E4%BD%8D%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/", "categories": "前端, CSS", "tags": "", "date": "2022-07-01 00:00:00 +0800", "snippet": "子绝父相的应用&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;容器水平垂直居中&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; /* 第一种方法 */ div.outside { /* position: relative; height: 200px; width: 200px; background-color: skyblue; */ } div.inside { /* 公式：左上偏移50%，再减去自身宽高的一般 */ /* width: 100px; height: 100px; background-color: red; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px; */ } /* 第二中方法 */ div.outside { position: relative; height: 200px; width: 200px; background-color: skyblue; } div.inside { /* 公式：左上偏移50%，再减去自身宽高的一般 */ width: 100px; height: 100px; background-color: red; position: absolute; top: 50%; left: 50%; /* translate()函数是css3的新特性.在不知道自身宽高的情况下，可以利用它来进行水平垂直居中 */ transform: translate(-50%, -50%); } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;outside&quot;&amp;gt; &amp;lt;div class=&quot;inside&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;" }, { "title": "定位", "url": "/posts/%E5%AE%9A%E4%BD%8D/", "categories": "前端, CSS", "tags": "", "date": "2022-07-01 00:00:00 +0800", "snippet": "为什么要使用定位定位可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子（浮在其他盒子上面），这是标准流和浮动都无法快速实现的效果定位组成定位 = 定位模式 + 边偏移 定位模式：决定元素的定位方式，它通过CSS的position属性来设置，其值分为四个： static：静态定位，也就是无定位，用的少 relative：相对定位 absolute：绝对定位 fixed：固定定位 边偏移：定位盒子移动到的最终位置，有top、bottom、left、right四个属性 top：顶端偏移量，定义元素相对于父元素上边线的距离 bottom：底部偏移量，定义元素相对于父元素下边线的距离 left：左侧偏移量，定义元素相对于父元素左边线的距离 right：右侧偏移量，定义元素相对于父元素右边线的距离 注意：边偏移量可以为负值，即往反方向移动相对定位relative相对定位是在元素移动位置的时候，相对与它原来的位置来说的特点： 移动位置参照点是自己原来的位置 不脱离标准流，原来的位置会继续占有，也就是说如果移动，其他元素不会占用它原来的位置绝对定位absolute绝对定位是元素在移动位置的时候，相对于它祖先元素来说的特点： 没有父级元素或父级元素无定位，则以浏览器为准定位（即html标签，这时元素左上角对应页面最上角） 如果祖先元素（包括父元素）有定位（相对、绝对、固定定位），则以最近的有定位的祖先元素为参考点移动位置 绝对定位不再占用原先位置，也就是说元素一旦脱离，其他元素就会占用它的位置子绝父相的由来 子元素决定定位，可以移动到父盒子任意地方却不会占用位置，其他元素不受影响，可以保持原来的布局 父盒子应该用相对，占用位置，保持布局定位的特殊性质 行内元素添加绝对或者固定定位，可以直接设置高度和宽度，也就是说在加上绝对和固定定位后行内元素变成了块元素，这样和浮动的效果类似 块元素添加绝对或者固定定位，如果不给宽度和高度，默认大小是内容的大小，原本应该独占一行的，像下面这样：加了之后就变成这样了：实际上从块元素变成了行内元素" }, { "title": "伪元素选择器", "url": "/posts/%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/", "categories": "前端, CSS", "tags": "", "date": "2022-07-01 00:00:00 +0800", "snippet": "定义伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签从而简化HTML结构常见选择符::before：在元素内部的前面插入内容::after：在元素内部的后面插入内容特性 before和after创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称其为伪元素 语法：element::before{} before和after必须有content属性 伪元素选择器和标签选择器一样权重为1，这里权重的左右是确定样式生效的级别，权重大的覆盖权重小的样式，权重相同就近原则简单效果展示&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;伪元素选择器&amp;lt;/title&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./panel.css&quot;&amp;gt; &amp;lt;style&amp;gt; .box{ width: 300px; height: 300px; font-size: 50px; } .box::before{ content: &#39;C&#39;; } .box::after{ content: &#39;S&#39;; } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;box&quot;&amp;gt; S &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;可见before和after分别在元素内部内容的前面和后面" }, { "title": "panel盒子设置上下左右四个边框", "url": "/posts/panel%E7%9B%92%E5%AD%90%E8%AE%BE%E7%BD%AE%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E5%9B%9B%E4%B8%AA%E8%BE%B9%E6%A1%86/", "categories": "前端, CSS", "tags": "", "date": "2022-07-01 00:00:00 +0800", "snippet": "定位、less语法和伪元素选择器的使用&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;panel盒子上下左右边框&amp;lt;/title&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./panel.css&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;panel&quot;&amp;gt; &amp;lt;div class=&quot;panel-footer&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.panel{ width: 8.125rem; height: 8.125rem; border: 1px solid #1e1e1e; position: relative; &amp;amp;::before{ position: absolute; content: &#39;&#39;; top: 0; left: 0; height: 2.1042rem; width: 2.1042rem; border-top: 2px solid green; border-left: 2px solid green; } &amp;amp;::after{ position: absolute; content: &#39;&#39;; top: 0; right: 0; /*这里after和before本来应该是行内元素的，但因为加了absolute定位，变成了块元素，因此可以设置宽高*/ height: 2.1042rem; width: 2.1042rem; border-top: 2px solid green; border-right: 2px solid green; } .panel-footer{ /*这里panel-footer无定位，伪元素before和after相对于元素.panel*/ &amp;amp;::before{ position: absolute; content: &#39;&#39;; bottom: 0; left: 0; height: 2.1042rem; width: 2.1042rem; border-bottom: 2px solid green; border-left: 2px solid green; } &amp;amp;::after{ position: absolute; content: &#39;&#39;; bottom: 0; right: 0; height: 2.1042rem; width: 2.1042rem; border-bottom: 2px solid green; border-right: 2px solid green; } }}提醒：1.这里after和before本来应该是行内元素的，但因为加了absolute定位，变成了块元素，因此可以设置宽高2.这里panel-footer无定位，伪元素before和after相对于元素.panel进行移动3.&amp;amp;符号，这是less语法，指向上一级，也就是说&amp;amp;::after会被编译成.panel-footer::after或者panel::after，如果不使用&amp;amp;，就会编译成.panel-footer ::after或panel ::after，这样不符号伪元素语法" }, { "title": "在Vue中使用Less", "url": "/posts/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8Less/", "categories": "前端, Vue", "tags": "", "date": "2022-06-29 00:00:00 +0800", "snippet": "什么是LessLess使得在CSS样式中使用变量、计算、函数成为可能，它的存在使得CSS更加灵活，也让CSS的编写更加高效添加less和less-loader依赖控制台命令：yarn add less less-loader@7.3.0注意：1.less-loader的版本一定要与less兼容，否则会报错，如less-loader\\@7.3.0和less\\@4.1.3是兼容的2.less-loader依赖是为了解析less文件，因为less无法被浏览器解析，所以需要通过less-loader将less文件编译成CSS文件在组件中使用less语法使用less语法时，style标签的lang=&quot;less&quot;/*less 的嵌套语法*/&amp;lt;style lang=&quot;less&quot; scoped&amp;gt;.home { height: 530px; width: 780px; background-color: green; margin: auto; display: flex; flex-direction: column; padding: 10px; .header-container { background-color: #ffcc22; flex: 10%; display: flex; padding: 5px; margin-bottom: 10px; .header1 { background-color: #0066ff; flex: 1; text-align: center; line-height: 40.163px; color: white; } .header2 { background-color: #0066ff; flex: 2; color: white; text-align: center; line-height: 40.163px; margin: 0px 5px; } .header3 { background-color: #0066ff; flex: 1; color: white; text-align: center; line-height: 40.163px; } } .body-container { background-color: #ffcc22; flex: 90%; display: flex; padding: 5px; .body1-container { flex: 1; background-color: #00aa00; display: flex; flex-direction: column; // padding: 5px; .body1-child1 { flex: 1; background-color: #0066ff; margin: 5px; } .body1-child2 { flex: 1; background-color: #0066ff; margin: 0px 5px 5px 5px; } .body1-child3 { flex: 1; background-color: #0066ff; margin: 0px 5px 5px 5px; } .body1-child4 { flex: 1; background-color: #0066ff; margin: 0px 5px 5px 5px; } } .body2-container { flex: 2; background-color: #00aa00; margin: 0px 5px; display: flex; flex-direction: column; .body2-child1 { background-color: #ee7700; flex: 3; margin: 5px; } .body2-child2-container { background-color: #0066ff; flex: 1; margin: 0px 5px 5px 5px; display: flex; .atom-child1 { background-color: #ee7700; flex: 1; margin: 5px; } .atom-child2 { background-color: #ee7700; flex: 1; margin: 5px 5px 5px 0px; } } } .body3-container { flex: 1; background-color: #00aa00; flex: 1; background-color: #00aa00; display: flex; flex-direction: column; // padding: 5px; .body3-child1 { flex: 1; background-color: #0066ff; margin: 5px; } .body3-child2 { flex: 1; background-color: #0066ff; margin: 0px 5px 5px 5px; } .body3-child3 { flex: 1; background-color: #0066ff; margin: 0px 5px 5px 5px; } .body3-child4 { flex: 1; background-color: #0066ff; margin: 0px 5px 5px 5px; } } }}&amp;lt;/style&amp;gt;如何在项目中引入全局Less样式在main.js中import引入：import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;@/assets/less/common.less&#39; // 全局CSS样式Vue.config.productionTip = falsenew Vue({ render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;)总结要想在Vue中使用less，引入less和less-loader两个组件，然后就可以将CSS替换成less语法了" }, { "title": "CSS初始化", "url": "/posts/CSS%E5%88%9D%E5%A7%8B%E5%8C%96/", "categories": "前端, CSS", "tags": "", "date": "2022-06-28 00:00:00 +0800", "snippet": "/* 初始化start */* { margin: 0px; /* 内间距 */ padding: 0px; /* 外间距 */ font-size: 16px; /* 默认字体大小，谷歌的默认字体大小 */ box-sizing: border-box; /*减掉border和padding的值*/}a{ text-decoration: none; /* 消除下划线 */ color: #fff; /* 主题颜色： 白色*/}a:hover{ color: #e33333;}input{ outline: none; /* 去除选中后的黑色内边线效果 */}/*图片没有边框*/img{ border: 0; vertical-align: middle;}/*让所有斜体 不倾斜*/em,i {font-style: normal;}/*去掉列表前面的小点*/li{ list-style: none;}/*让button按钮变成小手*/button{ cursor: pointer;}" }, { "title": "索引", "url": "/posts/%E7%B4%A2%E5%BC%95/", "categories": "数据库, MySQL", "tags": "", "date": "2022-06-25 00:00:00 +0800", "snippet": "索引概述索引是帮助 MySQL 高效获取数据的有序的数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。优缺点：优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗缺点： 索引列也是要占用磁盘空间的 索引大大提高了查询效率，但降低了更新表的速度，比如 INSERT、UPDATE、DELETE实际上索引的缺点可以忽略：1.磁盘比较便宜2.往往在使用索引的表中，查询操作频率高，增删改频率低索引结构MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含一下几种： 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，性能高支持精确查询，但不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 注意：1.B+Tree索引不同的存储引擎基本都支持，Hash索引只有Memory支持2.平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引B-Tree在讲解B树之前，我们首先看看二叉树：二叉树缺点：1.数据本身有序，构建二叉树会退化成链表，这是性能大大降低，等于全表查询2.由于二叉树只有两个分支，如果数据量比较大，层级会很深，检索速度也会很低二叉树的缺点可以用红黑树来解决：红黑树的缺点：红黑树本质也是二叉树，也存在上述二叉树的缺点2，为了解决这个问题，可以使用 B-Tree 结构。以一棵最大度数为5（5阶）的 B-Tree(多路平衡查找树) 为例（每个节点最多存储4个key，5个指针） 须知：1.多路：一个节点下可以有多颗子树，这样就可以解决二叉树在数据量大的情况下，层级较深的情况2.度数：一个节点的子节点/子树的个数3.指针数等于子节点数 动态构建B树演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html子树分裂原则:中间节点向上分裂总结：对于B树来说，每个节点的每个key下都会挂着数据B+Tree结构图： 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.htmlB+树与B树1.区别： 所有的key都会出现在叶子节点 叶子节点形成一个单向链表 数据只挂在叶子节点的key下 非叶子节点只起到索引的作用2.相同点： B+Tree本质是B树的变种，因此也遵循子树分裂原则MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree（其实最终就形成了一个双向链表），提高区间访问的性能。另外一个节点是存储在一个页中的，在InnoDB中一个页大小默认是16KBHash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表（拉链法）来解决。特点： Hash索引只能用于等值查询（=、in），不支持范围查询（betwwn、&amp;gt;、&amp;lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索（前提是不出现hash碰撞）就可以了，效率通常要高于 B+Tree 索引存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 在相同数据量的情况下，相对于二叉树/红黑树，B+树层级更少，搜索效率更高 相对于B树，非叶子节点不存储数据，一页中可以存储更多的指针，因此在相同数据量情况下，B+树的层级更浅，检索速度更快，另外由于B+树只在叶子节点存储数据，因此搜索效率稳定，而且叶子节点形成了一个双向链表，范围查询更加高效 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个   全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图：聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引思考题1. 以下 SQL 语句，哪个执行效率高？为什么？select * from user where id = 10;select * from user where name = &#39;Arm&#39;;-- 备注：id为主键，name字段创建的有索引答：第一条语句，因为第二条需要回表查询，相当于两个步骤。2. InnoDB 主键索引的 B+Tree 高度为多少？答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。索引语法创建索引：create [ unique | fulltext ] index index_name on table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引，如果关联多个字段，建立的就是联合索引查看索引：SHOW INDEX FROM table_name;删除索引：DROP INDEX index_name ON table_name;案例：-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引create index idx_user_name on tb_user(name);-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引create unique index idx_user_phone on tb_user (phone);-- 为profession, age, status创建联合索引create index idx_user_pro_age_stat on tb_user(profession, age, status);-- 为email建立合适的索引来提升查询效率create index idx_user_email on tb_user(email);-- 删除索引drop index idx_user_email on tb_user;SQL性能分析SQL执行频次 为什么要查询SQL执行频次?SQL优化主要对查询语句进行优化，如果数据库的查询语句频次远小于增删改的频次，就没必要进行SQL优化了查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;慢查询日志 慢查询日志为我们定位出那些SQL查询语句效率比较低慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf，这也是Linux系统位置）中配置如下信息：# 开启慢查询日志开关slow_query_log=1# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log（Linux系统位置）查看慢查询日志开关状态：show variables like &#39;slow_query_log&#39;;show profiles 慢查询需要我们指定long_query_time，相对来说不太灵活，实际上有些sql虽然小于long_query_time，但也需要优化，于是通过show profiles我们可以查询任意一条SQL语句执行耗时的详细情况show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。1.通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;2.profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：SET [session/global] profiling = 1;3.查看所有语句的耗时：show profiles;4.查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;5.查看指定query_id的SQL语句CPU的使用情况：show profile cpu for query query_id;explain 前面介绍的慢查询和show profiles都是单纯从时间判断一条SQL是否需要优化，而实际上不仅仅是执行时间，语句是否使用索引，多表查询中表的连接顺序等等也是判断的标准，而explain就能获取到这些信息EXPLAIN或者DESC命令获取select语句的执行计划语法：# 直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等（参考意义不大） type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all（比较重要，根据主键或唯一索引查询一般为const，如果是非唯一索引则一般是ref，all是全表扫描，index表示用了索引但扫描了所有索引） possible_keys：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好，也就是说索引字段尽量占用空间少 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 Extra：前面字段没有展示的信息会在Extra中展示总结：开发人员进行SQL优化时最主要关注的就是explain，而在explain中我们主要关注type，possible_keys、key、key_len和Extra这几个字段使用规则最左前缀法则(主要针对联合索引)如果索引关联了多列（联合索引），要遵守最左前缀法则（即索引最左列必须存在），最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。注意：是最左边的列一定要存在，与其在查询中出现的位置并无关，例如：create index idx_user_pro_age_status on user(profession, age, status);-- idx_user_pro_age_status在下面这条SQL查询中会生效的，因为在where中profession条件是存在的explain select * from user where age=31 and status=&#39;0&#39; and profession = &#39;软件工程&#39;; 范围查询(也是针对联合索引)联合索引中，出现范围查询（&amp;lt;, &amp;gt;），范围查询右侧的列索引失效。可以用&amp;gt;=或者&amp;lt;=来规避索引失效问题。例如下图：这里我有个问题，要是把范围查询的索引部分放在最右，那么会有索引失效吗索引失效情况索引列进行运算操作在索引列上进行运算操作，索引将失效。如下图示：字符串不加引号字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号，phone字段上建立的索引会失效注意：对联合索引也是一样的，如果联合索引某个字段值是字符串，但未加引号，这个字段上的索引会失效头部模糊匹配模糊查询中，如果仅仅是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like &#39;%工程&#39;;，前后都有 % 也会失效。or连接的条件用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。就算其中一个列是主键，也会失效，这时会进行全表扫描，性能最差，当然如果索引失效，走的自然是全表扫描，如下图：数据分布影响如果MySQL的优化器评估使用索引比全表更慢，则不使用索引。一般如果一条查询一定会走全表扫描，或者要扫描表的大部分，MySQL优化器会评估直接使用全表扫描，毕竟省去了翻目录的时间SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。例如：1.建议使用索引，use index：explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;2.不使用哪个索引，ignore index：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;3.必须使用哪个索引，force index：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。覆盖索引&amp;amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），尽量减少 select *。通过Extra中展示的值，能够区分出查询是否回表查询（注意：Extra在不同的MySQL版本，展示的值会不一样） explain 中 Extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如何利用辅助索引（二级索引）优化SQL：1.如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；2.如果在辅助索引中找聚集索引，如select id, name from xxx where name=&#39;xxx&#39;;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；3.如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name=&#39;xxx&#39;;所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username=&#39;itcast&#39;;解：1. 给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 或者击中缓存 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式：select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user;show index 里面的sub_part可以看到接取的长度单列索引&amp;amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。单列索引情况：explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;这句只会用到phone索引字段，如果name字段也建立了索引，MySQL只会使用两者中的一个，MySQL会判断name和phone谁的索引查询效率高从而选择效率高的，注意：1.多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询2.单列索引和联合索引都属于二级索引设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询问题保留1.索引是如何被加载进入内存的，按页？按区？还是按段？" }, { "title": "存储引擎", "url": "/posts/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/", "categories": "数据库, MySQL", "tags": "", "date": "2022-06-24 00:00:00 +0800", "snippet": "概述MySQL体系结构：存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。相关操作：-- 查询建表语句show create table account;-- 建表时指定存储引擎CREATE TABLE 表名( ...) ENGINE=INNODB;-- 查看当前数据库支持的存储引擎show engines;InnoDB(8.0.X)InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（8.0之前表结构存储再.frm和.sdi文件中，8.0之后全部整合进了.ibd文件中）、数据和索引。参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间知识点：查看 Mysql 变量：show variables like &#39;innodb_file_per_table&#39;;从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibdInnoDB 逻辑存储结构：MyISAM(8.0.X)MyISAM 是 MySQL 早期的默认存储引擎。特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引Memory(8.0.X)Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。特点： 存放在内存中，速度快 支持hash索引（默认）文件： xxx.sdi: 存储表结构信息存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。如今这两个用的比较少，MyISAM被MongoDB替代，Memory被Redis替代" }, { "title": "Redis基础篇", "url": "/posts/Redis%E5%9F%BA%E7%A1%80%E7%AF%87/", "categories": "数据库, Redis", "tags": "", "date": "2022-06-24 00:00:00 +0800", "snippet": "一、Redis入门1.认识NoSQL1.1 什么是NoSQL NoSQL最常见的解释是”non-relational“， 很多人也说它是”Not Only SQL” NoSQL仅仅是一个概念，泛指非关系型的数据库 区别于关系数据库，它们不保证关系数据的ACID特性 NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入 常见的NoSQL数据库有：Redis、MemCache、MongoDB等1.2 NoSQL与SQL的差异   SQL NoSQL 数据结构 结构化 非结构化 数据关联 关联的 无关联的 查询方式 SQL查询 非SQL 事务特性 ACID BASE 存储方式 磁盘 内存 扩展性 垂直 水平 使用场景 1）数据结构固定2）相关业务对数据安全性、一致性要求较高 1）数据结构不固定2）对一致性、安全性要求不高3）对性能要求 2.认识Redis Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。Redis的特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码）。 支持数据持久化 支持主从集群、分片集群 支持多语言客户端通常在项目中对于性能要求较高的部分可以使用Redis改善3.安装Redis3.1 前置准备 本次安装Redis是基于Linux系统下安装的，因此需要一台Linux服务器或者虚拟机。 Ps：由于提供的CentOS操作系统为mini版，因此需要自行配置网络，不会配置的请联系我，如果您使用的是自己购买的服务器，请提前开放6379端口，避免后续出现的莫名其妙的错误！ 虚拟机：VMware16 操作系统：CentOS-7-x86_64-Minimal-1708 Redis：redis-6.2.6.tar xShell及xFtp：https://www.xshell.com/zh/free-for-home-school/3.2 安装Redis依赖 Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖yum install -y gcc tcl安装成功如下图所示：3.3 正式安装Redis 将redis-6.2.6.tar上传至/usr/local/src目录 在xShell中cd到/usr/local/src目录执行以下命令进行解压操作 tar -xzf redis-6.2.6.tar.gz 解压成功后依次执行以下命令 cd redis-6.2.6makemake install 安装成功后打开/usr/local/bin目录（该目录为Redis默认的安装目录） 4.启动Redis Redis的启动方式有很多种，例如：前台启动、后台启动、开机自启4.1 前台启动（不推荐） 这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下CTRL + C则Redis停止。不推荐使用。 安装完成后，在任意目录输入redis-server命令即可启动Redis redis-server 启动成功如下图所示 4.2 后台启动（不推荐） 如果要让Redis以后台方式启动，则必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下 因为我们要修改配置文件，因此我们需要先将原文件备份一份 cd /usr/local/src/redis-6.2.6 cp redis.conf redis.conf.bck 然后修改redis.conf文件中的一些配置 # 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0# 守护进程，修改为yes后即可后台运行daemonize yes # 密码，设置后访问Redis必须输入密码requirepass 1325 Redis其他常用配置 # 监听的端口port 6379# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录dir .# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15databases 1# 设置redis能够使用的最大内存maxmemory 512mb# 日志文件，默认为空，不记录日志，可以指定日志文件名logfile &quot;redis.log&quot; 启动Redis # 进入redis安装目录 cd /usr/local/src/redis-6.2.6# 启动redis-server redis.conf 停止Redis服务 # 通过kill命令直接杀死进程kill -9 redis进程id # 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -a 来指定密码redis-cli -a 132537 shutdown 4.3 开机自启（推荐） 我们也可以通过配置来实现开机自启 首先，新建一个系统服务文件 vi /etc/systemd/system/redis.service 将以下命令粘贴进去 [Unit]Description=redis-serverAfter=network.target [Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true [Install]WantedBy=multi-user.target 然后重载系统服务 systemctl daemon-reload 现在，我们可以用下面这组命令来操作redis了 # 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis 执行下面的命令，可以让redis开机自启 systemctl enable redis 二、Redis常见命令 我们可以通过Redis的中文文档：http://www.redis.cn/commands.html，来学习各种命令。 也可以通过菜鸟教程官网来学习：https://www.runoob.com/redis/redis-keys.html1.Redis数据结构介绍 Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样2.通用命令 通用指令是部分数据类型的，都可以使用的指令，常见的有如下表格所示 指令 描述 KEYS 查看符合模板的所有key，不建议在生产环境设备上使用 DEL 删除一个指定的key EXISTS 判断key是否存在 EXPIRE 给一个key设置有效期，有效期到期时该key会被自动删除 TTL 查看一个KEY的剩余有效期 可以通过help [command] 可以查看一个命令的具体用法！3.String类型 String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类： string：普通字符串 int：整数类型，可以做自增、自减操作 float：浮点类型，可以做自增、自减操作 不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m. KEY VALUE msg hello world num 10 score 92.5 String的常见命令有如下表格所示 命令 描述 SET 添加或者修改已经存在的一个String类型的键值对 GET 根据key获取String类型的value MSET 批量添加多个String类型的键值对 MGET 根据多个key获取多个String类型的value INCR 让一个整型的key自增1 INCRBY 让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 INCRBYFLOAT 让一个浮点类型的数字自增并指定步长 SETNX 添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX 添加一个String类型的键值对，并且指定有效期 Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：项目名:业务名:类型:id这个格式并非固定，也可以根据自己的需求来删除或添加词条。例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key： user相关的key：heima:user:1 product相关的key：heima:product:1如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储 KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} 4.Hash类型 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD Hash的常见命令有： 命令 描述 HSET key field value 添加或者修改hash类型key的field的值 HGET key field 获取一个hash类型key的field的值 HMSET hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了 HMGET 批量获取多个hash类型key的field的值 HGETALL 获取一个hash类型的key中的所有的field和value HKEYS 获取一个hash类型的key中的所有的field HVALS 获取一个hash类型的key中的所有的value HINCRBY 让一个hash类型key的字段值自增并指定步长 HSETNX 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 5.List类型 Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。特征也与LinkedList类似： 有序 元素可以重复 插入和删除快 查询速度一般常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等. List的常见命令有 命令 描述 LPUSH key element … 向列表左侧插入一个或多个元素 LPOP key 移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element … 向列表右侧插入一个或多个元素 RPOP key 移除并返回列表右侧的第一个元素 LRANGE key star end 返回一段角标范围内的所有元素 BLPOP和BRPOP 与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil 思考问题 如何利用List结构模拟一个栈? 先进后出，入口和出口在同一边 如何利用List结构模拟一个队列? 先进先出，入口和出口在不同边 如何利用List结构模拟一个阻塞队列? 入口和出口在不同边 出队时采用BLPOP或BRPOP 6.Set类型 Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征 无序 元素不可重复 查找快 支持交集、并集、差集等功能 Set的常见命令有 命令 描述 SADD key member … 向set中添加一个或多个元素 SREM key member … 移除set中的指定元素 SCARD key 返回set中元素的个数 SISMEMBER key member 判断一个元素是否存在于set中 SMEMBERS 获取set中的所有元素 SINTER key1 key2 … 求key1与key2的交集 SDIFF key1 key2 … 求key1与key2的差集 SUNION key1 key2 .. 求key1和key2的并集 交集、差集、并集图示7.SortedSet类型 Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。SortedSet具备下列特性： 可排序 元素不重复 查询速度快因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet的常见命令有 命令 描述 ZADD key score member 添加一个或多个元素到sorted set ，如果已经存在则更新其score值 ZREM key member 删除sorted set中的一个指定元素 ZSCORE key member 获取sorted set中的指定元素的score值 ZRANK key member 获取sorted set 中的指定元素的排名 ZCARD key 获取sorted set中的元素个数 ZCOUNT key min max 统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member 让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max 按照score排序后，获取指定排名范围内的元素 ZRANGEBYSCORE key min max 按照score排序后，获取指定score范围内的元素 ZDIFF、ZINTER、ZUNION 求差集、交集、并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可三、Redis客户端 安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括： 命令行客户端 图形化桌面客户端 编程客户端1.命令行客户端 Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下： redis-cli [options] [commonds] 其中常见的options有： -h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1 -p 6379：指定要连接的redis节点的端口，默认是6379 -a 132537：指定redis的访问密码 其中的commonds就是Redis的操作命令，例如： ping：与redis服务端做心跳测试，服务端正常会返回pong 不指定commond时，会进入redis-cli的交互控制台： 2.图形化客户端 下载地址：https://pan.baidu.com/s/1sxQTOt-A5MCvVZnlgDf0eA?pwd=1234 安装图形化客户端 安装步骤过于简单不再演示 如何连接到Redis 连接成功后如图所示 3.Java客户端3.1 Jedis快速入门 Jedis的官网地址： https://github.com/redis/jedis，我们先来个快速入门： 新建一个Maven工程并引入以下依赖 &amp;lt;!--引入Jedis依赖--&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.2.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt; &amp;lt;!--引入单元测试依赖--&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.8.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt; 编写测试类并与Redis建立连接 private Jedis jedis; @BeforeEach //被该注解修饰的方法每次执行其他方法前自动执行void setUp(){ // 1. 获取连接 jedis = new Jedis(&quot;192.168.230.88&quot;,6379); // 2. 设置密码 jedis.auth(&quot;132537&quot;); // 3. 选择库（默认是下标为0的库） jedis.select(0);} 编写一个操作数据的方法（这里以操作String类型为例） @Testpublic void testString(){ // 1.往redis中存放一条String类型的数据并获取返回结果 String result = jedis.set(&quot;url&quot;, &quot;https://www.oz6.cn&quot;); System.out.println(&quot;result = &quot; + result); // 2.从redis中获取一条数据 String url = jedis.get(&quot;url&quot;); System.out.println(&quot;url = &quot; + url);} 最后不要忘记编写一个释放资源的方法 @AfterEach //被该注解修饰的方法会在每次执行其他方法后执行 void tearDown(){ // 1.释放资源 if (jedis != null){ jedis.close(); } } 执行testString()方法后测试结果如图所示 3.2 Jedis连接池 Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式public class JedisConnectionFactory { private static final JedisPool jedisPool; static { //配置连接池 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(8); jedisPoolConfig.setMaxIdle(8); jedisPoolConfig.setMinIdle(0); jedisPoolConfig.setMaxWaitMillis(200); //创建连接池对象 jedisPool = new JedisPool(jedisPoolConfig,&quot;192.168.230.88&quot;,6379,1000,&quot;132537&quot;); } public static Jedis getJedis(){ return jedisPool.getResource(); }}3.3 SpringDataRedis介绍 SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis 官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：3.4 SpringDataRedis快速入门 SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单 首先新建一个Spring Boot工程 然后引入连接池依赖 &amp;lt;!--连接池依赖--&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;&amp;lt;/dependency&amp;gt; 编写配置文件application.yml（连接池的配置在实际开发中是根据需求来的） spring: redis: host: 192.168.230.88 #指定redis所在的host port: 6379 #指定redis的端口 password: 132537 #设置redis密码 lettuce: pool: max-active: 8 #最大连接数 max-idle: 8 #最大空闲数 min-idle: 0 #最小空闲数 max-wait: 100ms #连接等待时间 编写测试类执行测试方法 @SpringBootTestclass RedisDemoApplicationTests { @Resource private RedisTemplate redisTemplate; @Test void testString() { // 1.通过RedisTemplate获取操作String类型的ValueOperations对象 ValueOperations ops = redisTemplate.opsForValue(); // 2.插入一条数据 ops.set(&quot;blogName&quot;,&quot;Vz-Blog&quot;); // 3.获取数据 String blogName = (String) ops.get(&quot;blogName&quot;); System.out.println(&quot;blogName = &quot; + blogName); }} 3.5 RedisSerializer配置 RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的缺点： 可读性差 内存占用较大 那么如何解决以上的问题呢？我们可以通过自定义RedisTemplate序列化的方式来解决。 编写一个配置类RedisConfig @Configurationpublic class RedisConfig { @Bean public RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate(RedisConnectionFactory factory){ // 1.创建RedisTemplate对象 RedisTemplate&amp;lt;String ,Object&amp;gt; redisTemplate = new RedisTemplate&amp;lt;&amp;gt;(); // 2.设置连接工厂 redisTemplate.setConnectionFactory(factory); // 3.创建序列化对象 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 4.设置key和hashKey采用String的序列化方式 redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); // 5.设置value和hashValue采用json的序列化方式 redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer); redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer); return redisTemplate; }} 此时我们已经将RedisTemplate的key设置为String序列化，value设置为Json序列化的方式，再来执行方法测试 由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个对象 @Testvoid testSaveUser() { redisTemplate.opsForValue().set(&quot;user:100&quot;, new User(&quot;Vz&quot;, 21)); User user = (User) redisTemplate.opsForValue().get(&quot;user:100&quot;); System.out.println(&quot;User = &quot; + user);} 尽管Json序列化可以满足我们的需求，但是依旧存在一些问题。 如上图所示，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。 那么我们如何解决这个问题呢？我们可以通过下文的StringRedisTemplate来解决这个问题。 3.6 StringRedisTemplate 为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。 Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程 我们可以直接编写一个测试类使用StringRedisTemplate来执行以下方法 @SpringBootTestclass RedisStringTemplateTest { @Resource private StringRedisTemplate stringRedisTemplate; @Test void testSaveUser() throws JsonProcessingException { // 1.创建一个Json序列化对象 ObjectMapper objectMapper = new ObjectMapper(); // 2.将要存入的对象通过Json序列化对象转换为字符串 String userJson1 = objectMapper.writeValueAsString(new User(&quot;Vz&quot;, 21)); // 3.通过StringRedisTemplate将数据存入redis stringRedisTemplate.opsForValue().set(&quot;user:100&quot;,userJson1); // 4.通过key取出value String userJson2 = stringRedisTemplate.opsForValue().get(&quot;user:100&quot;); // 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象 User user = objectMapper.readValue(userJson2, User.class); // 6.打印结果 System.out.println(&quot;user = &quot; + user); } } 执行完毕回到Redis的图形化客户端查看结果 3.7 总结 RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象" }, { "title": "Word添加页眉和页码", "url": "/posts/Word%E6%B7%BB%E5%8A%A0%E9%A1%B5%E7%9C%89%E5%92%8C%E9%A1%B5%E7%A0%81/", "categories": "Office办公软件, Word", "tags": "", "date": "2022-06-22 00:00:00 +0800", "snippet": "给除封面、目录和参考文献的页面添加页眉光标定位到正文最前 –&amp;gt; 页面布局 –&amp;gt; 下一页光标位置不变 –&amp;gt; 页面插入 –&amp;gt; 页眉空白页/编译页眉定位在最前正文页眉 –&amp;gt; 取消链接到前一节 –&amp;gt; 删除封面和目录的页眉定位到参考文献的前一节 –&amp;gt; 布局 –&amp;gt; 分隔符 –&amp;gt; 下一页定位参考文献的页眉 –&amp;gt; 取消链接到前一节 –&amp;gt; 选中“首页不同” –&amp;gt; 关闭页眉页脚至此完成页眉的添加 总结：1.视图 –&amp;gt; 草稿 可以查看分隔符是否加上2.有时候取消链接到前一节无法点击，这是在前一节插入分隔符（布局 –&amp;gt; 分隔符 –&amp;gt; 下一页）就可以点击了3.有时候页眉的横线不能删除，取消链接上一节 –&amp;gt; 首页不同 –&amp;gt; 关闭页眉页脚 就可以发现页眉已经被干净删除了添加页码，并从正文开始添加页码的操作与页眉的添加非常相似定位到最前正文的页脚 –&amp;gt; 页码，设置页码格式 –&amp;gt; 起始页码=1 –&amp;gt; 取消链接到上一节（图片里没有指出了）页码 –&amp;gt; 页码底端 –&amp;gt; 普通数字2如果这时候参考文献页也有页码，但是需要删除：选中参考文献页脚 –&amp;gt; 选中首页不同 –&amp;gt; 关闭页眉页脚，然后你就会发现页脚已经被干净删除了" }, { "title": "事务", "url": "/posts/%E4%BA%8B%E5%8A%A1/", "categories": "数据库, MySQL", "tags": "", "date": "2022-06-21 00:00:00 +0800", "snippet": "概述事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。默认MySQL的事务是自动提交的，也就是说任意执行一次DML，MySQL会立即隐式的提交事务，当然这是MySQL默认的事务操作，下面我们将介绍另外两种事务操作事务操作建立表结构，初始化表结构 create table account( id int auto_increment primary key comment &#39;主键id&#39;, name varchar(10) comment &#39;姓名&#39;, money int comment &#39;余额&#39;) comment &#39;账户表&#39;;insert into account(name, money) values(&#39;张三&#39;, 2000),(&#39;李四&#39;, 2000);当前表结构：事务操作-转账演示1-@@autocommit=1set @@autocommit = 1;start transaction;-- 1. 查询张三账户余额select * from account where name = &#39;张三&#39;;-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = &#39;张三&#39;;-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#39;李四&#39;;总结：1.像这样逻辑相关的语句连续执行，一旦中间有执行错误，后面的语句都不会执行，这样就会导致非常严重的后果2.由于MySQL的默认行为，每条语句就是一个事务，实际上对于具有逻辑相关的语句应该放在同一个事务中执行事务操作-转账演示2-@@autocommit=01.关闭事务自动提交select @@autocommit;set @@autocommit = 0;2.执行转账操作但不提交3.执行转账操作并提交4.执行转账操作失败并回滚总结：在实际编程业务中，当事务执行成功，应该commit，事务执行失败，应该rollback事务操作-转账演示3-start transactionset @@autocommit = 1;start transaction;总结：start transaction开启事务不需要关闭自动提交事务四大特性以MySQL的InnoDB存储引擎为例 A：原子性（atom），即以事务为最小操作单位，事务内的所有操作要么都成功要么都失败；依靠回滚日志（undo log）实现 I：隔离性（Isolation），依赖数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行；依靠锁机制和MVCC实现 D：持久性（durable），事务一旦提交或回滚，它对数据库中数据的改变就是永久的，即使这之后数据库发生故障，影响依然存在（可以还原）；依靠重做日志（redo log）实现 C：一致性（consistency），即事务执行前后，数据依然保持逻辑一致性，这个逻辑一致性一般符合现实逻辑，或由DBA指定的规则；上述三者实现后，一致性才能实现并发事务问题 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 提醒：1.不可重复读出现的原因可能是其他并发事务对同一条记录进行了修改2.在可重复读的隔离级别下，事务内两次读到的记录一定是相同的，但如果数据库确实被修改了，就会出现明明读到的某条记录不存在，却插入不了的情况，因为在其他并发事务已经插入并提交了该条记录事务隔离级别 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差查看事务隔离级别：select @@tx_isolation;-- 或SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };-- 如：set session transaction isolation level read uncommitted;SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效遗留问题1.为什么在当前会话，虽然事务未提交，查询的结果却已经被影响？2.读已提交如何触发幻读问题（本人认为幻读问题是因为可重复读隔离级别造成的后果）3.在不可重复读当中，两个事务不可能同时写数据，如果A事务进行写操作，B事务的写操作就会被阻塞，A事务提交，B事务才会继续执行" }, { "title": "多表查询", "url": "/posts/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/", "categories": "数据库, MySQL", "tags": "", "date": "2022-06-19 00:00:00 +0800", "snippet": "多表关系项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本分为三种： 一对多（多对一） 多对多 一对一一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）笛卡尔积概述：两个集合，A集合和B集合的所有组合情况，如：select * from employee, dept;（在多表查询时，需要消除无效的笛卡尔积）消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id;内连接查询内连接也被称为相等连接或简单连接，它是把两张表中满足on子句中搜索条件/where子句搜索条件的行连接起来或者说把两张表中相关的行连接起来（注意：搜索条件中指定的列都会被显示，并不是说被合并成一列） 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;显式性能比隐式高例子：表结构如下：-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;外连接查询左外连接：两张表中满足on子句中搜索条件的行连接起来以及左表所有数据，SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;在这个格式中表1就是左表右外连接：两张表中满足on子句中搜索条件的行连接起来以及右表所有数据，SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;例子：-- 左select e.*, d.name from employee e left join dept d on e.dept = d.id;-- 右select d.name, e.* from employee e right join dept d on e.dept = d.id;内连接和外连接的区别：外连接有个明显的特点，就是不管满不满足on子句搜索条件，左表或右表的数据会全部查询，而内连接中要是不相关的行就不会被查询自连接查询当前表与自身的连接查询，自连接必须使用表别名， 如何理解内连接：内连接是自己于自己连接，也就是行与行之间是有相关逻辑的，例如下面例子中行与行之间可以通过id和manager两个字段联系起来，因此我们也可以将其看作两张不同的表，其中manager是从表中的外键，id是主表中的主键，这样一来就可作为内连接或外连接理解了语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;，自连接查询，可以是内连接查询，也可以是外连接查询例子：-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id;联合查询 union, union all把多次查询的结果合并，形成一个新的查询集语法：SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ...注意：1.进行联合查询的多张表的列数必须相等，字段类型也需要保持一致2.相比于UNION ALL，UNION会对合并的结果集去重3.联合查询比使用or效率高，不会使索引失效子查询概述：SQL中嵌套select语句，称为嵌套查询，也叫子查询，如：SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列）根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &amp;lt; &amp;gt; &amp;gt; &amp;gt;= &amp;lt; &amp;lt;=例子：-- 查询销售部所有员工select id from dept where name = &#39;销售部&#39;;-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = &#39;销售部&#39;);-- 查询xxx入职之后的员工信息select * from employee where entrydate &amp;gt; (select entrydate from employee where name = &#39;xxx&#39;);列子查询返回的结果是一列（可以是多行），即该字段下有多条记录符合要求。常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子：-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;);-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &amp;gt; all(select salary from employee where dept = (select id from dept where name = &#39;财务部&#39;));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &amp;gt; any (select salary from employee where dept = (select id from dept where name = &#39;研发部&#39;));行子查询返回的结果是一行（可以是多列）。常用操作符：=, &amp;lt;, &amp;gt;, IN, NOT IN例子：-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#39;xxx&#39;);表子查询返回的结果是多行多列常用操作符：IN例子：-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = &#39;xxx1&#39; or name = &#39;xxx2&#39;);-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &amp;gt; &#39;2006-01-01&#39;) as e left join dept as d on e.dept = d.id;注意：在MySQL中，子查询得到的临时表（结果集）应该给别名，不然当外侧select from 的表与里侧的相同就会报You can&#39;t specify target table &#39;外侧表名&#39; for update in FROM clause案例地址：删除重复的电子邮箱多表查询例题删除重复的电子邮箱 原题链接题解：delete from person where person.id in(select a.id from (select p1.id from person p1, person p2 where p1.email=p2.email and p1.id&amp;gt;p2.id) as a);易错点：1.如果是(select * from person p1, person p2 where p1.email=p2.email and p1.id&amp;gt;p2.id) as a，就会出错；因为a最后被作为临时表被查询，表中是不允许有重复的字段的2.select * from person p1, person p2 where p1.email=p2.email and p1.id&amp;gt;p2.id，必须有别名，规定派生表必须有自己的别名，否则报Every derived table must have its own alias3.如果少了这条语句select a.id from 就会报错You can&#39;t specify target table &#39;person&#39; for update in FROM clause，意思是子查询操作的表和最近外层操作的表不能是同一张表，所以往往把子查询作为临时表，再重复查询一次" }, { "title": "约束", "url": "/posts/%E7%BA%A6%E6%9D%9F/", "categories": "数据库, MySQL", "tags": "", "date": "2022-06-18 00:00:00 +0800", "snippet": "概述1.概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据2.目的，保证数据库中数据的： 正确性：检查约束符合现实逻辑或自定义的逻辑有效性：非空约束不为空、唯一约束不重复完整性：外键约束主从一致，不会出现主表数据删除或修改从表数据却还保持原样3.分类 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 4.使用方法：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 演示：create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &amp;gt; 0 and age &amp;lt; 120), status char(1) default &#39;1&#39;, gender char(1));注意：1.auto_increment是MySQL独有的关键词，代表主键自增2.只有约束primary key标识的字段才是主键，虽然primary key同时有unique和not null的效果，但不是说加了这两个约束的就是主键3.check(exp)，exp一般是条件表达式外键约束1.简介：添加外键的表被称为从表，被引用的表被称为主表2.添加外键：CREATE TABLE 表名( 字段名 字段类型, ..., [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主表列名));ALTER TABLE 从表名 ADD CONSTRAINT 外键名称（推荐命名格式：FK_从表名_从表字段名称） FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);3.删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名;删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;注意：1.no action 是MySQL外键的默认行为，no action 和restrict效果等同2.常用删除/更新行为有：RESTRICT和CASCADE" }, { "title": "MySQL", "url": "/posts/MySQL/", "categories": "数据库, MySQL", "tags": "", "date": "2022-06-18 00:00:00 +0800", "snippet": "基础篇通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限DDL（数据定义语言）数据定义语言数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名;注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名;创建表：CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ];最后一个字段后面没有逗号添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;删除字段：ALTER TABLE 表名 DROP 字段名;修改表名：ALTER TABLE 表名 RENAME TO 新表名删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名;DML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...);批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;删除数据：DELETE FROM 表名 [ WHERE 条件 ];DQL（数据查询语言）语法：SELECT 字段列表FROM 表名字段WHERE 条件列表GROUP BY 分组字段列表HAVING 分组后的条件列表ORDER BY 排序字段列表LIMIT 分页参数基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名;设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;去除重复记录：SELECT DISTINCT 字段列表 FROM 表名;转义：SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;/ 之后的_不作为通配符条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表;条件： 比较运算符 功能 &amp;gt; 大于 &amp;gt;= 大于等于 &amp;lt; 小于 &amp;lt;= 小于等于 = 等于 &amp;lt;&amp;gt; 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;amp;&amp;amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子：-- 年龄等于30select * from employee where age = 30;-- 年龄小于30select * from employee where age &amp;lt; 30;-- 小于等于select * from employee where age &amp;lt;= 30;-- 没有身份证select * from employee where idcard is null or idcard = &#39;&#39;;-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 不等于select * from employee where age != 30;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &amp;gt;= 20 and age &amp;lt;= 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &amp;lt; 30 and gender = &#39;女&#39;;-- 年龄等于25或30或35select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like &#39;__&#39;;-- 身份证最后为Xselect * from employee where idcard like &#39;%X&#39;;聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = &quot;广东省&quot;;分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。例子：-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）select count(*) from employee group by gender;-- 根据性别分组，统计男性和女性数量select gender, count(*) from employee group by gender;-- 根据性别分组，统计男性和女性的平均年龄select gender, avg(age) from employee group by gender;-- 年龄小于45，并根据工作地址分组select workaddress, count(*) from employee where age &amp;lt; 45 group by workaddress;-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress, count(*) address_count from employee where age &amp;lt; 45 group by workaddress having address_count &amp;gt;= 3;注意事项 执行顺序：where &amp;gt; 聚合函数 &amp;gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;排序方式： ASC: 升序（默认） DESC: 降序例子：-- 根据年龄升序排序SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;-- 两字段排序，根据年龄升序排序，入职时间降序排序SELECT * FROM employee ORDER BY age ASC, entrydate DESC;注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;例子：-- 查询第一页数据，展示10条SELECT * FROM employee LIMIT 0, 10;-- 查询第二页SELECT * FROM employee LIMIT 10, 10;注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10DQL执行顺序FROM -&amp;gt; WHERE -&amp;gt; GROUP BY -&amp;gt; SELECT -&amp;gt; ORDER BY -&amp;gt; LIMITDCL管理用户查询用户：USER mysql;SELECT * FROM user;创建用户:CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;修改用户密码：ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;例子：-- 创建用户test，只能在当前主机localhost访问create user &#39;test&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;-- 创建用户test，能在任意主机访问create user &#39;test&#39;@&#39;%&#39; identified by &#39;123456&#39;;create user &#39;test&#39; identified by &#39;123456&#39;;-- 修改密码alter user &#39;test&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;1234&#39;;-- 删除用户drop user &#39;test&#39;@&#39;localhost&#39;;注意事项 主机名可以使用 % 通配权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看权限一览表查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有函数 字符串函数 数值函数 日期函数 流程函数字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 使用示例：-- 拼接SELECT CONCAT(&#39;Hello&#39;, &#39;World&#39;);-- 小写SELECT LOWER(&#39;Hello&#39;);-- 大写SELECT UPPER(&#39;Hello&#39;);-- 左填充SELECT LPAD(&#39;01&#39;, 5, &#39;-&#39;);-- 右填充SELECT RPAD(&#39;01&#39;, 5, &#39;-&#39;);-- 去除空格SELECT TRIM(&#39; Hello World &#39;);-- 切片（起始索引为1）SELECT SUBSTRING(&#39;Hello World&#39;, 1, 5);数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子：-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子：select name, (case when age &amp;gt; 30 then &#39;中年&#39; else &#39;青年&#39; end)from employee;select name, (case workaddress when &#39;北京市&#39; then &#39;一线城市&#39; when &#39;上海市&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39;from employee;约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子：create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &amp;gt; 0 and age &amp;lt; 120), status char(1) default &#39;1&#39;, gender char(1));外键约束添加外键：CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名;删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;多表查询多表关系 一对多（多对一） 多对多 一对一一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id;内连接查询内连接查询的是两张表交集的部分隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;显式性能比隐式高例子：-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;例子：-- 左select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样-- 右select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept自连接查询当前表与自身的连接查询，自连接必须使用表别名语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;自连接查询，可以是内连接查询，也可以是外连接查询例子：-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id;联合查询 union, union all把多次查询的结果合并，形成一个新的查询集语法：SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ...注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列）根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &amp;lt; &amp;gt; &amp;gt; &amp;gt;= &amp;lt; &amp;lt;=例子：-- 查询销售部所有员工select id from dept where name = &#39;销售部&#39;;-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = &#39;销售部&#39;);-- 查询xxx入职之后的员工信息select * from employee where entrydate &amp;gt; (select entrydate from employee where name = &#39;xxx&#39;);列子查询返回的结果是一列（可以是多行）。常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子：-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;);-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &amp;gt; all(select salary from employee where dept = (select id from dept where name = &#39;财务部&#39;));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &amp;gt; any (select salary from employee where dept = (select id from dept where name = &#39;研发部&#39;));行子查询返回的结果是一行（可以是多列）。常用操作符：=, &amp;lt;, &amp;gt;, IN, NOT IN例子：-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#39;xxx&#39;);表子查询返回的结果是多行多列常用操作符：IN例子：-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = &#39;xxx1&#39; or name = &#39;xxx2&#39;);-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &amp;gt; &#39;2006-01-01&#39;) as e left join dept as d on e.dept = d.id;事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。基本操作：-- 1. 查询张三账户余额select * from account where name = &#39;张三&#39;;-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = &#39;张三&#39;;-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#39;李四&#39;;-- 查看事务提交方式SELECT @@AUTOCOMMIT;-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效SET @@AUTOCOMMIT = 0;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 设置手动提交后上面代码改为：select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;操作方式二：开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK;操作实例：start transaction;select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效进阶篇存储引擎MySQL体系结构：存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。相关操作：-- 查询建表语句show create table account;-- 建表时指定存储引擎CREATE TABLE 表名( ...) ENGINE=INNODB;-- 查看当前数据库支持的存储引擎show engines;InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间知识点：查看 Mysql 变量：show variables like &#39;innodb_file_per_table&#39;;从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibdInnoDB 逻辑存储结构：MyISAMMyISAM 是 MySQL 早期的默认存储引擎。特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。特点： 存放在内存中，速度快 hash索引（默认）文件： xxx.sdi: 存储表结构信息存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;例：show global status like &#39;Com_______&#39;慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log=1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log查看慢查询日志开关状态：show variables like &#39;slow_query_log&#39;;profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法： # 直接在select语句之前加上关键字 explain / desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。优缺点：优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B-Tree二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.htmlB+Tree结构图： 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html与 B-Tree 的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&amp;gt;、&amp;lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个   全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图：聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引思考题1. 以下 SQL 语句，哪个执行效率高？为什么？select * from user where id = 10;select * from user where name = &#39;Arm&#39;;-- 备注：id为主键，name字段创建的有索引答：第一条语句，因为第二条需要回表查询，相当于两个步骤。2. InnoDB 主键索引的 B+Tree 高度为多少？答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引查看索引：SHOW INDEX FROM table_name;删除索引：DROP INDEX index_name ON table_name;案例：-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引create index idx_user_name on tb_user(name);-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引create unique index idx_user_phone on tb_user (phone);-- 为profession, age, status创建联合索引create index idx_user_pro_age_stat on tb_user(profession, age, status);-- 为email建立合适的索引来提升查询效率create index idx_user_email on tb_user(email);-- 删除索引drop index idx_user_email on tb_user;使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。联合索引中，出现范围查询（&amp;lt;, &amp;gt;），范围查询右侧的列索引失效。可以用&amp;gt;=或者&amp;lt;=来规避索引失效问题。索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like &#39;%工程&#39;;，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。覆盖索引&amp;amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。explain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name=&#39;xxx&#39;;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name=&#39;xxx&#39;;所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username=&#39;itcast&#39;;解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式：select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user;show index 里面的sub_part可以看到接取的长度单列索引&amp;amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。单列索引情况：explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;这句只会用到phone索引字段注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询SQL 优化插入数据普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。# 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）mysql --local-infile -u root -p# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1;select @@local_infile;# 执行load指令将准备好的数据，加载到表结构中load data local infile &#39;/root/sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\\n&#39;;主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化例如：-- 此语句耗时很长select * from tb_sku limit 9000000, 10;-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询select id from tb_sku order by id limit 9000000, 10;-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用rediscount的几种用法： 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0各种用法的性能： count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加按效率排序：count(字段) &amp;lt; count(主键) &amp;lt; count(1) &amp;lt; count(*)，所以尽量使用 count(*)update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。如以下两条语句：update student set no = &#39;123&#39; where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = &#39;123&#39; where name = &#39;test&#39;;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引数据类型整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&amp;lt;=M&amp;lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&amp;lt; = M和 1&amp;lt;=M&amp;lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&amp;lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&amp;lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&amp;lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&amp;lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&amp;lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&amp;lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&amp;lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&amp;lt;2^32 权限一览表 具体权限的作用详见官方文档GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration 图形化界面工具 Workbench(免费): http://dev.mysql.com/downloads/workbench/ navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/ HeidiSQL(免费): http://www.heidisql.com/ phpMyAdmin(免费): https://www.phpmyadmin.net/ SQLyog: https://sqlyog.en.softonic.com/安装小技巧 在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式 查看Mysql数据库占用空间： SELECT table_schema &quot;Database Name&quot; , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;FROM information_schema.TABLESGROUP BY table_schema; " }, { "title": "Netty", "url": "/posts/Netty%E5%9F%BA%E7%A1%80/", "categories": "框架, Netty", "tags": "", "date": "2022-06-09 00:00:00 +0800", "snippet": "Netty注意点1.调用方法的线程与接收结果的线程是同一个就会引发阻塞，而如果是不同线程则意味着异步2.Netty的IO模型是基于多路复用的Netty相比NIO的优势Netty-demo1channel.pipeline()消息传递的类型是ByteBuf类型的，ch.writeAndFlush(byteBuf)Netty服务端和客户端的设计步骤1.半包粘包处理2.编码解码处理3.收发数据方式强大的ChannelGroup1.ChannelGroup可以作为一个群组，它本身是一个线程安全的Channel集合，所有的客户端Channel放入其中即可作为一个群组2.ChannelGroup内部的广播消息非常方便，调用channelGroup.write(byteBuf, charset)，即可向group内部所有客户端Channel发送广播消息3.群组的关闭也非常方便，即关闭ChannelGroup，通过channelGroup.close()，就能优先关闭serverChannel，当然前提是serverChannel也在group中" }, { "title": "props配置项", "url": "/posts/props%E9%85%8D%E7%BD%AE%E9%A1%B9/", "categories": "前端, Vue", "tags": "", "date": "2022-06-08 00:00:00 +0800", "snippet": "props配置功能：让组件接受外部传入的数据外部传入数据方式&amp;lt;User :getUserName=&#39;getUserName&#39; name=&#39;我是爸爸&#39; age=&#39;50&#39;&amp;gt;&amp;lt;/User&amp;gt;在注册组件实例的同时，自定义属性传入数据，上面就传入了getUserName方法，name和age组件接受数据1.第一种方式（普通）export default { props:[&#39;getUserName&#39;,&#39;name&#39;,&#39;age&#39;],};像上面这样仅仅是用props声明接收2.第二种方式（限制类型）&amp;lt;script&amp;gt;export default { props:{ getUserName:Function, name:String, age:Number }};这里需要注意一点，age被限制类型为数值型，那么如下传入数值型数据呢？&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;User :age=&#39;50&#39;&amp;gt;&amp;lt;/User&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;用v-bind指令绑定age，这样age值就被当作表达式进行解析了3.第三种方式（限制类型、限制必要性、指定默认值）&amp;lt;script&amp;gt;export default { name: &quot;User&quot;, props:{ getUserName:{ type:Function }, name:{ type:String, required:true, }, age:{ type:Number, default:50 } },};&amp;lt;/script&amp;gt;必要性限制和指定默认值一般不会同时出现，毕竟限制了必要性就没必要指定默认值了props注意项1.props是只读的，Vue底层会监测你对props的修改，如果修改了就会发出警告，若业务需求确实需要修改，请复制props的内容到data中一份，然后去修改data中的数据当你尝试修改props数据：&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt;方法名：&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;姓名：&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;年龄：&amp;lt;/div&amp;gt; &amp;lt;button @click=&quot;updateAge&quot;&amp;gt;props属性age+1&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;User&quot;, props:{ getUserName:{ type:Function }, name:{ type:String, required:true, }, age:{ type:Number, default:50 } }, methods:{ updateAge(){ this.age++ } }};&amp;lt;/script&amp;gt;在方法updateAge尝试修改props中的age属性，结果报如下警告：Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop&#39;s value.意思是如果父组件被重新渲染，props中的属性会被覆盖，并且推荐我们使用computed和data处理props值，像下面这样使用data：// 展示的时候就不是age了，而是fatherAge&amp;lt;div&amp;gt;年龄：&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;export default { data(){ return{ // 将props值赋值给data fatherAge:this.age } }, methods:{ updateAge(){ // 方法修改的不是age，而是fatherAge this.fatherAge++ } }}&amp;lt;/script&amp;gt;从这种方式来看props属性值被初始化的优先级要大于data和computed2.如果父组件传入的props值动态改变，子组件中也会改变&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;User :age=&#39;age&#39;&amp;gt;&amp;lt;/User&amp;gt; &amp;lt;div&amp;gt;父组件中age的值&amp;lt;/div&amp;gt; &amp;lt;button @click=&quot;updateAge&quot;&amp;gt;age值++&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import User from &#39;./views/User.vue&#39;;export default { name: &quot;App&quot;, components: { User }, data(){ return { age:50 } }, methods:{ updateAge(){ this.age++ } }};&amp;lt;/script&amp;gt;设计案例如上：自定义属性传入数据对象age，并且父组件中通过方法updateAge动态改变数据对象age的值，子组件如下：&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt;年龄：&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;User&quot;, props:{ age:{ type:Number, } },};&amp;lt;/script&amp;gt;子组件直接展示props接收到的外部数据age，经过测试每当父组件中的age动态改变，这边子组件中的props传入值也会动态改变" }, { "title": "IDEA快捷键汇总", "url": "/posts/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/", "categories": "工具, IDEA", "tags": "", "date": "2022-06-08 00:00:00 +0800", "snippet": "" }, { "title": "NIO基础", "url": "/posts/NIO%E5%9F%BA%E7%A1%80/", "categories": "框架, Netty", "tags": "", "date": "2022-06-07 00:00:00 +0800", "snippet": "NIO三大组件Channel和BufferChannel是读写数据的双向通道，可以从Channel将数据读入Buffer，也可以将Buffer的数据写入Channel，而Java中的Stream，如InputStream、OutputStream要么输入，要么输出，Channel比Stream更加底层常见的Channel FileChannel DatagramChannel，UDP式的数据传输通道 SocketChannel，TCP式的，可用于服务端和客户端 ServerSocketChannel，TCP式的，专用于服务端常见的Buffer ByteBuffer，以字节为单位存储数据的Buffer，是抽象类，下面是实现类 MappedByteBuffer DirectByteBuffer HeapByteBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer CharBufferSelector多线程设计服务器需求：每个服务器可能同时需要处理来自多个客户端的请求，这就需要使用多线程处理：每个客户端与服务端的连接开一个线程处理数据传输，如下图所示存在的问题：1.CPU能同时开启的线程数是有限的，如16核CPU最多开启16个线程，也就是能够同时处理的连接也就16个，如果有新的连接就会被阻塞2.每个线程会占用一定的内存（记忆状态，名词变量等等），线程一多内存占用就会很高3.线程上下文切换成本高，一旦线程被换下，它的状态是需要被记住的，以便下次处理该线程的时候继续上次的进度，因此这样会有许多线程的状态需要被记住这种多线程设计只适合少连接的情况线程池设计服务器需求：多线程版本线程数量不受管束，容易超出内存处理：线程池限制最高线程数，由于最高线程数被限制，那么一旦连接数过多，每个线程就要处理多条连接，但是同一时刻线程只能处理一条连接，其他连接会被阻塞，线程池的工作模式如下：缺点：1.不管正在被处理的连接干不干事，线程都会被占用，其他线程只能等待，这个模式被称为阻塞模式，也就是每个线程仅能处理一个socket连接2.仅适合短链接，http请求下服务端返回响应，连接就可以被断开了，当下线程便可继续处理其他线程，这被称为短链接，非常适合线程池模式总结：线程池模式下，线程利用率不高Selector设计服务器需求：如果连接不进行任何读写事件，就不占用线程，线程可以处理其他发出读写事件的连接注意:在Selector中，Channel就相当于一次Socket连接处理：Selector负责监听所有连接，一旦有连接发出读写事件，就通知Thread进行处理，如果有多个线程同时发出读写事件，就轮流处理；模式图如下：适用多连接和流量低的场景，如果一次连接的流量过高，比如某个连接需要处理大量的数据，这样就要耗费大量的时间，在轮流处理模式下其他连接其实就相当与被阻塞了，甚至可能永远不会被处理到，比如在当前连接处理当中，有新增了需要处理的连接，这样等待处理的连接队伍就会越来越长；之所以适合多连接是因为Selector模式就是为了在多连接下提高线程的利用率ByteBuffer的基本使用读取本地文件，并在控制台打印内容import java.io.FileInputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class Demo { public static void main(String[] args) { // 1.文件输入流获取FileChannel 或 2.RandomAccessFile获取 try (FileChannel fileChannel = new FileInputStream(&quot;E:\\\\Netty\\\\NIO-demo1\\\\src\\\\main\\\\resources\\\\file1.txt&quot;).getChannel()) { // 准备ByteBuffer缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(10); while (true) { // Channel数据写入ByteBuffer int count = fileChannel.read(byteBuffer); if (count &amp;lt; 0) { break; } // 开启读模式 byteBuffer.flip(); // 打印数据 while (byteBuffer.hasRemaining()) { byte b = byteBuffer.get(); System.out.println((char) b); } // 切换写模式 byteBuffer.clear(); } } catch (IOException e) { } }}ByteBuffer正确使用姿势1.文件输入流获取Channel2.准备ByteBuffer缓冲区，Channel数据写入缓冲区（ByteBuffer刚创建默认为写模式）3.ByteBuffer开启读模式，byteBuffer.flip()4.byteBuffer读出数据，如byteBuffer.get()5.如果要继续写入byteBuffer，请开启写模式，byteBuffer.clear()，或byteBuffer.compact()ByteBuffer内部结构" }, { "title": "MyBatis整合与逆向工程", "url": "/posts/MyBatis%E6%95%B4%E5%90%88%E4%B8%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/", "categories": "框架, MyBatis", "tags": "", "date": "2022-06-06 00:00:00 +0800", "snippet": "MyBatis基本的使用方法1.新建Maven工程2.导入MyBatis依赖 &amp;lt;dependencies&amp;gt; &amp;lt;!-- Junit测试框架，用作方法测试 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MyBatis核心依赖，就这一个 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MySQL数据库驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;3.MyBatis全局配置文件&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;!-- 引入外部配置文件之后，就可以通过${}引入属性了 --&amp;gt; &amp;lt;properties resource=&quot;jdbc.properties&quot;/&amp;gt; &amp;lt;!-- 配置环境为开发环境，当然还包括测试，生产 --&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;!-- 事务管理器，使用了 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务范围 --&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;!-- 数据源，POOLED标识带数据源的，会使用MyBatis默认的数据连接池，UNPOOLED就是不带的，尽量带数据源，因为JDBC事务提交依赖连接保证事务的原子性 --&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;org/mybatis/example/UserMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt;&amp;lt;/configuration&amp;gt;4.jdbc.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8jdbc.username=rootjdbc.password=ww27115547705.创建UserMapper.xml和UserMapper接口&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;&amp;lt;mapper namespace=&quot;org.flameking.mybatis.mapper.UserMapper&quot;&amp;gt; &amp;lt;!--int insertUser();--&amp;gt; &amp;lt;insert id=&quot;insertUser&quot;&amp;gt; insert into employee values(null,&#39;张三&#39;,18,0) &amp;lt;/insert&amp;gt;&amp;lt;/mapper&amp;gt;public interface UserMapper { int insertUser();}6.测试文件public class UserMapperTest { @Test public void insertUser() throws IOException { // Resource时MyBatis提供的外部配置文件加载类 InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); // SqlSession sqlSession = sqlSessionFactory.openSession(); 此时通过sqlSession对象操作的sql需要手动提交或回滚事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); // 创建动态代理的mapper对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); int count = mapper.insertUser(); System.out.println(&quot;count:&quot;+count); }}MyBatis整合第三方数据源连接池Spring整合MyBatisSpringBoot整合MyBatis" }, { "title": "函数", "url": "/posts/%E5%87%BD%E6%95%B0/", "categories": "数据库, MySQL", "tags": "", "date": "2022-06-05 00:00:00 +0800", "snippet": "函数有下面两种场景：1.数据库表中，存储的是入职日期，如2000-11-12，如何快速计算入职天数？2.数据库表中，存储的是学生的分数值，如98，75，如何快速判定分数的等级呢？其实这些场景都需要用到函数，MySQL数据库中函数是其内置的一段程序代码，函数可以再另一段程序中调用字符串函数注意：1.SubString函数截取子字符串的起始索引从1开始2.trim函数只会消除字符串两边的空格，注意是空格不是所有的空字符串补充：1.length(str)：求str的长度2.left(str, 5)：截取str左边长度为5的子字符串3.right(str, 6)：截取str右边长度为6的子字符串4.group_concat([distinct] 字段A [order by 字段A] separator ‘;’)：连接经过排序后的字段A的所有值，并用’;’分隔，默认使用逗号分隔并按升序排序值，常用搭配group by使用，用于连接组内各值5.substring_index(str, delimiter, n)：如果n&amp;gt;0，获取左 –&amp;gt; 右第n个分隔符左边的所有字符，不包含该分隔符，如果n&amp;lt;0，获取右 –&amp;gt; 左第n个分隔符右边的所有字符，不包含该分隔符数值函数常见的数值函数：案例：随机生成6位的验证码select lpad(round(rand()*1000000), 6, 0);select lpad(substring(rand(),3,6),6,0);注意：Mod(x,y)就是求x/y的余数日期函数常见的日期函数：date_add演示：当前日期往后推70天：date_add(now(),interval 70 day);，其中interval是固定写法案例：查询员工的入职天数，并倒序排序select name, datediff(curdate(), entrydate) as &#39;entrydays&#39; from emp order by entrydays desc;注意：1.datediff()会有日期格式检查，如果日期格式不正确会返回null2.datediff的值是由前一个参数减后一个参数得到的，并且返回的是day类型，虽然参数可以是datetime类型的，但time部分不会参与计算流程函数流程函数可以用于按条件筛选，常见流程函数：案例1：查询emp表的员工姓名和工作地址（北京/上海 —-&amp;gt; 显示一线城市，其他 —-&amp;gt; 二线城市）select name, (case workaddress when &#39;北京&#39; then &#39;一线城市&#39; when &#39;上海&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39; from emp;这个查询很像switch案例2：统计班级各个学员的成绩，展示的规则如下：1.&amp;gt;=85，展示优秀2.&amp;gt;=60，展示及格3.否则展示不及格select id, name, (case when math &amp;gt;= 85 then &#39;优秀&#39; when math &amp;gt;= 65 then &#39;及格&#39; else &#39;不及格&#39; end) as &#39;数学&#39;, (case when english &amp;gt;= 85 then &#39;优秀&#39; when english &amp;gt;= 65 then &#39;及格&#39; else &#39;不及格&#39; end) as &#39;英语&#39;, (case when chinese &amp;gt;= 85 then &#39;优秀&#39; when chinese &amp;gt;= 65 then &#39;及格&#39; else &#39;不及格&#39; end) as &#39;英语&#39;from score;这个查询很像if/else if：总结：两种case语句都是对字段值进行筛选并返回对应的值，所以case语句通常是有效的可以select" }, { "title": "组件之间通信", "url": "/posts/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/", "categories": "前端, Vue", "tags": "", "date": "2022-06-04 00:00:00 +0800", "snippet": "父组件向子组件传值通过props配置向子组件传值1.在父组件App注册子组件User时通过自定义属性值传值&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;User :getUserName=&#39;getUserName&#39; name=&#39;我是爸爸&#39; age=&#39;50&#39;&amp;gt;&amp;lt;/User&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;2.子组件User中用props接受属性，该属性会被直接赋予给User组件实例，这样就可以像使用数据对象的方法一样直接使用了&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt;方法名：&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;姓名：&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;年龄：&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;User&quot;, props:[&#39;getUserName&#39;,&#39;name&#39;,&#39;age&#39;],};&amp;lt;/script&amp;gt;子组件向父组件传值子组件props接收函数子组件props接收父组件的传入函数，函数在子组件中被调用，作用域却在父组件，因而子组件在函数中传入的函数就能在父组件接收，如下：&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; // 将函数传递给子组件 &amp;lt;User :getUserName=&quot;getUserName&quot;&amp;gt;&amp;lt;/User&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import User from &quot;./views/User.vue&quot;;export default { name: &quot;App&quot;, components: { User, }, methods: { // 父类的方法，作为媒介接收来自子组件的值 getUserName(username){ console.log(&#39;获取到用户名：&#39;+username) } },};&amp;lt;/script&amp;gt;子组件接收函数，并将值通过参数传递给父组件&amp;lt;template&amp;gt; &amp;lt;div class=&quot;user&quot;&amp;gt; &amp;lt;div&amp;gt;用户姓名：&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;User&quot;, // 接收函数 props:[&#39;getUserName&#39;], data() { return { name: &#39;flameking&#39;, }; }, mounted(){ // 传入name this.getUserName(this.name) }};&amp;lt;/script&amp;gt;自定义事件（一）第一种定义方式，在标签当中定义1.首先定义我们的事件和事件被触发的回调函数&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; // 自定义我们的事件名 // 加上事件修饰符：once，表示事件至多触发一次 &amp;lt;Home @testevent.once=&quot;getFamilyAddress&quot;&amp;gt;&amp;lt;/Home&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import Home from &quot;./views/Home.vue&quot;;export default { name: &quot;App&quot;, components: { Home }, methods: { // 定义回调函数，接收一个参数，address getFamilyAddress(address){ console.log(&#39;家庭住址：&#39;+address) } },};2.事件被注册在子组件Home当中，自然就需要在Home当中触发&amp;lt;script&amp;gt;export default { name: &quot;Home&quot;, data() { return { address: &quot;湖南 衡阳&quot;, }; }, // 触发事件testevent，并传入参数address mounted() { this.$emit(&quot;testevent&quot;, this.address); console.log(this); },};&amp;lt;/script&amp;gt;（二）第二种定义方式，直接获取组件实例，并注册事件1.我们知道事件是被绑定在子组件实例中，第一种定义方式是在标签当中定义事件并与组件一同注册，现在我们优先获取子组件实例，然后注册事件&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; // ref配置获取当前组件实例 &amp;lt;Home ref=&quot;home&quot;/&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import Home from &quot;./views/Home.vue&quot;;export default { name: &quot;App&quot;, components: { Home, }, methods: { getFamilyAddress(address,x,y,z) { console.log(&quot;家庭住址：&quot;,address,x,y,z); }, // 接收多个参数，出为首一个参数，其余参数放在a数组中 // getFamilyAddress(address,...a) { // console.log(&quot;家庭住址：&quot;,address,a); // }, }, // 当父组件挂载完成后注册事件testevent，以及事件的回调函数getFamilyAddress mounted() { this.$refs.home.$on(&#39;testevent&#39;,this.getFamilyAddress) // 事件至多被触发一次 // this.$refs.home.$once(&#39;testevent&#39;,this.getFamilyAddress) },};&amp;lt;/script&amp;gt;2.子组件如原来方式触发事件，不过有一点需要注意：由于事件是在父组件App被挂载往后才注册的，如果在子组件挂载完后里面触发事件不会有效因为App在所有子组件挂载完成后完成挂载，也就是说子组件内mounted触发的事件压根还未注册&amp;lt;template&amp;gt; &amp;lt;div class=&quot;family&quot;&amp;gt; &amp;lt;div&amp;gt;家庭住址：&amp;lt;/div&amp;gt; // 在经过一次点击事件后触发testevent事件 &amp;lt;button @click=&quot;sendFamilyAddress&quot;&amp;gt;send&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;Home&quot;, components: {}, data() { return { address: &quot;湖南 衡阳&quot;, }; }, methods: { // 在sendFamilyAddress方法内触发testevent事件，并传入参数多个参数 sendFamilyAddress(){ this.$emit(&quot;testevent&quot;, this.address,&#39;中国&#39;,&#39;湖南&#39;,&#39;衡阳&#39;); console.log(this); } }, mounted() { },};&amp;lt;/script&amp;gt;这种方式下比第一种更加灵活，主要体现在注册事件的时候，例如让事件在App组件挂载完成后3秒后完成注册 mounted() { setTimeout(() =&amp;gt; { this.$refs.home.$on(&#39;testevent&#39;,this.getFamilyAddress) },3000) },解绑自定义事件如果自定义事件需要解绑，那么也需要在通过事件的组件实例进行解绑，解绑总共三种方法: this.$off(‘getUserAge’)，解绑一个事件 this.$off([‘getUserName’,’getUserAge’])，解绑多个事件 this.$off()，解绑当前组件的所有事件自定义事件需要注意的点1.如果销毁当前组件实例，由于实例被销毁，绑定在它身上的所有自定义事件无效，响应式无法再起作用，即页面不会随着数据的修改而动态更新**destroyComponent(){ this.$destroy()}2.回调函数里面的this指向如果自定义事件的回调函数我们不卸载methods中，而是直接以匿名函数的形式作为参数传入:mounted() { this.$refs.home.$on(&quot;testevent&quot;, function (address, ...a) { console.log(&quot;家庭住址：&quot;, address, a); // 此时的this不是父组件实例对象而是子组件实例对象 console.log(this) }); this.$refs.user.$on(&quot;getUserAge&quot;, this.getUserAge);}如何获取到父组件的实例对象呢？ 使用箭头函数的形式 再函数外使用变量保存父组件的实例对象，延长作用域 或直接使用原来的形式3.给组件绑定原生事件给组件绑定原生事件有两种形式：第一种：&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;div&amp;gt;我是父组件&amp;lt;/div&amp;gt; &amp;lt;Home @click=&quot;callNative&quot; ref=&quot;home&quot; /&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import Home from &quot;./views/Home.vue&quot;;export default { name: &quot;App&quot;, components: { Home, }, methods: { callNative(){ console.log(&#39;绑定原生事件&#39;) } },};&amp;lt;/script&amp;gt;像这种Vue会把click作为自定义事件进行处理第二种：&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;div&amp;gt;我是父组件&amp;lt;/div&amp;gt; // 通过native事件修饰符就可以调用到原生事件 &amp;lt;Home @click.native=&quot;callNative&quot; ref=&quot;home&quot; /&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import Home from &quot;./views/Home.vue&quot;;export default { name: &quot;App&quot;, components: { Home, }, methods: { callNative(){ console.log(&#39;绑定原生事件&#39;) } },};&amp;lt;/script&amp;gt;注意：native事件修饰符只能用在组件当中，并且事件被绑定再了组件的root元素上兄弟组件互相通信全局事件总线全局事件总线与自定义事件模型对比图全局事件总线将有vm担任" }, { "title": "路由的相关规则", "url": "/posts/%E8%B7%AF%E7%94%B1%E7%9A%84%E7%9B%B8%E5%85%B3%E8%A7%84%E5%88%99/", "categories": "前端, Vue", "tags": "", "date": "2022-06-01 00:00:00 +0800", "snippet": "嵌套路由的使用方式配置路由规则index.js/** * 嵌套路由 */export default new VueRouter({ mode: &quot;history&quot;, routes: [ { path: &#39;/home&#39;, name: &#39;Home&#39;, component: Home, // 父路由下的children配置中继续指定新的子路由规则 children: [ { // 子路由不许带&#39;/&#39;，因为底层自动加上了 path: &#39;child&#39;, name: &#39;HomeChild&#39;, component: HomeChild, } ] }, { path: &#39;/user&#39;, name: &#39;User&#39;, component: User, children:[ { name:&#39;UserChild&#39;, path:&#39;child&#39;, component: UserChild } ] } ]})如何配置子路由：父路由下的children配置中继续指定新的子路由规则，新的路由规则与父路由配置方式相同，具有的属性也相同，因此按照理论可以无限嵌套，不过实际开发不会嵌套超过5，6层。需要注意的地方：1.子路由不许带’/’，因为底层自动加上了2.router-link中必须是完整路径，如渲染HomeChild应该是/home/child，而不是/childrouter-link与router-view如何匹配当我们使用嵌套路由时，必定会增加一套新的router-link与router-view，那么不同的router-link是如何匹配到响应正确位置上的router-view呢？ 观察路由规则的path属性，Home路由的path是/home，而它的子路由是/home/child，从这点看其实子路由是归属夫路由的，相对而言路由中的组件也是相互归属的，即HomeChild应该被渲染在Home组件中，而且/是根路径，而根路径对应的组件其实是App.vue，所以User和Home组件都应该渲染在App组件，这也是为什么User和Home组件的router-view在App.vue的原因简单的来说：子组件应当在父组件中渲染路由传参路由传参存在的意义是什么：能够提高组件的复用率 简单来说，有很多个组件内容大部分相同，可以将小部分的提取出来作为动态的部分，也就是通过外部传参的形式传入参数，并由组件接收，虽然说相同的部分也可以抽取出来作为一个组件，但既然一个文件能做到的事为什么要用两个文件呢？毕竟后者可能导致组件爆炸传参的流程图：传递参数的两种方法1.to的字符串传参写法&amp;lt;!-- to的字符串传参法1 --&amp;gt;&amp;lt;router-link to=&quot;/home/child?title=HomeChild&quot;&amp;gt; &amp;lt;el-button&amp;gt; HomeChild &amp;lt;/el-button&amp;gt;&amp;lt;/router-link&amp;gt;&amp;lt;!-- to的字符串传参法2如果需要使用数据对象：1.首先v-bind绑定to属性，2.url放在模板字符串``中，因为被绑定的属性会作为js来解析，而在模板字符串中能够解析${}语法 --&amp;gt;&amp;lt;router-link :to=&quot;`/user/child?title=${title}&amp;amp;poem=${poem}`&quot;&amp;gt; &amp;lt;el-button&amp;gt; UserChild &amp;lt;/el-button&amp;gt;&amp;lt;/router-link&amp;gt;2.to的对象传参写法&amp;lt;!-- to的对象传参法 --&amp;gt;&amp;lt;router-link :to=&quot;{ path:&#39;/home/child&#39;, query:{ // 可以直接引用数据对象中的值 title:this.title }}&quot;&amp;gt; &amp;lt;el-button&amp;gt; HomeChild &amp;lt;/el-button&amp;gt;&amp;lt;/router-link&amp;gt;接收参数// 如果是params传参的话，query改成params就行this.$route.query.XXX// 如在插值表达式中使用就是像下面这样params参数相比与query传参，params传参有诸多限制：1.在注册路由规则时，需要实现使用占位符声明接收参数2.如果使用to的对象传参法，必须使用name，而不是path像下图所示：另外：相比query传参，params传参，参数列表不会显示在浏览器的链接栏，所以其实query传参对应get传参，params传参对应post传参命名路由即给路由规则用name属性命名，经过命名的组件在使用to的对象传参法时就可以使用name，而不是path，这样能够简化路径的编写，毕竟如果嵌套了多层路由，path可能会很长路由的props配置从上图可见props配置是为了组件能够更好的接收参数，同时props是路由规则配置中的一个属性props配置的三种方式1.第一种，props值为对象，该对象中的所有key-value组合最终会通过组件中的props配置传给组件index.js中路由规则配置props属性{ path: &#39;/home&#39;, name: &#39;Home&#39;, component: Home, children: [ { // 子路由不许带&#39;/&#39;，因为底层自动加上了 path: &#39;child&#39;, name: &#39;HomeChild&#39;, component: Child, // props值为对象 props:{ title:&#39;中华小当家&#39; } } ]}Child.vue组件中通过props属性接收title参数&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; // 使用title参数 &amp;lt;li v-for=&quot;(item, index) in menu&quot; :key=&quot;index&quot;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;Child&quot;, // 组件中用props接收参数 props:[&#39;title&#39;], mounted(){ console.log(this.$route); },};&amp;lt;/script&amp;gt;这种方法下，props里面的值被写死，并没有延续路由传值的优点2.第二种，props值为布尔，把路由收到的params参数通过组件中的props配置传递给组件（这种方法对query参数无效）index.js中的路由配置{ path: &#39;/home&#39;, name: &#39;Home&#39;, component: Home, children: [ { // 子路由不许带&#39;/&#39;，因为底层自动加上了 path: &#39;child&#39;, name: &#39;HomeChild&#39;, component: Child, // props值为布尔 props:true } ]}router-link的params传参&amp;lt;router-link :to=&quot;{ name:&#39;HomeChild&#39;, params:{ // 可以直接引用数据对象中的值 title:this.title }}&quot;&amp;gt; &amp;lt;el-button&amp;gt; HomeChild &amp;lt;/el-button&amp;gt;&amp;lt;/router-link&amp;gt;组件中通过props配置接收参数&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for=&quot;(item, index) in menu&quot; :key=&quot;index&quot;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;Child&quot;, // 组件中用props接收参数 props:[&#39;title&#39;],}这种方法下必须与to的params对象传参绑定，因为不支持query传参，不过也是一个好方法3.第三种，props值为函数，该函数返回的对象中的每一组key-value组合都会通过组件中的props配置传递给组件index.js中的路由配置{ path: &#39;/home&#39;, name: &#39;Home&#39;, component: Home, children: [ { // 子路由不许带&#39;/&#39;，因为底层自动加上了 path: &#39;child&#39;, name: &#39;HomeChild&#39;, component: Child, // props值为函数 props($route){ console.log(&#39;路由规则中的$route:&#39;+$route); return { // 接收路由收到的params参数，当然如果是query传参，下面写的就是query // title:$route.query.title title:$route.params.title } } } ]}router-link的params传参&amp;lt;!-- to的对象传参法 --&amp;gt;&amp;lt;router-link :to=&quot;{ name:&#39;HomeChild&#39;, params:{ // 可以直接引用数据对象中的值 title:this.title }}&quot;&amp;gt; &amp;lt;el-button&amp;gt; HomeChild &amp;lt;/el-button&amp;gt;&amp;lt;/router-link&amp;gt;Child.vue组件中用props接收参数&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for=&quot;(item, index) in menu&quot; :key=&quot;index&quot;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &quot;Child&quot;, // 组件中用props接收参数 props:[&#39;title&#39;],}解构赋值，使用解构赋值，路由规则里的props配置可以写的更加简洁// 1.解构赋值props({params}){ console.log(&#39;路由规则中的$route:&#39;+$route); return { title:params.title }}// 2.解构赋值的连续写法props({params:{title}}){ console.log(&#39;路由规则中的$route:&#39;+$route); return { title }}props配置的传参流程大致如下：router-link的replace属性这个功能其实有点像后端的重定向和转发，可以用来做登录注册那部分的内容编程式路由导航函数式路由导航与router-link的区别：router-link本质是通过a标签实现路由的跳转，而函数式路由导航则通过固定的函数如push和replace等函数直接将链接推入历史记录栈中总的来说两者只在传入参数不同，而组件接收参数时用的是用一套规则函数式路由导航的实现方式某个组件中定义导航&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;!-- 编程式路由导航 --&amp;gt; &amp;lt;el-button @click=&quot;pushShow&quot;&amp;gt; HomeChild &amp;lt;/el-button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default { name: &quot;App&quot;, data(){ return { title:&#39;时间煮酒&#39;, poem:&#39;jinyesi&#39; } }, methods:{ pushShow(){ console.log(&#39;函数式编程&#39;) var that = this; // 配置参数，与to的对象式传参相同，函数都存在this.router中 this.$router.replace({ name:&#39;HomeChild&#39;, params:{ title:that.title } }) } } };&amp;lt;/script&amp;gt;" }, { "title": "搭建ui容器框架", "url": "/posts/%E6%90%AD%E5%BB%BAui%E5%AE%B9%E5%99%A8%E6%A1%86%E6%9E%B6/", "categories": "项目, Vue通用后台管理系统", "tags": "", "date": "2022-05-28 00:00:00 +0800", "snippet": "" }, { "title": "vue-cli脚手架文件结构分析", "url": "/posts/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/", "categories": "前端, Vue", "tags": "", "date": "2022-05-28 00:00:00 +0800", "snippet": "脚手架目录结构main.js// 1.引入Vue，但是vue.runtime.xxx.js，相比完整版vue.js，它有vue核心但没有模板解析器，也就是无法解析template属性里面的东西import Vue from &#39;vue&#39;// 2.引入App组件import App from &#39;./App.vue&#39;// 3.关闭Vue生产提示Vue.config.productionTip = false// 4.创建vm实例new Vue({ // 5-1.因为不可以使用template配置项，所以要用render函数接收到的createElement函数去渲染App组件 render: h =&amp;gt; h(App), // 6.挂载容器}).$mount(&#39;#app&#39;)App.vue&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&amp;gt; // 1.实例化HelloWorld组件 &amp;lt;HelloWorld/&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;// 2.引入组件定义import HelloWorld from &quot;./components/HelloWorld.vue&quot;;export default { name: &quot;App&quot;, // 3.注册组件 components: { HelloWorld, },};&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&amp;lt;/style&amp;gt;public下的index.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;!-- 1.针对IE浏览器的特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt; &amp;lt;!-- 2.开启移动端的理想视口 --&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&amp;gt; &amp;lt;!-- 3.配置页签图标 --&amp;gt; &amp;lt;link rel=&quot;icon&quot; href=&quot;&amp;lt;%= BASE_URL %&amp;gt;favicon.ico&quot;&amp;gt; &amp;lt;!-- 4.配置网页标题 --&amp;gt; &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- 5.如果浏览器不支持JavaScript，将会显示下面的句子 --&amp;gt; &amp;lt;noscript&amp;gt; &amp;lt;strong&amp;gt;We&#39;re sorry but &amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&amp;lt;/strong&amp;gt; &amp;lt;/noscript&amp;gt; &amp;lt;!-- 6.最终被管理的容器 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- built files will be auto injected --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;1.&amp;lt;%= BASE_URL %&amp;gt;是Vue底层做的一个路径转换的配置，其实就是项目根目录，比如http://localhost:8080/2.&amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;最终指向package-lock.json文件开头的name属性，也就是项目名称" }, { "title": "Vue组件化编程", "url": "/posts/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/", "categories": "前端, Vue", "tags": "", "date": "2022-05-28 00:00:00 +0800", "snippet": "什么是组件实现应用中局部功能代码和资源的集合组件化编程的好处 依赖关系更加清晰 代码复用率更高（不仅仅是js和css，html结构也被复用了）非单文件组件和单文件组件什么是非单文件组件和单文件组件，看下图：简而言之，非单文件组件是一个html文件，里面使用到多个组件，单文件组件是一个vue文件，本身代表一个组件非单文件组件的使用&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;非单文件组件&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;./js/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; /* 中间如果不加&#39;，&#39;，表示的是后代元素，加了才表示两个没有关系的class */ .mytitle, .text { font-size: 50px; } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;!-- 3.使用组件 --&amp;gt; &amp;lt;list&amp;gt;&amp;lt;/list&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;script&amp;gt; // 1.定义组件 const myList = Vue.extend({ // el:&#39;#app&#39;，不需要挂载容器，毕竟组件作为复用对象是要被用在不同的地方，而且它是由Vue实例进行统一管理的 // 1-1.组件结构，template结构必须有一个root element，即整个template需要用容器包裹，这个容器可以是任意的 template: ` &amp;lt;div&amp;gt; &amp;lt;p class=&#39;mytitle&#39; v-text=&#39;title&#39;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li class=&#39;text&#39; v-for=&#39;food in foods&#39;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; `, // 1-2.数据对象必须用函数式，因为函数式每次返回不同的对象，那么就不存在改了值大家都变了的结果 data() { return { title: &#39;食谱&#39;, foods: [&#39;青椒炒肉&#39;, &#39;水煮鱼片&#39;, &#39;宫保鸡丁&#39;] } } }); // 2.注册组件 new Vue({ components: { // 左边的组件名中间不能有大写字母，如果左右名称相同，就可以省略冒号和右边 list: myList }, }).$mount(&#39;#app&#39;);&amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;非单文件组件使用流程非单文件组件需要注意的点组件嵌套与标准化开发&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;非单文件组件&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;./js/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&amp;gt; &amp;lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- 2-1.最终在html结构中，我们不需要写任何代码，这样非常的清晰 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;script&amp;gt; // 1.定义组件 const list = Vue.extend({ // 1-1.列表组件 template: ` &amp;lt;div&amp;gt; &amp;lt;p class=&#39;mytitle&#39; v-text=&#39;title&#39;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li class=&#39;text&#39; v-for=&#39;food in foods&#39;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; `, data() { return { title: &#39;食谱&#39;, foods: [&#39;青椒炒肉&#39;, &#39;水煮鱼片&#39;, &#39;宫保鸡丁&#39;] } } }); const mybutton = { // 1-2.按钮组件 template: ` &amp;lt;Button type=&quot;submit&quot;&amp;gt;提交&amp;lt;/Button&amp;gt; ` } const myinput = { // 1-3.输入框组件 template: ` &amp;lt;input type=&#39;text&#39; value=&#39;请输入值&#39; /&amp;gt; ` } const app = { // 1-4.母组件 template: ` &amp;lt;div&amp;gt; &amp;lt;mylist&amp;gt;&amp;lt;/mylist&amp;gt; &amp;lt;myinput&amp;gt;&amp;lt;/myinput&amp;gt;&amp;lt;br&amp;gt; &amp;lt;mybutton&amp;gt;&amp;lt;/mybutton&amp;gt; &amp;lt;/div&amp;gt; `, // 1-5.app统一管理子组件 components:{ mybutton, myinput, mylist:list } } // 2.注册组件 new Vue({ template: ` &amp;lt;app&amp;gt;&amp;lt;/app&amp;gt; `, // vm管理母组件 components: { app }, }).$mount(&#39;#app&#39;);&amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;像下面的这种结构：我们称其为标准化开发VueComponent构造函数深入理解组件一个重要的内置关系在javascript中存在一种被称作原型链的关系，其中实例对象的属性__proto__会指向它的上级，它对应的构造函数的属性prototype也会指向实例对象的上级而在Vue中，有这样一个重要的内置关系：VueComponenet.prototype.__proto__ == Vue.prototype，而这个关系的存在使得组件实例对象（vc）可以访问到Vue原型上的属性和方法单文件组件单文件组件以.vue结尾，最终会被编译成.js，单文件的基本组成结构&amp;lt;template&amp;gt; // 组件的结构，template最终会被消掉，留下里面的东西&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; // 相关的资源和交互逻辑代码&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt; // 样式&amp;lt;/style&amp;gt;非单文件组件与单文件组件相比他不能为每个组件分组独立的css，这是它的缺陷，也是单文件组件的优点单文件组件示例List.vue&amp;lt;template&amp;gt; // 1.注意外面一定要用root元素包裹 &amp;lt;div&amp;gt; &amp;lt;p class=&#39;mytitle&#39; v-text=&#39;title&#39;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li class=&#39;text&#39; v-for=&#39;food in foods&#39;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; // 2.组件需要被暴露，才能被外界使用 // 第一种写法，分别暴露 // export const list = { // data() { // return { // title: &#39;食谱&#39;, // foods: [&#39;青椒炒肉&#39;, &#39;水煮鱼片&#39;, &#39;宫保鸡丁&#39;] // } // }, // methods: { // } // } // 第二种写法，统一暴露 // export {list} // 第三中方式，默认暴露 // export default list // 或者下面这样 export default { name: List, data() { return { title: &#39;食谱&#39;, foods: [&#39;青椒炒肉&#39;, &#39;水煮鱼片&#39;, &#39;宫保鸡丁&#39;] } }, methods: { } }&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;App.vue&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; // 4.实例化组件 &amp;lt;List&amp;gt;&amp;lt;/List&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; // 1.引入子组件，.vue在脚手架中可以忽略 import List from &#39;./List.vue&#39; // 2.组件需要被暴露，才能被外界使用 export default { name: App, // 3.注册组件 components:{ List } }&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;main.jsimport App from &#39;./App.vue&#39;new Vue({ el:&#39;#root&#39;, // 在这里写了 template:`&amp;lt;App&amp;gt;&amp;lt;/App&amp;gt;` components:{ App }})index.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt; &amp;lt;title&amp;gt;测试&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- 1.main.js使用了Vue，所以在它之前需要引入vue.js --&amp;gt; &amp;lt;script src=&quot;./js/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 2.由于main.js使用了root元素，因此必须在其后引入 --&amp;gt; &amp;lt;script src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;分别暴露和统一暴露被外界引用时格式：import {XXX} from YYY，而默认暴露是：import XXX from YYY，所以我们推荐使用默认暴露，因为它更加简洁es6模块化" }, { "title": "data与el的两种写法", "url": "/posts/data%E4%B8%8Eel%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95/", "categories": "前端, Vue", "tags": "", "date": "2022-05-27 00:00:00 +0800", "snippet": "el的两种写法1.在实例中设置new Vue({ el:&quot;#app&quot;, data:{ msg:&quot;hello vue!&quot; }})2.创建实例之后设置var v = new Vue({ // el:&quot;#app&quot;, data:{ msg:&quot;hello vue!&quot; }})// 创建Vue实例之后再选择挂载哪个组件v.$mount(&#39;#app&#39;);data的两种写法1.对象式var v = new Vue({ // el:&quot;#app&quot;, data:{ msg:&quot;hello vue!&quot; }})v.$mount(&#39;#app&#39;);2.函数式var v = new Vue({ // data: function () { // return { // msg: &quot;hello vue!&quot; // } // } // 上面的形式一般简写成下面这样 data(){ return { msg: &#39;hello vue!&#39; } }})v.$mount(&#39;#app&#39;);注意：1.在组件中，data必须使用函数式，否则报错2.由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了" }, { "title": "Yarn与NPM", "url": "/posts/Yarn%E4%B8%8ENPM/", "categories": "前端, Vue", "tags": "", "date": "2022-05-27 00:00:00 +0800", "snippet": "包管理器以前一个简单的文本编辑器足以让开发人员创建和管理他们的大部分项目。但如今，即使是一个相当简单的项目也有成百上千个脚本，而且还具有复杂的嵌套依赖项。如果没有某种自动化工具，这些脚本根本无法管理。这就是包管理器发挥作用的地方。包管理器干的事以各种不同的方式自动处理项目的依赖，例如：在包管理器的帮助下，我们可以安装、卸载、更新和升级包，配置项目设置，运行脚本等。Yarn和NPMYarn是为了弥补NPM的一些缺陷而出现的NPM的缺陷 NPM install的时候巨慢，特别是新的项目拉下来要等半天，删除node_modules，重新install的时候依旧如此 同一个项目，安装的时候无法保持一致性。由于package.json文件版本号的特点，下面三个版本号在安装的时候代表不同的含义 “5.0.3”，表示安装指定的5.0.3版本“~5.0.3”，表示安装5.0.X中的最新版本^5.0.3，表示安装5.X.X中最新的版本这样就麻烦的，如果在项目约束中是用的后面两种，那么就很可能不同的人最终下载到的版本会不一样 安装的时候包会在同一时间下载和安装，中途一个包抛出错误，NPM也会继续下载和安装包 NPM把所有的日志输出到终端，有关报错误的信息和警告信息扎堆在一起，影响阅读，更甚至你可能永远不会发现实际存在的错误Yarn的优点 速度快 1.并行安装，NPM是按照队列执行每个package，只有当前package安装完成才会安装下一个package，而Yarn是同步执行所有任务，提高了性能。2.离线下载，如果之前已经安装了一个软件包，用Yarn会从缓存中获取，而NPM依旧从网络中下载 安装版本统一 为了防止每次拉取到不同的版本，Yarn有一个锁定文件（lock file）记录了被确切安装上的模块的版本号，每次只要新增了一个模块，Yarn就会创建（或更新）这个Yarn.lock文件，每次拉取下载是都是已经固定了的版本，这样就保证了模块的统一，而NPM也有这样的功能，但是lock file不是默认生成，需要执行NPM shrinkwrap命令 更简洁的输出 Yarn相比NPM输出更简洁，不过这只在1.X.X版本中存在 Yarn和NPM命令对比" }, { "title": "Vue Router的使用", "url": "/posts/VueRouter%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/", "categories": "前端, Vue", "tags": "", "date": "2022-05-27 00:00:00 +0800", "snippet": "什么是路由和路由器路由就是一组key-value的对应关系多个路由需要经过路由器进行管理vue-router的理解Vue的一个插件库，专门用来实现SPA应用，其中vue-router就是路由器，而我们创建的一个个链接地址与Vue组件页的键值对就是一个个路由，这些路由被Vue进行管理，当我们访问某个链接时，vue-router就会将指定的Vue组件渲染到对应的位置；使用vue-router的流程图如下：对SPA应用的理解1.单页Web应用（single page web application，SPA）2.整个应用只有一个完整的页面3.点击页面中的导航链接不会刷新页面，只会做页面的局部更新4.数据需要通过Ajax请求获取安装Vue Router1.npm下载：npm install vue-router@3.5.32.Yarn下载：yarn add vue-router@3.5.3注意：Vue2应该使用vue-router@3.X.X，这里推荐使用3.5.3版本的准备我们的组件在src下创建views文件夹，这里放我们的组件home.vue&amp;lt;template&amp;gt; &amp;lt;div&amp;gt;Home&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &#39;Home&#39;, data(){ return {} }}&amp;lt;/script&amp;gt;user.vue&amp;lt;template&amp;gt; &amp;lt;div&amp;gt;User&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { name: &#39;Home&#39;, data(){ return {} }}&amp;lt;/script&amp;gt;注册路由在项目下创建我们的router文件，这里放的是我们注册的路由，新建index.js文件如下：import Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import Home from &#39;@/views/Home&#39;import User from &#39;@/views/User&#39;Vue.use(VueRouter);export default new VueRouter({ mode: &quot;history&quot;, routes: [ { path: &#39;/home&#39;, name: &#39;Home&#39;, component: Home }, { path: &#39;/user&#39;, name: &#39;User&#39;, component: User } ]})创建好路由后再main.js配置路由import Vue from &#39;vue&#39;import Element from &#39;element-ui&#39;;import &#39;element-ui/lib/theme-chalk/index.css&#39;;import App from &#39;./App.vue&#39;import router from &#39;../router&#39;Vue.config.productionTip = falseVue.use(Element);new Vue({ // 配置名就叫router，不要乱修改，也就是配置路由器 // router:router,左右相同可以直接写成下面这样 router, render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;)预设组件的链接通过点击不同的链接，跳转到不同的组件，当然这一系列擦操作是由路由完成的在HelloWorld.vue中准备好跳转链接&amp;lt;template&amp;gt; &amp;lt;div class=&quot;hello&quot;&amp;gt; // 其实与a标签类似 // 不需要引入需要跳转的组件，毕竟我们也没有到，而这种不需要写标签的组件就被称为路由组件，通常被放在views中，而一般组件就被放在components中 &amp;lt;router-link to=&quot;/home&quot;&amp;gt; &amp;lt;el-button&amp;gt;Home页面&amp;lt;/el-button&amp;gt; &amp;lt;/router-link&amp;gt; &amp;lt;router-link to=&quot;/user&quot;&amp;gt; &amp;lt;el-button type=&quot;primary&quot;&amp;gt;User页面&amp;lt;/el-button&amp;gt; &amp;lt;/router-link&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;选择展示组件的地方在App.vue中&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&amp;gt; &amp;lt;HelloWorld/&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;就是组件被展示的地方使用vue-router需要注意的点" }, { "title": "Vue-cli4脚手架搭建", "url": "/posts/Vue-cli4%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA/", "categories": "前端, Vue", "tags": "", "date": "2022-05-27 00:00:00 +0800", "snippet": "为什么要使用Vue-cli脚手架Vue-cli脚手架自带多种插件，这些插件能帮助开发者提高项目开发的效率，快速搭建项目开发环境安装Vue-cli之前的环境准备安装Node.js1.版本查看命令：node -v2.Node.js安装包携带了NPM包管理器安装cnpm因为npm国内使用下载速度很慢，所以使用cnpm从一个淘宝团队搭建的npmjs.org镜像网站下载我们所需要的js包，这样速度会快很多1.安装命令：npm install -g cnpm--registry=https://registry.npm.taobao.org2.查看版本号：cnpm -v安装Yarn1.安装命令：npm install -g yarn2.查看版本：yarn -v安装Vue-cli脚手架工具1.安装命令：cnpm install -g @vue/cli2.查看版本号：vue -V使用Vue-cli创建项目1.创建项目命令：vue create vue-manage 项目名不能出现大写字母。如果安装了yarn，在创建项目的过程时会让你选择使用yarn还是npm安装项目依赖。2.运行项目：npm run serve" }, { "title": "Element-Ui初体验", "url": "/posts/Element-Ui%E5%88%9D%E4%BD%93%E9%AA%8C/", "categories": "前端, Vue", "tags": "", "date": "2022-05-27 00:00:00 +0800", "snippet": "Element-UI在网页中使用CDN引入Element-UI1.引入样式&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&amp;gt;2.引入js&amp;lt;!-- Vue必须在element-ui之前引入，因为element-ui.js是基于Vue的 --&amp;gt;&amp;lt;script src=&quot;https://unpkg.com/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!-- import JavaScript --&amp;gt;&amp;lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;打开对话框示例&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;!-- import CSS --&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&amp;gt; &amp;lt;title&amp;gt;对话框&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;el-row&amp;gt; &amp;lt;el-button @click=&quot;open&quot;&amp;gt;打开对话框&amp;lt;/el-button&amp;gt; &amp;lt;/el-row&amp;gt; &amp;lt;el-dialog title=&quot;标题&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot;&amp;gt; &amp;lt;span&amp;gt;内容&amp;lt;/span&amp;gt; &amp;lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&amp;gt; &amp;lt;!-- 3.取消或关闭操作， dialogVisble=false --&amp;gt; &amp;lt;el-button @click=&quot;dialogVisible = false&quot;&amp;gt;取 消&amp;lt;/el-button&amp;gt; &amp;lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&amp;gt;确 定&amp;lt;/el-button&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/el-dialog&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;!-- 在element-ui.js引入之前引入Vue.js --&amp;gt;&amp;lt;script src=&quot;https://unpkg.com/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt; new Vue({ el: &#39;#app&#39;, data: function () { // 1.dialogVisble，对话框是否显示 return { dialogVisible: false } }, methods: { // 2.open方法，dialogVisible=true open() { this.dialogVisible = true; } } })&amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;Element-Ui在脚手架中使用element-ui完整引入和按需引入1.安装模块：npm i element-ui -S2.完整引入：在main.js中写入以下内容import Vue from &#39;vue&#39;;import ElementUI from &#39;element-ui&#39;;import &#39;element-ui/lib/theme-chalk/index.css&#39;;import App from &#39;./App.vue&#39;;Vue.use(ElementUI);new Vue({ el: &#39;#app&#39;, render: h =&amp;gt; h(App)});3.按需引入：如果只需要引入Button，Select组件，像下面这样就可以使用了，当然也需要在main.js中操作import Vue from &#39;vue&#39;;import { Button, Select } from &#39;element-ui&#39;;import App from &#39;./App.vue&#39;;Vue.use(Button)Vue.use(Select)new Vue({ el: &#39;#app&#39;, render: h =&amp;gt; h(App)});按需引入避免了引入大量不需要的组件，能够大幅节省程序空间" }, { "title": "认识O(NlogN)的排序", "url": "/posts/%E8%AE%A4%E8%AF%86O(NlogN)%E7%9A%84%E6%8E%92%E5%BA%8F/", "categories": "算法与数据结构", "tags": "", "date": "2022-05-23 00:00:00 +0800", "snippet": "剖析递归行为和递归行为复杂度的估算递归求数组最大值public class RecursionArr { // right&amp;lt;arr.length，否则发送数组越界异常 public static int process(int[] arr, int left, int right){ if (left == right){ return arr[left]; } // (right-left)&amp;gt;&amp;gt;2 外面要加括号 int mid = left + ((right-left)&amp;gt;&amp;gt;2); int num1 = process(arr, left, mid); int num2 = process(arr, mid+1, right); return Math.max(num1, num2); }}master公式master公式是用来估算一类特殊的递归行为复杂度的方法，这类特殊的递归行为必须满足子问题规模相同才可使用master公式，公式如下：T(N) = aT(N/b)+O(Nd)，其中a代表子问题调用的次数，N/b代表子问题规模，O(Nd)代表除子问题外的额外时间复杂度，如果满足master公式则有：1.logba &amp;lt; d —&amp;gt; O(Nd)2.logba &amp;gt; d —&amp;gt; O(Nlogba)3.logba = d —&amp;gt; O(Nd·logN)使用master公式就可以很方便的估算一类递归行为的时间复杂度归并排序O(NlogN)public class MergeSort { public static void mergeSort(int[] arr){ if (arr == null || arr.length &amp;lt; 2){ return; } process(arr, 0, arr.length - 1); } private static void process(int[] arr, int L, int R) { if (L == R){ return; } int mid = L + ( (R-L) &amp;gt;&amp;gt; 1 ); process(arr, L, mid); process(arr, mid+1, R); merge(arr, L, mid, R); } private static void merge(int[] arr, int L, int M, int R) { int[] help = new int[R-L+1]; int i = 0; int p1 = L; int p2 = M+1; while (p1 &amp;lt;= M &amp;amp;&amp;amp; p2 &amp;lt;= R) { help[i++] = arr[p1] &amp;lt;= arr[p2] ? arr[p1++] : arr[p2++]; } while (p1 &amp;lt;= M){ help[i++] = arr[p1++]; } while (p2 &amp;lt;= R) { help[i++] = arr[p2++]; } for (i = 0; i&amp;lt;help.length; i++){ arr[L+i] = help[i]; } }}很显然归并排序满足master公式，求解可得：①母问题规模即arr数组长度为N，子问题规模为N/2，b=2②子问题被调用了2次，a=2③额外复杂度即help填充值和help拷贝进原数组的过程，即2O(N)，那么就是O(N)，d=1④logba = d所以归并排序的时间复杂度是O(NlogN)另外merge和process是在同一栈空间，而merge会引用辅助变量help，所以每次递归的空间复杂度是O(N)，调用完后就会销毁，所以最后的空间复杂度就是O(N)小和问题在一个数组中，每个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。例子：数组：[1, 3, 4, 2, 5] ，1左边比1小的数没有，3左边比3小的数，1，4左边比4小的数，1、3，2左边比2小的数，1，5左边比5小的数，1、3、4、2；所以小和为1+1+3+1+1+3+4+2=16求解思路如下：按照归并的方法，数组每次会被分为左右两个区间，在merge的过程中，区间之间数据的绝对位置是没有改变的，也就是说对于左区间的某个数A来说，未二分之前和二分之后A都是在右区间的左边merge在合并的过程中，如果左区间数据A小于有区间数据B，那么A会小于B和B右边的所有数据，因为两个区间本身是有序的原题链接和我的题解逆序对问题在一个数组中，左边的数如果比右边的数大，则选择两个数构成一个逆序对，请打印所有的逆序对分析思路同小和问题原题链接注意：在该原题中：求余公式(a+b)%p=(a%p+b%p)%p快速排序荷兰国旗问题问题1给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)思路如下：问题2（荷兰国旗问题）给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)颜色分类该题解题思路比较多： 单指针，遍历两次数组，分别把nums[i]=0和nums[i]=1的交换到数组最左，其中第一次遍历0，指针最后的位置为p1，所以区间[0, p1-1]都是0，第二次遍历1，指针最后的位置是p2，所以区间[p1, p2]都是1，剩下的就都是2，这样数组就排好了。 因为数组的元素固定分别是0、1、2，所以统计出个元素的数量，然后按照左0，中1，右2的顺序放置元素，数组就排好了，需要两次遍历，第一次统计，第二次填充数组 双指针，如果双指针都从0开始，其中p0交换0，p1交换1，i负责遍历，需要注意得是：p0==p1时，p0每次交换，p1也要与p0同步+1，这步保证p1不会落后p0，但直到p0 &amp;lt; p1得时候，这个时候就不需要遵循先前得原则，因为p1 &amp;gt; p0，而如果现在p0需要交换，那么一定会把原本的1替换出去，这时需要由p1再次交换，然后两者都+1，也就是如果p1 &amp;gt; p0，后面就会一直大于 双指针，其中p0从0开始，p2从n-1开始，n=nums.length，p0负责交换0，p2负责交换2，i负责遍历总结：不管怎么样第四种都是最右而且最简单得一种方法，所以还是优先采用第四种方式快排2.0在划分分区时：将其分为三块，&amp;lt;target、==target和&amp;gt;target三部分，这样每次分区，所有==target的就被排序好了快排3.0快排1.0和快排2.0都有一个问题:快排3.0为了不让target的选择过于固定，于是使用了生成随机位置的方法，最终在概率的加持下时间复杂度能保持在O(NlogN)因为每次分层递归都需要额外的空间存储target，所以空间复杂度为O(logN)，public class QuickSort { public static void quickSort(int[] arr){ if (arr == null || arr.length == 0 || arr.length == 1){ return; } quickSort(arr, 0, arr.length-1); } public static void quickSort(int[] arr, int L, int R){ if (L &amp;gt;= R){ return; } swap(arr, L + (int) (Math.random()*(R-L+1)), R); int[] p = partition(arr, L, R); quickSort(arr, L, p[0]-1); quickSort(arr, p[1]+1, R); } public static int[] partition(int[] arr, int L, int R){ int less = L-1; int more = R; while(L &amp;lt; more){ if (arr[L] &amp;lt; arr[R]){ swap(arr, ++less, L++); }else if (arr[L] &amp;gt; arr[R]){ swap(arr, --more, L); }else { L++; } } swap(arr, more, R); return new int[]{less+1, more}; } public static void swap(int[] arr, int a, int b){ int tmp = arr[a]; arr[a] = arr[b]; arr[b] = tmp; }}原题链接相关题目：最小k个数 这里要求使用快排，思路： 1.不同与快排将数组分为大于prox和小于等于prox的两个区间，这里我们只考虑左区间，直到左区间长度为k2.当左区间不足k个长度时，此时区间替换成右区间，并且我们只要分离出k-larr.length个最小的数据3.当分离出的左区间大于k，此时区间替换成分离后得左区间，并且我需要分离出k个最小得数据4.这样就形成得区间范围不断缩小得有效递归" }, { "title": "玉秀天气", "url": "/posts/%E7%8E%89%E7%A7%80%E5%A4%A9%E6%B0%94/", "categories": "项目, 玉秀天气", "tags": "litepal", "date": "2022-05-11 00:00:00 +0800", "snippet": "" }, { "title": "时间复杂度", "url": "/posts/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/", "categories": "算法与数据结构", "tags": "", "date": "2022-05-11 00:00:00 +0800", "snippet": "时间复杂度通常指最差情况下数据处理需要的开销，前提是数据量大的时候有效，原因是因为时间复杂度通常保存高阶，去掉低阶，如：O(n2 +2n+c)，通常表示为O(n2)，显然在数据量小的时候不可能忽略后面的低阶的数据，但如果数据量足够大，就可以忽略后面的低阶了常数操作与数据量无关的操作，通常基本数据运算，如加、减、乘、除等属于常数操作测试程序的优略解决一个问题不同方法，我们往往通过时间复杂度判断优略，如果时间复杂度越小，性能就越好，但如果时间复杂度相同就应该实测判断，毕竟每个常数操作开销不同，如乘法大于加法的开销，加法大于位运算开销，因而用低阶部分判断优略是不合理的空间复杂度如果只需要借助几个变量，空间复杂度为O(1)，如果额外的空间与程序使用的数据结构规模相当，那么就是O(n)异或运算^异或运算有种很便于记忆的性质，它可以看作无进位的加法异或运算两数交换通过异或运算可以快速的交换两个数：int a=11,b=13;a=a^b;b=a^b;a=a^b;当然前提是a，b内存位置不一样，毕竟两个相同的数异或会清零异或运算的性质存在变量eor：①0^eor=eor，②eor^eor=0，③满足交换律第三点证明：最终的结果取决于同一行上1的奇偶如果为奇，结果为1；如果为偶，结果为0；如下图经典例题1.存在数组，只有一类数出现奇数次，其余均出现偶数次，求这个出现奇数次的数 原题链接2.有两种数存在奇数次，其余存在偶数次，求这个两种出现奇数次的数 原题链接提示：假设两种数设为a，b，异或后的结果是eor；由题意可得：a不等于b，即eor二进制上存在一位一定是1，且a，b在该位值一定不同，那么通过该为就可以将数据分为两类，一类是值=1，一类是值=2； 思路：1.求eor最右为1的二进制数result，即如果eor=00010001，那么result=00000001。公式：result=eor&amp;amp;（~eor+1）或者result = eor &amp;amp; -eor2.对数组分类：数组上的数与result做&amp;amp;运算，将等于0的一类统统异或，最终的结果就是a，或b中的一个，假设求出的值为x；3.y=eor^x，其中x和y就是最终的结果注意：&amp;amp; 和 == 的优先级顺序，实际上 == 的优先级大于 &amp;amp;，Java运算符优先级表如下：选择排序O(N2)/** * 选择出未排序的最小元素与排好序的末尾元素交换 */public class SelectionSort { public static void doWork(Integer[] arr){ // 1.不合格的数组 if(arr==null || arr.length &amp;lt; 2){ return ; } // 2.arr.length-1个元素排好序后，整个数组就有序了 for (int i = 0; i &amp;lt; arr.length-1; i++) { int minIndex = i; // 3.在未排好序的数组中选择最小元素 for (int j = i+1; j &amp;lt; arr.length; j++) { minIndex = arr[minIndex]&amp;gt;arr[j] ? j : minIndex; } // 4.交换 swap(arr, i, minIndex); } return ; } private static void swap(Integer[] arr, int x, int y){ Integer tmp = arr[x]; arr[x] = arr[y]; arr[y] = tmp; }}冒泡排序O(N2)/** * 冒泡排序，顾名思义泡泡从水底到水面逐渐变大 */public class BubbleSort { public static void doWork(Integer[] arr){ // 0.不合格的数组 if (arr == null || arr.length &amp;lt; 2) { return; } // 1.进行arr.length-1轮冒泡排序，能完成数组排序 for (int i = arr.length - 1; i &amp;gt; 0; i--) { // 2.每轮需要完成的比较次数 for (int j = 0; j &amp;lt; i; j++) { if (arr[j] &amp;gt; arr[j+1]) { swap(arr, j, j+1); } } } } private static void swap(Integer[] arr, int j, int i) { Integer tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp; }}插入排序O(N)~O(N2)/** * 所谓插入排序，就是指对于有序的部分，插入一个数重排的过程 */public class InsertSort { public static void doWork(Integer[] arr){ // 1.不合格的数组 if (arr == null || arr.length &amp;lt; 2) { return; } // 2.要插入arr.length个数 for (int i = 0; i &amp;lt; arr.length; i++) { // 3.首先保证当前插入元素所在的索引大于0，然后当前索引一定比前面的数小，才触发重排 for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j] &amp;lt; arr[j-1]; j--) { swap(arr, j, j-1); } } } private static void swap(Integer[] arr, int j, int i) { Integer tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp; }}二分查找O(logN)二分查找实例1.在一个有序数组中，找某个数是否存在2.在一个有序数组中，找&amp;gt;=某个数最左侧的位置提示：index变量记录到每次命中的元素下标，最小的index就是我们要的结果3.局部最小：数组arr无序，任何两个相邻的数一定不相等，定义局部最小为：①在0位置，如果arr(0) &amp;lt; arr(1)，那么局部最小值在0位置；②在n位置，如果arr(n) &amp;lt; arr(n-1)，那么局部最小在n位置；③对于中间位置m，如果arr(m) &amp;lt; arr(m-1)，且arr(m) &amp;lt; arr(m+1)，那么m是局部最小位置。提示：①首先判断0和n位置；②二分法判断m-1，和m+1，此时可能出现两种情况：第一种，m-1 &amp;gt; m &amp;gt; m+1，那么二分区间更新为(m+1,n)第二种，m-1 &amp;lt; m &amp;lt; m+1，那么二分区间更新为(0,m-1)局部最小相关题目：寻找峰值峰顶索引山脉数组中查找目标值对数器 有一个你想要测的方法a。 实现复杂度不好但是容易实现的方法b。 实现一个随机样本产生器。 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或方法b。 当样本数量很多时比对测试依然正确，可以确定方法a基本正确。 /** * 这是用来比较两个排序方法的正确性 * @param testTimes * @param maxLength * @param maxValue */ private void comparableDataMachine(int testTimes, int maxLength, int maxValue) { // 1.循环测试testTimes次 for (int i = 0; i &amp;lt; testTimes; i++) { // 2.生成随机长度的数组 int[] arr = new int[(int)(maxLength * Math.random())]; // 3.生成随机数组值 for (int j = 0; j &amp;lt; arr.length; j++) { arr[j] = (int) (maxValue * Math.random()); } // 4.拷贝新的数组 int[] copyArr = Arrays.copyOf(arr, arr.length); // 5.分别对两对数组排序 BubbleSort.doWork(arr); InsertSort.doWork(copyArr); // 6.打印方法测试结果 if (Arrays.equals(arr, copyArr)) { System.out.println(&quot;yes&quot;); }else{ // 打印样本 System.out.println(arr.toString()); System.out.println(&quot;no&quot;); } } }" }, { "title": "excel数据处理", "url": "/posts/excel%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/", "categories": "Office办公软件, Excel", "tags": "", "date": "2022-05-11 00:00:00 +0800", "snippet": "" }, { "title": "Vue基础", "url": "/posts/vue%E5%9F%BA%E7%A1%80/", "categories": "前端, Vue", "tags": "", "date": "2022-05-09 00:00:00 +0800", "snippet": "vue框架的特点 相比JavaScript，vue作为前端框架更加强大 简化dom操作，vue通过特殊的语法操作dom元素 响应式数据驱动，页面由数据组成，数据一旦发生改变，页面随之改变el挂载点1.el设置的是Vue实例挂载（管理）的元素，经挂载的元素，包括其后代元素都会被Vue实例管理2.推荐在el中使用id选择器挂载元素，虽然可以选择其他元素3.推荐挂载双标签元素，但不建议挂载html和body元素&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;br&amp;gt; &amp;lt;span&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el:&quot;#app&quot;, data:{ msg:&quot;hello vue!&quot; } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;data数据对象Vue实例使用的数据都会定义在data数据对象中javascript常见数据类型值类型：数字（Number），字符串（String），布尔（Boolean），null，undefined;与Java不同的是JavaScript字符串是数值型，而不是引用型引用数据类型（对象类型）：对象（Object），数组（Array），函数（Function）var x; // x 为 undefinedvar x = 5; // 现在 x 为数字var x = &quot;John&quot;; // 现在 x 为字符串typeof &quot;John&quot; // 返回 stringtypeof 3.14 // 返回 numbertypeof false // 返回 booleantypeof [1,2,3,4] // 返回 objecttypeof {name:&#39;John&#39;, age:34} // 返回 objectundefined和nullundefined用于变量，属性和方法，null用于对象数组如何判断类型是数组用typeof判断数组类型依然是object，实际判断数组类型可以使用isArray方法和instanceof操作符// 1.使用isArray方法var cars=new Array();cars[0]=&quot;Saab&quot;;cars[1]=&quot;Volvo&quot;;cars[2]=&quot;BMW&quot;;// 判断是否支持该方法if (Array.isArray) { if(Array.isArray(cars)) { document.write(&quot;该对象是一个数组。&quot;) ; }}if (cars instanceof Array) { document.write(&quot;该对象是一个数组。&quot;) ;}创建数组的方法// 第一种方法var arr = new Array();arr[0] = &quot;saab&quot;;arr[1] = &quot;saas&quot;;// 第二种方法var arr = new Array(&quot;saab&quot;,&quot;saas&quot;);// 第三种方法var arr = [&quot;saab&quot;,&quot;saas&quot;];data数据对象使用示例&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;h1&amp;gt;我的云盘&amp;lt;/h1&amp;gt; &amp;lt;table id=&quot;app&quot;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;称号&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;\\{\\{my_net_disk_name\\}\\}&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;名称&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;\\{\\{driver_config.name\\}\\}&quot;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;存储源类型&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;\\{\\{driver_config.type\\}\\}&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;存储源根地址&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;\\{\\{driver_config.root_url\\}\\}&quot;&amp;lt;/td&amp;gt; &amp;lt;!-- 出问题的地方 --&amp;gt; &amp;lt;!-- &amp;lt;td&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;&amp;lt;/td&amp;gt; --&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;文件&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;\\{\\{driver_config.files[0]\\}\\}&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { my_net_disk_name: &quot;my_net_disk&quot;, driver_config: { id: 1, name: &quot;蓝色空间号&quot;, type: &quot;阿里云存储&quot;, root_url: &quot;www.flameking.com&quot;, files: [&quot;葵花宝典&quot;, &quot;降龙十八掌&quot;, &quot;如来神掌&quot;, &quot;狮吼功&quot;] } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;关注的问题：我们发现，在元素属性赋值使用数据对象会失效&amp;lt;td&amp;gt;&amp;lt;a href=&quot;\\{\\{driver_config.root_url\\}\\}&quot;&amp;gt;&amp;lt;/td&amp;gt;这里其实就需要使用我们vue的特定语法了，见下章：vue指令vue指令内容绑定、事件绑定v-text指令和插值表达式{{}} v-text表达式会替换标签内部的所有内容，如果部分替换，推荐使用{{}}` v-text和{{}}内部都可以进行字符串拼接操作&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;!-- 1.内容替换 --&amp;gt; &amp;lt;!-- 2.字符串拼接 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;p v-text=&quot;my_net_disk_name&quot;&amp;gt;阿里云&amp;lt;/p&amp;gt; &amp;lt;p v-text=&quot;driver_config.name +&#39;前进四&#39;&quot;&amp;gt;那里不是家&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;\\{\\{driver_config.type + &quot;yyds&quot;\\}\\}那里不是家&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { my_net_disk_name: &quot;my_net_disk&quot;, driver_config: { id: 1, name: &quot;蓝色空间号&quot;, type: &quot;阿里云存储&quot;, root_url: &quot;www.flameking.com&quot;, files: [&quot;葵花宝典&quot;, &quot;降龙十八掌&quot;, &quot;如来神掌&quot;, &quot;狮吼功&quot;] } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;v-text和v-html v-html指令的作用是：设置元素对象的innerHTML属性，内容中有html结构会被解析为标签 v-text指令无论什么内容，只会解析为文本&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;p v-text=&quot;driver_config.root_url&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p v-html=&quot;driver_config.root_url&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { my_net_disk_name: &quot;my_net_disk&quot;, driver_config: { id: 1, name: &quot;蓝色空间号&quot;, type: &quot;阿里云存储&quot;, root_url: &quot;&amp;lt;a href=&#39;www.flameking.com&#39;&amp;gt;我的根目录&amp;lt;/a&amp;gt;&quot;, files: [&quot;葵花宝典&quot;, &quot;降龙十八掌&quot;, &quot;如来神掌&quot;, &quot;狮吼功&quot;] } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;v-on指令 v-on指令是为元素绑定事件 指令可简写为@ 绑定的事件函数定义在methods属性中 函数内部必须通过this引用data中的数据对象，否则无法引用 如果事件函数逻辑简单，比如仅仅一条表达式，那么就可以直接写在v-on:click=&#39;表达式&#39;中&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;做菜&quot; v-on:click=&quot;doliaoli&quot;&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;双击获取小红花&quot; @dblclick=&quot;redflower&quot;&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1&amp;gt;你已经获取8朵小红花&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { action: &quot;西红柿炒蛋&quot;, count: 0 }, methods: { doliaoli:function(){ this.action+=&quot;好好吃！&quot;; console.log(this.action); }, redflower: function(){ alert(&quot;送你一朵小红花&quot;); // 如果不用this修饰，无法引用数据对象 this.count++; } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;v-on指令自定义传参和事件修饰符1.当事件函数带上了形参，那么传实参时就形如：v-on=”doliaoli(‘好吃’)”2.事件的后面跟上.修饰符可以对事件进行限制3..enter可以限制触发的按键为回车4.事件修饰符有多种，详细可查阅&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;button @click=&quot;doliaoli(dishName[index])&quot;&amp;gt;做菜&amp;lt;/button&amp;gt; &amp;lt;button @click=&quot;prepareDish&quot;&amp;gt;准备其他菜品&amp;lt;/button&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;text&quot; value=&quot;请输入消息&quot; @keyup.enter=&quot;enter&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { dishName: [&quot;西红柿炒蛋&quot;,&quot;辣椒炒肉&quot;,&quot;剁椒鱼头&quot;,&quot;麻婆豆腐&quot;], index: 0 }, methods: { doliaoli: function(dishName){ alert(&quot;你刚刚做了一道&quot; + dishName); }, prepareDish: function(){ this.index = (this.index+1)%this.dishName.length; console.log(this.index); }, enter: function(){ console.log(&#39;消息已发送&#39;); } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;计数器案例body{ background-color: #f5f5f5;}#app { width: 480px; height: 80px; margin: 200px auto;}.input-num { margin-top:20px; height: 100%; display: flex; border-radius: 10px; overflow: hidden; box-shadow: 4px 4px 4px #adadad; border: 1px solid #c7c7c7; background-color: #c7c7c7;}.input-num button { width: 150px; height: 100%; font-size: 40px; color: #ad2a27; cursor: pointer; border: none; outline: none; background-color:rgba(0, 0, 0, 0);}.input-num span { height: 100%; font-size: 40px; flex: 1; text-align: center; line-height: 80px; font-family:auto; background-color: white;}img{ float: right; margin-top: 50px;}&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;计数器&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;div class=&quot;input-num&quot;&amp;gt; &amp;lt;button @click=&quot;sub&quot;&amp;gt;-&amp;lt;/button&amp;gt; &amp;lt;span&amp;gt;\\{\\{count\\}\\}&amp;lt;/span&amp;gt; &amp;lt;button @click=&quot;add&quot;&amp;gt;+&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { count: 0 }, methods: { add: function () { if (this.count &amp;lt; 10) { ++this.count; } else { alert(&quot;兄弟，最大不过10&quot;); } }, sub: function () { if (this.count &amp;gt; 0) { --this.count; } else { alert(&quot;兄弟，最小不过0&quot;); } } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;显示切换、属性绑定v-show v-show指令作用是：根据真假切换元素的显示状态，实际原理为设置css属性display: none，实现元素的隐藏 指令后面的内容，最终都会解析为布尔值 v-show=”true”，元素显示；v-show=”false”，元素隐藏&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; #app { width: 480px; height: 80px; margin: 200px auto; } /* .hp { margin-top: 20px; height: 100%; display: flex; border-radius: 10px; overflow: hidden; box-shadow: 4px 4px 4px #adadad; border: 1px solid #c7c7c7; background-color: #c7c7c7; } */ div.hp { width: 500px; height: 100%; font-size: 20px; color: #ad2a27; cursor: pointer; border: none; outline: none; background-color: rgba(0, 0, 0, 0); } div span { font-size: 50px; } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;div class=&quot;hp&quot;&amp;gt; &amp;lt;img v-show=&quot;HP&quot; src=&quot;./img/艾莉丝-无职转生.jpg&quot;&amp;gt; &amp;lt;h1&amp;gt;心魔的血量还剩&amp;lt;/h1&amp;gt; &amp;lt;br&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;h1 v-show=&quot;HP&quot;&amp;gt;各方道友，我快抵挡不住诱惑了，点击下方按钮助我击败心魔&amp;lt;/h1&amp;gt; &amp;lt;button @click=&quot;suppress&quot; v-text=&quot;button_content&quot;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { HP: 10, button_content: &quot;齐心协力击败心魔&quot; }, methods: { suppress: function () { if (this.HP &amp;gt; 0) { --this.HP; } if (this.HP &amp;lt;= 2) { console.log(&quot;心魔即将消灭！道友再加把力！&quot;); } if (this.HP == 0) { alert(&quot;心魔已被击败，感谢道友的助力\\n道友可就此打住&quot;); this.button_content = &quot;心魔已经被打败&quot;; } } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;从这段程序可见，v-show把值大于0的一切整数解析为true，0则解析为falsev-show和v-ifv-if显示效果和使用方式与v-show并无区别，不过两者在dom操作底层上有本质区别，v-if表达式为false时，整个元素会从dom树结构移除，而v-show元素一直存在显然v-if效率更低，如果元素需要频繁切换不推荐使用v-ifv-bindv-bind用于专门操作元素内部属性，完整写法是v-bind:属性名，简写即:属性名，v-bind可直接省略，经绑定后的属性可以使用data数据对象中的值常见应用：需要动态的增删class属性，当然建议使用对象的方式&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; a.active { font-size: 50px; } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;!-- v-bind操作元素属性 --&amp;gt; &amp;lt;!-- 1.被v-bind修饰的元素内部属性可以使用data数据对象 --&amp;gt; &amp;lt;!-- 2.经典应用，操作class属性显示样式 --&amp;gt; &amp;lt;!-- 对象方式 :class=&quot;{active:isActive}&quot; 读作class属性active的存在取绝isActive的值 --&amp;gt; &amp;lt;a :href=&quot;my_blog_url&quot; target=&quot;_blank&quot; :class=&quot;{active: isActive}&quot;&amp;gt;我的博客&amp;lt;/a&amp;gt; &amp;lt;br&amp;gt; &amp;lt;button @click=&quot;vary_size&quot;&amp;gt;改变大小&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { my_blog_url: &quot;https://Casflawed.github.io&quot;, isActive: true }, methods: { vary_size:function(){ this.isActive = !this.isActive; } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;图片切换实例* { margin: 0; padding: 0;}html,body,#mask { width: 100%; height: 100%;}#mask { background-color: #c9c9c9; position: relative;}#mask .center { position: absolute; background-color: #fff; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 10px;}#mask .center .title { position: absolute; display: flex; align-items: center; height: 56px; top: -61px; left: 0; padding: 5px; padding-left: 10px; padding-bottom: 0; color: rgba(175, 47, 47, 0.8); font-size: 26px; font-weight: normal; background-color: white; padding-right: 50px; z-index: 2;}#mask .center .title img { height: 40px; margin-right: 10px;}#mask .center .title::before { content: &quot;&quot;; position: absolute; width: 0; height: 0; border: 65px solid; border-color: transparent transparent white; top: -65px; right: -65px; z-index: 1;}#mask .center &amp;gt; img { display: block; width: 700px; height: 458px;}#mask .center a { text-decoration: none; width: 45px; height: 100px; position: absolute; top: 179px; vertical-align: middle; opacity: 0.5;}#mask .center a :hover { opacity: 0.8;}#mask .center .left { left: 15px; text-align: left; padding-right: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px;}#mask .center .right { right: 15px; text-align: right; padding-left: 10px; border-top-left-radius: 10px; border-bottom-left-radius: 10px;}img.display_img{ width: 620px; height: 349px;}&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;图片切换&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/toggle_img.css&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div id=&quot;mask&quot;&amp;gt; &amp;lt;div class=&quot;center&quot;&amp;gt; &amp;lt;img class=&quot;display_img&quot; :src=&quot;imgs[index]&quot; alt=&quot;&quot;&amp;gt; &amp;lt;!-- v-if 如果操作img元素则会出错 --&amp;gt; &amp;lt;a v-if=&quot;index&amp;gt;0&quot; @click=&quot;left&quot; class=&quot;left&quot;&amp;gt;&amp;lt;img src=&quot;./img/prev.png&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;!-- 数组可以调用imgs.length，可见data数据对象依然符合JavaScript语法 --&amp;gt; &amp;lt;a v-if=&quot;index&amp;lt;imgs.length-1&quot; @click=&quot;right&quot; class=&quot;right&quot;&amp;gt;&amp;lt;img src=&quot;./img/next.png&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#mask&quot;, data: { index: 0, left_display: false, right_display: true, imgs: [&quot;./img/01.png&quot;,&quot;./img/02.jpg&quot;,&quot;./img/03.jpg&quot;,&quot;./img/04.jpg&quot;,&quot;./img/05.jpg&quot;] }, methods: { left: function(){ if(this.index == 0){ this.index = 4; }else{ this.index--; } }, right: function(){ if(this.index == 4){ this.index = 0; }else{ this.index++; } } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;列表循环、表单元素绑定v-for指令根据数据循环生成dom元素列，类比JSP模板引擎中的c:foreach标签，语法是v-for=&quot;(item,index) in arr&quot;，item和index可以结合其他指令一起使用。数组经常和v-for结合使用，并且数组长度的更新会同步到v-for，是响应式的。&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for=&quot;(item,index) in items&quot;&amp;gt;\\{\\{item\\}\\}+\\{\\{index\\}\\}&amp;lt;/li&amp;gt; &amp;lt;button @click=&quot;add&quot;&amp;gt;添加&amp;lt;/button&amp;gt; &amp;lt;button @click=&quot;shift&quot;&amp;gt;删除&amp;lt;/button&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { items: [1, 2, 3, 4, 5] }, methods: { add: function () { this.items.push(&quot;6&quot;); }, shift: function(){ this.items.shift(); } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;v-model指令能把表单中的值和挂载实例中的数据关联起来，这样可以十分便捷的获取、设置表单元素的值（双向绑定，指更改任何一方，都会同步更新）&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;button @click=&quot;setMsg&quot;&amp;gt;修改输入框&amp;lt;/button&amp;gt; &amp;lt;input type=&quot;text&quot; v-model=&quot;msg&quot; @keyup.enter=&quot;getMsg&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { msg: &quot;对数器&quot; }, methods: { getMsg: function(){ alert(this.msg); }, setMsg: function(){ this.msg = &quot;局部最小量&quot;; } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;记事本案例0.显示带索引的任务列表，v-for，和插值表达式展示item和index1.添加任务，v-model让数据对象和输入框值双向绑定，v-on绑定keyup.enter事件，将数据添加进数组2.删除任务，v-on，数组list.splice(index,count)，从index位置删除count个元素3.统计元素个数4.清空数组元素，list = []5.隐藏清空后列表的显示效果，使用v-show=”list.length&amp;gt;0”&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;小黑记事本&amp;lt;/title&amp;gt; &amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot; /&amp;gt; &amp;lt;meta name=&quot;googlebot&quot; content=&quot;noindex, nofollow&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/notebook.css&quot; /&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- 主体区域 --&amp;gt; &amp;lt;section id=&quot;todoapp&quot;&amp;gt; &amp;lt;!-- 输入框 --&amp;gt; &amp;lt;header class=&quot;header&quot;&amp;gt; &amp;lt;h1&amp;gt;小黑记事本&amp;lt;/h1&amp;gt; &amp;lt;input v-model=&quot;inputValue&quot; @keyup.enter=&quot;add&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; /&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;!-- 列表区域 --&amp;gt; &amp;lt;section class=&quot;main&quot;&amp;gt; &amp;lt;ul class=&quot;todo-list&quot;&amp;gt; &amp;lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&amp;gt; &amp;lt;div class=&quot;view&quot;&amp;gt; &amp;lt;span class=&quot;index&quot;&amp;gt;.&amp;lt;/span&amp;gt; &amp;lt;label&amp;gt;&amp;lt;/label&amp;gt; &amp;lt;button class=&quot;destroy&quot; @click=&quot;remove(index)&quot;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;!-- 统计和清空 --&amp;gt; &amp;lt;footer v-show=&quot;list.length&amp;gt;0&quot; class=&quot;footer&quot; &amp;gt; &amp;lt;span class=&quot;todo-count&quot;&amp;gt; &amp;lt;strong&amp;gt;&amp;lt;/strong&amp;gt; items left &amp;lt;/span&amp;gt; &amp;lt;button class=&quot;clear-completed&quot; @click=&quot;clear&quot;&amp;gt; Clear &amp;lt;/button&amp;gt; &amp;lt;/footer&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;!-- 底部 --&amp;gt; &amp;lt;!-- &amp;lt;footer class=&quot;info&quot;&amp;gt; &amp;lt;p&amp;gt; &amp;lt;a href=&quot;http://www.itheima.com/&quot;&amp;gt;&amp;lt;img src=&quot;./img/black.png&quot; alt=&quot;&quot; /&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/footer&amp;gt; --&amp;gt; &amp;lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#todoapp&quot;, data: { list: [], inputValue: &quot;好好学习,天天向上&quot;, isActive: false }, methods: { add: function () { this.list.push(this.inputValue); this.inputValue = &quot;&quot;; }, remove:function(index){ this.list.splice(index,1); }, clear:function(){ this.list = []; } }, }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;axios网络应用axios是封装Ajax后的产物，它相比Ajax更加易用，功能更加单一，就是发送网络请求axios发送get请求&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;axios get请求&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- el挂载的元素内部，可以使用声明的数据，外部不行 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;button @click=&quot;getJoke&quot;&amp;gt;获取随机笑话&amp;lt;/button&amp;gt; &amp;lt;p&amp;gt;\\{\\{joke\\}\\}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &quot;#app&quot;, data: { joke:&#39;&#39; }, methods: { getJoke:function(){ // 两个函数内部使用this的含义不同 var obj = this; axios.get(&quot;https://autumnfish.cn/api/joke&quot;) .then(function(response){ obj.joke = response.data; }) .catch(function(error){ console.log(&#39;错误码：&#39; + error.status + &#39;,错误消息：&#39; + error.statusText); }) } } }) &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;1.axios回调函数中的this并不是Vue实例对象，这个this是无法访问到data中的数据，解决办法时将代表Vue实例的this用变量存储起来，延长作用域，这样就可以在axios回调函数中使用2.axios网络应用和本地应用最大的区别就是改变了数据来源，原来都是本地生成的数据，而现在使用请求响应的数据天知道网络案例&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt; &amp;lt;title&amp;gt;天知道&amp;lt;/title&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/weather_reset.css&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/weather_index.css&quot; /&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;wrap&quot; id=&quot;app&quot;&amp;gt; &amp;lt;div class=&quot;search_form&quot;&amp;gt; &amp;lt;div class=&quot;logo&quot;&amp;gt;&amp;lt;img src=&quot;./img/logo.png&quot; alt=&quot;logo&quot; /&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;form_group&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; v-model=&quot;city&quot; @keyup.enter=&quot;searchWeather&quot; class=&quot;input_txt&quot; placeholder=&quot;请输入查询的天气&quot;/&amp;gt; &amp;lt;button class=&quot;input_sub&quot; @click=&quot;searchWeather&quot;&amp;gt; 搜 索 &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;hotkey&quot;&amp;gt; &amp;lt;a href=&quot;javascript:;&quot; @click=&quot;changeCity(&#39;北京&#39;)&quot;&amp;gt;北京&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;javascript:;&quot; @click=&quot;changeCity(&#39;上海&#39;)&quot;&amp;gt;上海&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;javascript:;&quot; @click=&quot;changeCity(&#39;广州&#39;)&quot;&amp;gt;广州&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;javascript:;&quot; @click=&quot;changeCity(&#39;深圳&#39;)&quot;&amp;gt;深圳&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;ul class=&quot;weather_list&quot;&amp;gt; &amp;lt;li v-for=&quot;item in weatherList&quot;&amp;gt; &amp;lt;div class=&quot;info_type&quot;&amp;gt; &amp;lt;span class=&quot;iconfont&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;info_temp&quot;&amp;gt; &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; ~ &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;info_date&quot;&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 官网提供的 axios 在线地址 --&amp;gt; &amp;lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 自己的js --&amp;gt; &amp;lt;script src=&quot;./js/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;var app = new Vue({ el: &quot;#app&quot;, data: { city: &#39;衡阳&#39;, weatherList: [] }, methods:{ searchWeather: function(){ var main = this; axios.get(&quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot; + this.city) .then(function(response){ main.weatherList = response.data.data.forecast; // 查看控制台会发现，这条打印语句最后才会打印，毕竟是网络请求速度会要慢些 console.log(main.weatherList); }) console.log(this.city); }, changeCity: function(city){ this.city = city; this.searchWeather(); } }})Vue实例在methods方法内部通过this表示，类比Java类，this其实就是对象，而data就是属性或者说字段，el就是构造函数，methods就是方法，那么这些元素都可以通过this.的方法调用，如this.searchWeather()，就表现为方法searchweather方法被调用。悦听player&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt; &amp;lt;title&amp;gt;悦听player&amp;lt;/title&amp;gt; &amp;lt;!-- 样式 --&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/player/index.css&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;wrap&quot;&amp;gt; &amp;lt;!-- 播放器主体区域 --&amp;gt; &amp;lt;div class=&quot;play_wrap&quot; id=&quot;player&quot;&amp;gt; &amp;lt;div class=&quot;search_bar&quot;&amp;gt; &amp;lt;img src=&quot;./img/player/player_title.png&quot; alt=&quot;&quot; /&amp;gt; &amp;lt;!-- 搜索歌曲 --&amp;gt; &amp;lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; v-model=&quot;query&quot; @keyup.enter=&quot;searchSongs&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;center_con&quot;&amp;gt; &amp;lt;!-- 歌曲列表 --&amp;gt; &amp;lt;div class=&#39;song_wrapper&#39;&amp;gt; &amp;lt;ul class=&quot;song_list&quot;&amp;gt; &amp;lt;li v-for=&quot;(item,index) in songs&quot;&amp;gt; &amp;lt;a href=&quot;javascript:;&quot; @click=&quot;playSong(index)&quot;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; &amp;lt;!-- 显示mv图标 --&amp;gt; &amp;lt;span&amp;gt;&amp;lt;i v-show=&quot;item.mvid&amp;gt;0&quot; @click=&quot;playMV(item.mvid)&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;img src=&quot;./img/player/line.png&quot; class=&quot;switch_btn&quot; alt=&quot;&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 歌曲信息容器 --&amp;gt; &amp;lt;div class=&quot;player_con&quot; :class=&quot;{playing:isPlaying_song}&quot;&amp;gt; &amp;lt;img src=&quot;./img/player/player_bar.png&quot; class=&quot;play_bar&quot; /&amp;gt; &amp;lt;!-- 黑胶碟片 --&amp;gt; &amp;lt;img src=&quot;./img/player/disc.png&quot; class=&quot;disc autoRotate&quot; /&amp;gt; &amp;lt;!-- 歌曲封面 --&amp;gt; &amp;lt;img :src=&quot;songCover&quot; class=&quot;cover autoRotate&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 评论容器 --&amp;gt; &amp;lt;div class=&quot;comment_wrapper&quot;&amp;gt; &amp;lt;h5 class=&#39;title&#39;&amp;gt;热门留言&amp;lt;/h5&amp;gt; &amp;lt;div class=&#39;comment_list&#39;&amp;gt; &amp;lt;dl v-for=&quot;item in songHotComments&quot;&amp;gt; &amp;lt;!-- 用户头像 --&amp;gt; &amp;lt;dt&amp;gt;&amp;lt;img :src=&quot;item.user.avatarUrl&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/dt&amp;gt; &amp;lt;!-- 用户昵称 --&amp;gt; &amp;lt;dd class=&quot;name&quot;&amp;gt;&amp;lt;/dd&amp;gt; &amp;lt;!-- 用户评论 --&amp;gt; &amp;lt;dd class=&quot;detail&quot;&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;img src=&quot;./img/player/line.png&quot; class=&quot;right_line&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;audio_con&quot;&amp;gt; &amp;lt;!-- 音频播放器 --&amp;gt; &amp;lt;audio ref=&#39;audio&#39; :src=&quot;songUrl&quot; @pause=&quot;doPause_song&quot; @playing=&quot;doPlaying_song&quot; controls autoplay loop class=&quot;myaudio&quot;&amp;gt;&amp;lt;/audio&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;video_con&quot; v-show=&quot;isShow_mv&quot;&amp;gt; &amp;lt;!-- 视频播放器 --&amp;gt; &amp;lt;video :src=&quot;mvUrl&quot; controls=&quot;controls&quot;&amp;gt;&amp;lt;/video&amp;gt; &amp;lt;div class=&quot;mask&quot; @click=&quot;hide&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 官网提供的 axios 在线地址 --&amp;gt; &amp;lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&quot;./js/player_main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;/* 1:歌曲搜索接口 请求地址:https://autumnfish.cn/search 请求方法:get 请求参数:keywords(查询关键字) 响应内容:歌曲搜索结果 2:歌曲url获取接口 请求地址:https://autumnfish.cn/song/url 请求方法:get 请求参数:id(歌曲id) 响应内容:歌曲url地址 3.歌曲详情获取 请求地址:https://autumnfish.cn/song/detail 请求方法:get 请求参数:ids(歌曲id) 响应内容:歌曲详情(包括封面信息) 4.热门评论获取 请求地址:https://autumnfish.cn/comment/hot?type=0 请求方法:get 请求参数:id(歌曲id,地址中的type固定为0) 响应内容:歌曲的热门评论 5.mv地址获取 请求地址:https://autumnfish.cn/mv/url 请求方法:get 请求参数:id(mvid,为0表示没有mv) 响应内容:mv的地址*/var app = new Vue({ el: &quot;#player&quot;, data: { // 查询关键字 query:&#39;&#39;, // 歌曲数组 songs:[], // 歌曲地址 songUrl:&#39;&#39;, // 歌曲封面 songCover:&#39;&#39;, // 歌曲评论 songHotComments:[], // 动画播放状态 isPlaying_song:false, // 正在播放歌曲的索引 songId:-1, // 遮罩层的显示状态 isShow_mv:false, // mv地址 mvUrl:&#39;&#39; }, methods: { // 1.搜索歌曲，初始化歌曲数组 searchSongs:function(){ var main = this; axios.get(&quot;https://autumnfish.cn/search?keywords=&quot;+this.query) .then(function(response){ main.songs = response.data.result.songs; console.log(response); }) .catch(function(error){}) }, // 2.播放歌曲 playSong:function(index){ // 2-0.避免正在播放的歌曲信息被反复请求 if(this.songs[index].id == this.songId){ return; } // 2-1.初始化歌曲id console.log(&quot;歌曲索引：&quot;+index); this.songId = this.songs[index].id; console.log(&quot;歌曲id:&quot;+this.songId); var main = this; // 2-2.初始化歌曲url axios.get(&quot;https://autumnfish.cn/song/url?id=&quot;+this.songId) .then(function(response){ main.songUrl = response.data.data[0].url; console.log(&quot;歌曲url:&quot;+response.data.data[0].url); }).catch(function(error){}) // 2-3.初始化歌曲封面 axios.get(&quot;https://autumnfish.cn/song/detail?ids=&quot;+this.songId) .then(function(response){ main.songCover = response.data.songs[0].al.picUrl; console.log(&quot;封面url:&quot;+response.data.songs[0].al.picUrl); }) .catch(function(error){ alert(error); }) // 2-4.初始化热评信息 axios.get(&quot;https://autumnfish.cn/comment/hot?type=0&amp;amp;id=&quot;+this.songId) .then(function(response){ main.songHotComments = response.data.hotComments; console.log(response.data.hotComments); }).catch(function(error){}) }, // 3.歌曲播放状态 doPlaying_song:function(){ console.log(&quot;song播放&quot;); this.isPlaying_song = true; }, // 4.歌曲暂停状态 doPause_song:function(){ console.log(&quot;song暂停&quot;); this.isPlaying_song = false; }, // 5.播放mv playMV:function(mvId){ var main = this; axios.get(&quot;https://autumnfish.cn/mv/url?id=&quot;+mvId) .then(function(response){ console.log(&quot;mvUrl:&quot;+response.data.data.url); // 5-1.初始化mvUrl main.mvUrl = response.data.data.url; // 5-2.打开遮罩层 main.isShow_mv = true; // 5-3.暂停正在播放的歌曲 main.$refs.audio.pause(); }).catch(function(){}) }, // 6.隐藏遮罩层 hide:function(){ // 6-1.关闭遮罩层 this.isShow_mv = false; // 6-2.关闭mv this.mvUrl = &#39;&#39;; } }});" }, { "title": "html", "url": "/posts/html/", "categories": "前端, HTML", "tags": "", "date": "2022-05-04 00:00:00 +0800", "snippet": " 学习HTML，主要就是学习标签。静态页面组成元素 文字 图片 超链接 音频和视频HTML结构&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!-- 定义文档类型 默认为html5 必须在文档第一行 --&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;!-- lang表示语言，lang=&quot;en&quot;：英文，lang=&quot;zh-CN&quot;:中文 --&amp;gt;&amp;lt;head&amp;gt; 浏览器解析的特殊内容(定时刷新，网页标题，外部文件)&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; 网页的主体内容&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;标签 标签大小写不敏感 标签格式 双标签，常常可以插入其他标签 单标签，如meta标签，br标签，hr标签，link标签，img标签和input标签等等。 不可以插入其他标签 标签分类 块标签，如标题标签，p标签，div标签，hr标签，ol标签，ul标签等等在浏览器的显示效果中独占一行，并排斥其他标签效果与其位于同一行。块标签内部可以容纳其他块标签和行内标签，同时可以设置width和height 行内标签，如strong标签，em标签，a标签，span标签等等，可容纳其他行内标签，但不可以容纳块标签，同时不可以设置width和height 标签拥有自己的属性 基本属性，可以修改简单的样式&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;!-- bgcolor表示背景颜色 --&amp;gt;&amp;lt;body bgcolor=&quot;blue&quot;&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 事件属性，直接设置事件响应后的代码&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;!-- onclick表示单击(点击)事件alert是JavaScript提供的一个警告框函数可以接受任意参数，参数就是警告框提升信息 --&amp;gt; &amp;lt;body onclick=&quot;alert(&#39;卧槽&#39;)&quot;&amp;gt;请点击这里&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;head标签的子标签title标签浏览器栏目标题meta标签定义页面特殊信息供搜索引擎分析，页面关键词，页面描述信息属性1.name&amp;lt;!-- 网页关键词 --&amp;gt;&amp;lt;meta name=&quot;keywords&quot; content=&quot;前端开发,html+css&quot;/&amp;gt;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!-- 网页描述 --&amp;gt;&amp;lt;meta name=&quot;description&quot; content=&quot;学习前端技术&quot;/&amp;gt;&amp;lt;!-- 本页作者 --&amp;gt;&amp;lt;meta name=&quot;author&quot; content=&quot;flameking&quot;/&amp;gt;&amp;lt;!-- 版权声明 --&amp;gt;&amp;lt;meta name=&quot;copyright&quot; content=&quot;本站内容为原创,版权所有，禁止转载。否则必将追究法律责任。&quot;/&amp;gt;2.http-equiv：网页使用编码&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&amp;gt;&amp;lt;!-- 简写形式 --&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;/&amp;gt;3.网页自动刷新跳转&amp;lt;!-- 当前页面在6秒后会自动跳转到http://www.*.com下 很多广告网站就是用这种方法实现页面定时跳转的 --&amp;gt;&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;6;url=http://www.*.com&quot;/&amp;gt;link标签用于引入外部样式文件(CSS文件)style标签用于定义CSS样式script标签用于定义页面JavaScript代码，也可用于引入外部JavaScript文件base标签没啥实际应用的标签body标签内的常用标签标题标签h系列标签：h1~h6&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt;&amp;lt;h2&amp;gt;二级标题&amp;lt;/h2&amp;gt;&amp;lt;h3&amp;gt;三级标题&amp;lt;/h3&amp;gt;&amp;lt;h4&amp;gt;四级标题&amp;lt;/h4&amp;gt;&amp;lt;h5&amp;gt;五级标题&amp;lt;/h5&amp;gt;&amp;lt;h6&amp;gt;六级标题&amp;lt;/h6&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;段落标签会自动换行&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;古诗词&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;爱莲说&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊。自李唐来，世人甚爱牡丹。予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清，亭亭净植，可远观而不可亵玩焉。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。噫！菊之爱，陶后鲜有闻。莲之爱，同予者何人？牡丹之爱，宜乎众矣。&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;换行标签&amp;lt;br/&amp;gt; 文本标签1.粗体标签&amp;lt;strong&amp;gt;粗体&amp;lt;/strong&amp;gt;2.斜体标签&amp;lt;!-- 有三种表达 --&amp;gt;&amp;lt;i&amp;gt;斜体&amp;lt;/i&amp;gt; &amp;lt;em&amp;gt;斜体&amp;lt;/em&amp;gt; &amp;lt;!-- 因为语义性好，更常用--&amp;gt;&amp;lt;cite&amp;gt;斜体&amp;lt;/cite&amp;gt;3.上标标签&amp;lt;p&amp;gt; 2&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;=4&amp;lt;/p&amp;gt;4.下标标签&amp;lt;p&amp;gt; H&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;SO&amp;lt;sub&amp;gt;4&amp;lt;/sub&amp;gt;&amp;lt;/p&amp;gt;5.中划线标签&amp;lt;s&amp;gt;中划线&amp;lt;/s&amp;gt;6.下划线标签&amp;lt;u&amp;gt;下划线&amp;lt;/u&amp;gt;7.大字号和小字号标签&amp;lt;p&amp;gt;普通文本&amp;lt;/p&amp;gt;&amp;lt;big&amp;gt;大文本&amp;lt;/big&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;small&amp;gt;小文本&amp;lt;/small&amp;gt;水平线标签&amp;lt;hr/&amp;gt;特殊符号 空格   版权符 © 注册商标 ®div标签 语法&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; 划分HTML结构，配合CSS来整体控制某一块的样式 可以放入绝大多数其他标签，如p标签，strong标签，hr标签等。块级标签与行内标签，容器级标签和文本级标签块级标签相对于容器级标签多了一个 p 标签，行内标签相对于文本级标签少了一个 p 标签其中 img 为行内块级元素图片标签&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;见崎鸣&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;img src=&quot;https://tse4-mm.cn.bing.net/th/id/OIP-C.eu52Jg2XlqzucnzBGF81igHaNK?w=187&amp;amp;h=333&amp;amp;c=7&amp;amp;o=5&amp;amp;dpr=1.25&amp;amp;pid=1.7&quot; alt=&quot;见崎鸣&quot; title=&quot;见崎鸣&quot;/&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;1.属性解析 title：鼠标放在图片上显示(给用户看的) alt：图片无法显示会出现alt的提示文字(给浏览器看的) src：一般使用相对路径，如果文件位置改变也不会有影响2.图片格式 位图，放大缩小图片会失真 jpg：图片体积大，不支持保存透明背景，适合颜色丰富的图片 png：图片体积小，支持透明背景，不适合颜色丰富的图片，可以无损压缩以保证页面打开速度 gif：适合制作动画 矢量图，放大缩小图片不会失真 .ai .cdr .fh .swf：Flash动画 超链接 外部链接&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;超链接&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;a href=&quot;http://www.baidu.com/&quot;&amp;gt;百度&amp;lt;/a&amp;gt; &amp;lt;!--文本超链接--&amp;gt;&amp;lt;!--图片超链接 target=&quot;_blank&quot; 表示在新页面打开窗口 --&amp;gt;&amp;lt;a href=&quot;http://www.baidu.com/&quot; target=&quot;_blank&quot;&amp;gt;&amp;lt;img src=&quot;https://img2.baidu.com/it/u=3997374157,3590333969&amp;amp;fm=26&amp;amp;fmt=auto&amp;amp;gp=0.jpg&quot;/&amp;gt; &amp;lt;/a&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 内部链接 锚点链接注意：超链接被iframe框架实现内嵌框架，指在一个页面中嵌入另一个页面&amp;lt;!-- width：内嵌页面的宽度 height：长度 --&amp;gt;&amp;lt;iframe src=&quot;页面地址&quot; width=&quot;640&quot; height=&quot;100&quot; &amp;gt;&amp;lt;/iframe&amp;gt;如何应用：在内嵌窗口中打开任意链接&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;iframe&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; ul{list-style-type: none;} &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;iframe src=&quot;https://www.taobao.com/&quot; width=&quot;1529&quot; height=&quot;314&quot; name=&quot;window&quot;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Top1:&amp;lt;a href=&quot;https://www.taobao.com&quot; target=&quot;window&quot;&amp;gt;淘宝&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Top2:&amp;lt;a href=&quot;https://www.sina.com.cn&quot; target=&quot;window&quot;&amp;gt;新浪&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Top3:&amp;lt;a href=&quot;https://www.163.com&quot; target=&quot;window&quot;&amp;gt;网易&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;footer和header这两个元素通常作为文档的页眉和页脚，它们都是块内元素nav这个元素通常用来表示导航链接，它是块内元素，它本身不具有任何意义，只是标识导航链接section这个元素通常用来包含一个无意义的内容，与div类似，通常与footer、header一起使用" }, { "title": "css", "url": "/posts/css/", "categories": "前端, CSS", "tags": "", "date": "2022-05-04 00:00:00 +0800", "snippet": " Cascading Style Sheet：层叠样式表，用来控制网页外观的技术CSS引入方式 外部样式表，CSS代码单独作一文件，并在HTML文件中通过link引入&amp;lt;head&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;CSS文件路径&quot;&amp;gt;&amp;lt;/head&amp;gt; 内部样式表在style中自定义&amp;lt;head&amp;gt; &amp;lt;style text=&quot;text/css&quot;&amp;gt; div{text-align: center} &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt; 行内样式表在标签的style属性中定义选择器选用指定的标签，定义CSS样式&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; &amp;lt;!-- 元素 --&amp;gt; div{ height: 640px; /*width: 640px;*/ border-width: 30px; border-style: solid; border-color: hotpink; } &amp;lt;!-- class --&amp;gt; .out{ position: relative; left: 239.6px; right: 239.6px; } &amp;lt;!-- 后代：father下的所有div标签 --&amp;gt; #father div{ width: 800px; height: 600px; background-color: white; } &amp;lt;!-- id --&amp;gt; #away{ clear: both; } &amp;lt;!-- 群组 --&amp;gt; div,p,span,.out,#father{ color: red; } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt; 元素选择器 id，唯一标识一个标签,引用时需用#标识 class，可标记多种标签，class值相同的标签共用同一种样式，需用.标识 后代选择器 群组选择器字体样式 font-family:“宋体”，“Time New Roman”，Arial，可以定义多个，按顺序优先使用已安装的字体 字体大小：font-size:10px font-style:normal(默认)，italic(斜体)，oblique(斜体) font-weight:normal(默认)，lighter(较细)，bold(较粗)，bolder(很粗) color:red，#FBF9D0(RGB值)文本样式 首行缩进：text-indent:2倍字体像素值 水平对齐：text-align:center，left，right，对文本和图片均有效 text-decoration:none,underline，line-through，overline，去除划线效果（超链接下划线效果去除），下划线，删除线，顶划线 大小写转换：text-transform:none,uppercase,lowercase,capitalize(首字母大写) 行高：line-height:10px，有行间距的效果 字间距，单词间距：letter-spacing:10px,word-spacing:10px，一个中文汉字和一个英文字母都算一个字边框样式几乎所有标签都可以定义边框 border-width:10px border-style: none，无（边框将不存在） dashed，虚线 solid，实现 border-color一般定义用简写：boder:1px solid red 另外还包括局部边框：border-top,border-bottom,border-left,border-right列表样式list-style-type 对ol标签 decimal，（1，2，···） lower-roman，（i，iii，···） upper-roman lower-alpha，（a,b,···） upper-alpha 对ul标签 disc circle aquare 去除列表符号 ol,ul{list-style-type:none;} 自定义列表符号，ol,ul{list-style-image:url(图片路径);}表格样式 表格标题位置：caption-side:top,bottom 表格边框合并：border-collapse:collapse,separate，合并，默认 表格边框间距：border-spacing:8px图片样式1.图片大小 weight height2.图片边框边框样式3.图片对齐文本水平对齐样式，在img标签的父标签种定义才能生效4.浮动img{float:left/right}，修饰后的块可与其他块共处一行背景样式1.背景图片地址：background-image:url(图片路径) ，引入背景图片之前要先定义块的大小，至少与图片大小相同，图片才能正常显示2.图片重复：background-repeat repeat（默认） repeat-x，repeat-y（水平或垂直方向平铺） no-repeat （不平铺）3.图片位置：background-position:水平距离 垂直距离(相对于页面左上角) 像素值语法 关键词语法4.图片固定：background-attachment:scroll,fixed（图片随页面一起滚动，固定不动）5.背景颜色：background-color超链接样式超链接伪类 a:link，未访问样式 a:visited，已访问后 a:hover，鼠标经过的样式 另外它也可以定义其他标签在鼠标经过时的样式，如div:hover，img:hover a:active，鼠标点击激活时的样式鼠标样式cursor:default,pointer,text，(默认箭头样式，手状样式，I样式)自定义鼠标样式cursor:url(图片地址,通常是.cur文件)，pointer/default/textCSS盒子模型页面中的所有标签都可看成一个盒子，占据着一定的页面空间 context padding内边距：定义文本在块中的相对位置 div{padding-top:8px;padding-right:9px;padding-bottom:10px;padding-left:11px;} div{padding:8px 9px 10px 11px}，效果同上 div{padding:8px 10px}=div{padding-top:8px;padding-bottom:8px;padding-right:10px;padding-left:10px;} div{padding:8px}=div{padding-top:8px;padding-bottom:8px;padding-right:8px;padding-left:8px;} margin外边距：块与块之间的相对距离，格式同 padding border weight，height在块标签中可以生效，行内标签无法生效布局定位页面中的标签 浮动布局float:left/right 清除浮动布局clear:both,left,right 定位布局(定义顺序) position:fixed,relative,absolute,static，固定定位（相对于浏览器左上角），相对定位（相对于标签原来位置），绝对定位（相对于浏览器左上角），静态定位（默认） top bottom left right" }, { "title": "MyNetDisk-step1-与存储源建立连接", "url": "/posts/MyNetDisk-step1-%E4%B8%8E%E5%AD%98%E5%82%A8%E6%BA%90%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/", "categories": "项目, MyNetDisk", "tags": "SpringBoot", "date": "2022-05-04 00:00:00 +0800", "snippet": "存储源的类型资源分为本地存储，远程存储，云存储区分不同的存储源与不同类型存储源建立连接我们资源往往通过URL标识和定位与本地交互资源与远程交互资源与云端交互资源获取资源列表并在前端展示提供下载接口提供预览提供分享链接" }, { "title": "Spring-step5-从配置文件读取Bean信息的容器", "url": "/posts/Spring-step5-%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96Bean%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AE%B9%E5%99%A8/", "categories": "框架, Spring", "tags": "系统设计, 封装, 反射", "date": "2022-05-01 00:00:00 +0800", "snippet": "回顾到目前为止spring-bean容器也来越自动化，它能够为客户端做的事情越来越多，包括自动创建Bean对象、对象属性自动注入；我们前面说过的一个Bean容器应该具备的能力： Bean定义 Bean注册，所谓的注册就像DriveManger对数据库驱动进行注册的那样，实际就是将Bean或者与Bean直接关联的信息用容器进行保存，待要使用时就用索引（可以是名称、id、或其他任何能够唯一对应Bean的事务）取出 Bean对象创建 依赖注入目前该容器已经全部具备，但是与实际的Spring-Bean相比，它还有个地方很有违和感：客户端每次都需要依靠Java代码把BeanDefinition和PropertyValues给准备好，并且注册进入容器，但实际上这样操作比较麻烦，毕竟记住API是件非常烦人的事情，所以实际的Spring容器采用配置文件记录bean信息的方法，通过读取配置文件解析成BeanDefinition和PropertyValues，这样容器就将BeanDefinition和PropertyValues创建工作也包揽在自己手里，这样客户端的工作就更加轻松了；目标所以本step的目标就是实现读取xml配置文件，实现容器自动创建BeanDefinition和PropertyValues！当前的Bean容器可以看到客户端不用管BeanDefinition和PropertyValues的实例化，XML配置文件彻底接管了这个任务，这下我们其实可以把XML配置文件和Bean容器合并一下作为最新的容器，从客户端的角度来看只需要从Bean容器中get，而不用set了，这样客户端差不多把对象的控制权完全交给了Bean容器，也就实现了对象实例化逻辑和客户端核心业务解耦的目的，而从容器的角度来看，生产对象实例的原料由XML配置文件提供，Bean容器负责制造，整个合在一起构造了一个严谨的对象实例化工厂；怎么从原始容器——&amp;gt;期望容器当前容器，Bean定义和Bean注册还需要客户端操劳，应该为了让客户端轻松点，就让Bean容器来代劳吧；也就是说Bean容器现在要做的工作就有：Bean定义 ——&amp;gt; Bean注册 ——&amp;gt; Bean实例化 ——&amp;gt; Bean属性注入；不过在这之前得准备原料，才能准备生产得事情吧，哈哈哈，不急慢慢来！所以工作有点多啊：准备原料 ——&amp;gt; Bean定义 ——&amp;gt; Bean注册 ——&amp;gt; Bean实例化 ——&amp;gt; Bean属性注入合理规划生产所谓思考建设得时候不仅要考虑当前得情况，还要给未来留有余地，以便建设的扩展优化，所以我们是否要把所有的生产流程放在一个流水线上呢？当然不是，分部门，各司其职分而治之才是王道，因为这样各个流程不会杂糅在一起，要是针对其中一个流程做优化，也不会影响到其他的生产流程，总之生产线分解再分解就对了原料引进部门所以针对生产流程，成立专门的部门，原料引进部门专门处理XML配置文件读取，解析BeanDefinition的任务，毕竟BeanDefiniton就是我们需要的原料，下面看看原料加工厂需要做那些工作吧：给原料来源分渠道由于XML配置文件可能来自本地，classpath，或者云文件，所以实际上XML配置文件的读取是有多种策略的，因此依照策略模式，建立XML配置文件的不同读取策略public interface Resource { InputStream getInputStream() throws IOException;}public class ClassPathResource implements Resource { // 为什么要定义path和classLoader两个属性 // 1.原本让我来写，classLoader是写死的（方便客户端指定特定的classLoader，毕竟classLoader与资源类型有点关系？） // 2.path也可以直接传递给方法（延长path的生命周期？） private final String path; private ClassLoader classLoader; public ClassPathResource(String path) { this(path, (ClassLoader) null); } public ClassPathResource(String path, ClassLoader classLoader) { Assert.notNull(path, &quot;Path must not be null&quot;); this.path = path; this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader()); } @Override public InputStream getInputStream() throws IOException { InputStream is = classLoader.getResourceAsStream(path); if (is == null) { throw new FileNotFoundException( this.path + &quot; cannot be opened because it does not exist&quot;); } return is; }}public class FileSystemResource implements Resource { private final File file; private final String path; public FileSystemResource(File file) { this.file = file; this.path = file.getPath(); } public FileSystemResource(String path) { this.file = new File(path); this.path = path; } @Override public InputStream getInputStream() throws IOException { return new FileInputStream(this.file); } public final String getPath() { return this.path; }}public class UrlResource implements Resource{ private final URL url; public UrlResource(URL url) { Assert.notNull(url,&quot;URL must not be null&quot;); this.url = url; } @Override public InputStream getInputStream() throws IOException { URLConnection con = this.url.openConnection(); try { return con.getInputStream(); } catch (IOException ex){ if (con instanceof HttpURLConnection){ ((HttpURLConnection) con).disconnect(); } throw ex; } }}读取资源时首先要判断是什么类型的资源public interface ResourceLoader { /** * Pseudo URL prefix for loading from the class path: &quot;classpath:&quot; */ String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;; Resource getResource(String location);}public class DefaultResourceLoader implements ResourceLoader { @Override public Resource getResource(String location) { Assert.notNull(location, &quot;Location must not be null&quot;); if (location.startsWith(CLASSPATH_URL_PREFIX)) { return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length())); } else { try { URL url = new URL(location); return new UrlResource(url); } catch (MalformedURLException e) { return new FileSystemResource(location); } } }}从资源中解析BeanDefiniton/** * Simple interface for bean definition readers. */public interface BeanDefinitionReader { BeanDefinitionRegistry getRegistry(); ResourceLoader getResourceLoader(); void loadBeanDefinitions(Resource resource) throws BeansException; void loadBeanDefinitions(Resource... resources) throws BeansException; void loadBeanDefinitions(String location) throws BeansException;}/** * Abstract base class for bean definition readers which implement * the {@link BeanDefinitionReader} interface. */public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader { private final BeanDefinitionRegistry registry; private ResourceLoader resourceLoader; protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) { this(registry, new DefaultResourceLoader()); } public AbstractBeanDefinitionReader(BeanDefinitionRegistry registry, ResourceLoader resourceLoader) { this.registry = registry; this.resourceLoader = resourceLoader; } @Override public BeanDefinitionRegistry getRegistry() { return registry; } @Override public ResourceLoader getResourceLoader() { return resourceLoader; }}/** * Bean definition reader for XML bean definitions. */public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader { public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) { super(registry); } public XmlBeanDefinitionReader(BeanDefinitionRegistry registry, ResourceLoader resourceLoader) { super(registry, resourceLoader); } @Override public void loadBeanDefinitions(Resource resource) throws BeansException { try { try (InputStream inputStream = resource.getInputStream()) { doLoadBeanDefinitions(inputStream); } } catch (IOException | ClassNotFoundException e) { throw new BeansException(&quot;IOException parsing XML document from &quot; + resource, e); } } @Override public void loadBeanDefinitions(Resource... resources) throws BeansException { for (Resource resource : resources) { loadBeanDefinitions(resource); } } @Override public void loadBeanDefinitions(String location) throws BeansException { ResourceLoader resourceLoader = getResourceLoader(); Resource resource = resourceLoader.getResource(location); loadBeanDefinitions(resource); } protected void doLoadBeanDefinitions(InputStream inputStream) throws ClassNotFoundException { Document doc = XmlUtil.readXML(inputStream); Element root = doc.getDocumentElement(); NodeList childNodes = root.getChildNodes(); for (int i = 0; i &amp;lt; childNodes.getLength(); i++) { // 判断元素 if (!(childNodes.item(i) instanceof Element)) continue; // 判断对象 if (!&quot;bean&quot;.equals(childNodes.item(i).getNodeName())) continue; // 解析标签 Element bean = (Element) childNodes.item(i); String id = bean.getAttribute(&quot;id&quot;); String name = bean.getAttribute(&quot;name&quot;); String className = bean.getAttribute(&quot;class&quot;); // 获取 Class，方便获取类中的名称 Class&amp;lt;?&amp;gt; clazz = Class.forName(className); // 优先级 id &amp;gt; name String beanName = StrUtil.isNotEmpty(id) ? id : name; if (StrUtil.isEmpty(beanName)) { beanName = StrUtil.lowerFirst(clazz.getSimpleName()); } // 定义Bean BeanDefinition beanDefinition = new BeanDefinition(clazz); // 读取属性并填充 for (int j = 0; j &amp;lt; bean.getChildNodes().getLength(); j++) { if (!(bean.getChildNodes().item(j) instanceof Element)) continue; if (!&quot;property&quot;.equals(bean.getChildNodes().item(j).getNodeName())) continue; // 解析标签：property Element property = (Element) bean.getChildNodes().item(j); String attrName = property.getAttribute(&quot;name&quot;); String attrValue = property.getAttribute(&quot;value&quot;); String attrRef = property.getAttribute(&quot;ref&quot;); // 获取属性值：引入对象、值对象 Object value = StrUtil.isNotEmpty(attrRef) ? new BeanReference(attrRef) : attrValue; // 创建属性信息 PropertyValue propertyValue = new PropertyValue(attrName, value); beanDefinition.getPropertyValues().addPropertyValue(propertyValue); } if (getRegistry().containsBeanDefinition(beanName)) { throw new BeansException(&quot;Duplicate beanName[&quot; + beanName + &quot;] is not allowed&quot;); } // 注册 BeanDefinition getRegistry().registerBeanDefinition(beanName, beanDefinition); } }}总结像spring这样的精妙设计一定是经过无数次修改，因此对于我自己来说想要一次性就写出这么完美的设计是很难的，不过认识到自己的上限，勇敢接受自己的不足；目前我已经掌握了流程图对功能进行分解，但是真正将文字描述的功能转化成代码，还有一段路要走；不过在设计并实践的过程中：1.保证功能得到实现，不要妄想一次性达到官方那种完美的状态2.由有缺陷的代码不断精进，不断完善才是一段设计精妙的代码该有的过程，同时可以借助流程图，类图等UML工具辅助设计" }, { "title": "Spring-step4-自动注入Bean对象属性的容器", "url": "/posts/Spring-step4-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5Bean%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%B9%E5%99%A8/", "categories": "框架, Spring", "tags": "系统设计, 封装, 反射", "date": "2022-04-30 00:00:00 +0800", "snippet": "目标上个step实现了对象创建的多种策略，包括JDK反射创建和CGLIB创建，最终都是为了能够更具构造器创建对象，但是我们发现，虽然创建了对象，但是无法自动为对象属性赋值，这个step就让我们实现对象属性的自动赋值说到属性注入，你首先想到的方法是什么？反射，既然有了BeanDefinition，通过反射获取对象的field，然后直接将值赋给field，首先这个方法是正解，基本流程图：用类封装属性通过《反射注入属性流程图》，我们大致能了解从这两个步骤会有哪些东西牵涉：1.具体操作的对象——obj 对于第三点，反射注入属性首先需要对象实例存在，那么属性注入的方法操作应该放在createBean()之后；2.对象属性的名称——name 外界传入的对象的属性初始化值——value 属性注入需要名称获取Field，和初始化值value，由于这两个值需要同时使用，所以将它们封装在一个类中进行传递比较合适，这就产生了PropertyValue，又因为一个类不止一个属性，所以还需要一个类缓存所有的属性信息，这就是PropertyValues的由来3.beanClass——BeanDefinition 反射依靠Class对象，所以我们需要BeanDefinition，1.同时我们应该将PropertyValues作为BeanDefiniton的属性，毕竟PropertyValues和Class对象是需要同时使用的，2.而且BeanDefinition就是存储Bean相关的信息，属性信息当然与Bean相关，3.而且目前BeanDefinition是暴露给客户端的，由客户端控制，同时beanClass和PropertyValues应该也由客户端指定，所以PropertyValues由BeanDefinition管理理所当然类PropertyValue和PropertyValues/** * bean 属性信息 */public class PropertyValue { private final String name; private final Object value; public PropertyValue(String name, Object value) { this.name = name; this.value = value; } public String getName() { return name; } public Object getValue() { return value; }}仔细观察这个类，你会发现没有setter，也就是说没有必要暴露对外修改name和value的必要，毕竟客户端要想修改，直接覆盖就可以了public class PropertyValues { private final List&amp;lt;PropertyValue&amp;gt; propertyValueList = new ArrayList&amp;lt;&amp;gt;(); public void addPropertyValue(PropertyValue pv) { this.propertyValueList.add(pv); } /** * ArrayList类型——》数组类型，里面的数据原封不动，或许是为了防止客户端直接对propertyValueList进行操作 * @return */ public PropertyValue[] getPropertyValues() { return this.propertyValueList.toArray(new PropertyValue[0]); } public PropertyValue getPropertyValue(String propertyName) { for (PropertyValue pv : this.propertyValueList) { if (pv.getName().equals(propertyName)) { return pv; } } return null; }}这个类将propertyValueList的添加，查询都封装在了内部（唯独没有修改方法），同时提供getPropertyValues()，相当于是获取数组拷贝，避免PropertyValueList被外界直接修改，这样会更加安全属性注入方法applyPropertyValuesprotected void applyPropertyValues(String beanName, Object bean, BeanDefinition beanDefinition) { try { PropertyValues propertyValues = beanDefinition.getPropertyValues(); for (PropertyValue propertyValue : propertyValues.getPropertyValues()) { String name = propertyValue.getName(); Object value = propertyValue.getValue(); if (value instanceof BeanReference) { // A 依赖 B，获取 B 的实例化 BeanReference beanReference = (BeanReference) value; value = getBean(beanReference.getBeanName()); } // 属性填充 BeanUtil.setFieldValue(bean, name, value); } } catch (Exception e) { throw new BeansException(&quot;Error setting property values：&quot; + beanName); } }BeanUtil的作用是区别不同类型的属性，比如属性的类型可能是数组，map，List，获取自定义的引用类型，这些都要分别处理同时我们发现有这么一个东西：BeanReference，我们知道Bean的属性可能也是待实例化的Bean，而BeanReference就是为了区别出这些Bean从而递归创建这些Bean的依赖，当然我们也可以让客户端直接先创建出依赖Bean，即先从容器中获取，就像下面这样：// 3. UserService 设置属性[uId、userDao] PropertyValues propertyValues = new PropertyValues(); propertyValues.addPropertyValue(new PropertyValue(&quot;uId&quot;, &quot;10001&quot;)); propertyValues.addPropertyValue(new PropertyValue(&quot;userDao&quot;, beanFactory.getBean(&quot;userDao&quot;))); // 4. UserService 注入bean BeanDefinition beanDefinition = new BeanDefinition(UserService.class, propertyValues); beanFactory.registerBeanDefinition(&quot;userService&quot;, beanDefinition); // 5. UserService 获取bean UserService userService = (UserService) beanFactory.getBean(&quot;userService&quot;);但这样存在一个功能上的差距，即对象之间的依赖关系控制在了客户端手里，而实际上作为Bean容器，它应该主导这个功能，毕竟这个功能很复杂，由容器来处理，客户端会轻松很多BeanDefinition这么一来依赖注入的功能基本就完成了，下面看看BeanDefinition的变化：public class BeanDefinition { private Class beanClass; private PropertyValues propertyValues; public BeanDefinition(Class beanClass) { this.beanClass = beanClass; this.propertyValues = new PropertyValues(); } public BeanDefinition(Class beanClass, PropertyValues propertyValues) { this.beanClass = beanClass; this.propertyValues = propertyValues != null ? propertyValues : new PropertyValues(); } public Class getBeanClass() { return beanClass; } public void setBeanClass(Class beanClass) { this.beanClass = beanClass; } public PropertyValues getPropertyValues() { return propertyValues; } public void setPropertyValues(PropertyValues propertyValues) { this.propertyValues = propertyValues; }}提供了依赖注入需要的构造器，其他的就每什么特别的了总体设计流程图" }, { "title": "Spring-step3-能选择正确构造器的容器", "url": "/posts/Spring-step3-%E8%83%BD%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%AE%B9%E5%99%A8/", "categories": "框架, Spring", "tags": "设计模式, CGLIB", "date": "2022-04-22 00:00:00 +0800", "snippet": "目标由于上一步骤我们将对象创建的方式限制在用无参构造函数创建，因为Class.newInstance()，本质上是调用无参构造函数，那么对于没有无参构造的类就会报错，所以step3就是为了实现：使得没有无参构造器的类也能正常创建如何让容器具备选择正确构造器的能力为了让对象能够正常创建，而非默认由无参构造器创建，因此需要选择正确的构造器器；如何选择正确构造器？对于重载的构造器，我们根据参数类型和参数顺序就能判断，那么参数哪里来呢？对于容器来说，它可以自主创建对象，但是它毕竟也不知道该使用哪个构造器，或者说究竟使用哪个构造器应该由用户创建，我们只需把判断构造器的逻辑封装进容器即可；我们知道容器对外提供了提取对象的方法：getBean()，我们可以由它传入参数将构造器选择逻辑封装进容器JDK反射获取public class JDKInitializeBeanStrategy implements InitializeBeanStrategy{ @Override public Object initializeBean(BeanDefinition beanDefinition, Object[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException { // 1.获取Class对象 Class beanClass = beanDefinition.getBeanClass(); // 2.获取构造器组 Constructor[] constructors = beanClass.getDeclaredConstructors(); // 3.遍历构造器组，选择合适的构造器 if (args != null) { for (Constructor constructor : constructors) { // 4.获取方法参数列表 Class&amp;lt;?&amp;gt;[] parameterTypes = constructor.getParameterTypes(); // 5.比较参数长度 if (parameterTypes.length == args.length) { int i; // 6.比较参数类型是否相同 for (i = 0; i &amp;lt; parameterTypes.length; i++) { if (parameterTypes[i] != args[i].getClass()) { break; } } // 7.如果参数长度相同，类型相同，说明构造器匹配 if (i == parameterTypes.length) { try { // 传入参数，创建bean对象，并返回 return constructor.newInstance(args); } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } } } } // 8.args为null Constructor constructor = null; // 9.获取无参构造函数 constructor = beanClass.getDeclaredConstructor(); // 10.返回bean对象 return constructor.newInstance(null); }抽取构造器选择逻辑protected Object createBeanInstance(BeanDefinition beanDefinition, Object... args) { // 抽取构造器选择逻辑 Constructor constructor = null; // 1.获取Class对象 Class beanClass = beanDefinition.getBeanClass(); if (args == null) { try { constructor = beanClass.getDeclaredConstructor(); } catch (NoSuchMethodException e) { e.printStackTrace(); } } else { // 2.获取构造器组 Constructor[] constructors = beanClass.getDeclaredConstructors(); // 3.遍历构造器组，选择合适的构造器 for (Constructor cons : constructors) { // 4.获取方法参数列表 Class&amp;lt;?&amp;gt;[] parameterTypes = cons.getParameterTypes(); // 5.比较参数长度 if (parameterTypes.length == args.length) { int i; // 6.比较参数类型是否相同 for (i = 0; i &amp;lt; parameterTypes.length; i++) { if (parameterTypes[i] != args[i].getClass()) { break; } } // 7.如果参数长度相同，类型相同，说明构造器匹配 if (i == parameterTypes.length) { constructor = cons; } } } } return initializeBeanStrategy.initializeBean(constructor, beanDefinition, args); }CGLIB动态创建对象（不熟）public class CglibInitializeBeanStrategy implements InitializeBeanStrategy{ @Override public Object initializeBean(Constructor constructor, BeanDefinition beanDefinition, Object[] args) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(beanDefinition.getBeanClass()); enhancer.setCallback(new NoOp() { @Override public int hashCode() { return super.hashCode(); } }); if (constructor.getParameterTypes().length == 0){ return enhancer.create(); } return enhancer.create(constructor.getParameterTypes(),args); }}总结：步骤流程图扩展通过一步步优化扩展，我们的spring容器已经具备了自主创建对象的能力，但是相比正统的Spring容器，我们的容器还无法对对象属性进行赋值，那么下一步就让我们解决对象属性注入的问题吧" }, { "title": "Spring-step2-掌握Bean对象自动创建的容器", "url": "/posts/Spring-step2-%E6%8E%8C%E6%8F%A1Bean%E5%AF%B9%E8%B1%A1%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AE%B9%E5%99%A8/", "categories": "框架, Spring", "tags": "设计模式, 系统设计", "date": "2022-04-22 00:00:00 +0800", "snippet": "回顾step1step1我们实现了一个非常单纯的Bean容器—BeanFactory，里面提供方法registerBeanDefinition()，getBean()，并且维护一个ConcurrentHashMap的实例，用于存储Bean对象这个容器提供的Bean的注册、获取功能，但对用户而言，用户却需要自行创建、自行注册、同时自行提取；这与我们最初的设想：将创建对象的控制权从用户手中夺回，因此我们应该让容器自行创建对象才是，那么如何实现呢？掌控对象控制权我们知道将创建对象和业务功能解耦，可以使用工厂设计模式或者抽象工厂，但是由于对象的类型不确定，我们不可能在未知对象类型的情况下new出对象，所以说用户必须告诉我们的工厂我们该实例化哪个类型？用户不能自己创建，又必须告诉工厂创建什么，大家想到了什么？对，就是反射！通过反射获取Class对象就可以创建实例对象，用户只要告诉我么类型的全类名就可以了；所以现在用户和容器的关系应该是下面这样的：而原来容器维护的是实例对象，现在维护的应该是Class对象，这样容器就能真正掌握对象的创建权力，这样什么时候需要对象，容器就可以为其创建，或者单例对象所以我们的BeanDefinition看起来应该是这样的：public class BeanDefinition{ private Class beanClass; public BeanDefinition(){} public BeanDefinition(Class beanClass){ this.beanClass = beanClass; } public void setBeanClass(Class beanClass){ this.beanClass = beanClass; } public Class getBeanClass(Class beanClass){ return this.beanClass }}拆分容器在step1中我们总结过Spring Ioc容器的主要工作，包括Bean定义、Bean注册、Bean初始化、依赖注入；而现在这些功能都被耦合在同一个BeanFactory类中，这样不便于后期扩展，为了提供更好的可扩展性，我们应该将其分解，一个类做一件事；经分析我们发现，容器的真正起作用时是当我们需要从中获取Bean对象的时候，那么容器需要能够自己创建Bean对象，并且暂存起来，那么我们看下BeanFactory的继承链是如何的：然后我们在以getBean为目标，看看它是如何执行的：可见因为getBean的需要，诞生了getBeanDefinition和createBean方法，并且我们发现这次的容器增加了单例对象缓存，使得不是每次getBean都重新创建对象，AbstractBeanFactory确定了getBean()的执行框架，使得该容器会默认返回对象的单例，同样单例缓存功能也实现在另一个类DefaultSingletonRegistry中，这样每个功能之间保持独立，类与类之间实现解耦，整个框架更容易扩展完整的类图为什么无论是BeanDefinition容器还是singletonObject容器都要用final修饰呢？因为这样让属性更安全，因为被final修饰后，容器就很难被替换，也就是说属性只能初始化一次；当前容器存在的问题先看一段代码，这段代码测试单例缓存是否成功：public class DefaultSingletonBeanRegistryTest { @Test public void testGetSingleton() { // 我的bean容器 DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); // 创建我的BeanDefinition BeanDefinition beanDefinition = new BeanDefinition(UserService.class); //BeanDefinition注册进容器 beanFactory.registerBeanDefinition(&quot;userService&quot;, beanDefinition); //获取Bean对象 UserService userService = (UserService)beanFactory.getBean(&quot;userService&quot;); //再次获取Bean对象 Object anotherUserService = beanFactory.getBean(&quot;userService&quot;); // 判断两者是否为同一对象 System.out.println(userService == anotherUserService); }}问题：1.很明显，相较于step1我们的容器确实能够自己创建对象，并且还能进行单例缓存，但是对于用户来说，依然需要手动注册Definition，也就是说还是要由程序主动管理对象的生成2.每次取出Bean需要用户显式进行强转，有没有如泛型那样容器帮我们自动强转的方法3.容器创建Bean，使用反射的newInstance()方法，而它的底层实际上调用的是无参构造函数，所以如果面对这样的一个类：public class UserService { private String name; public UserService(String name) { this.name = name; } public void queryUserInfo(){ System.out.println(&quot;查询用户信息&quot;); }}就会报错，因为它压根就没有无参构造函数那么如何解决这些问题呢？Spring-step3继续" }, { "title": "编译原理", "url": "/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/", "categories": "计算机科学与技术, 编译原理", "tags": "正则表达式", "date": "2022-04-21 00:00:00 +0800", "snippet": "编译与计算机程序设计语言的关系编译：将高级语言翻译成机器语言或汇编语言的过程编译器和解释器的区别：1.编译器整个将源程序翻译成目标程序，而解释器以源程序作为输入，每输入一条语句就执行一条语句，不生产目标程序2.相比解释器编译器经过一次编译就不需要再编译，直接以目标程序运行即可编译器在语言处理系统中的位置翻译过程一条句子的翻译过程：1.词法分析划分词性，如名词、动词、形容词2.语法分析划分短语，依靠词法分析，如名词短语、动词短语、介词短语3.语义分析最后根据语法分析，总结各短语的关系，得到一条句子的语义（中间表示形式），如某人干了某事，即名词短语和动词短语的练习语法制导翻译即编译器过程的逻辑实现，在实际中可能是多个步骤在一起实现，比如语法分析、语义分析、中间代码生成就被放在一起实现，而这个技术也称为语法制导翻译词法分析1.这个过程概括来讲就是：高级语言的单词 –&amp;gt; 对应的机内表示（也被称为token），为了区别这些机内表示，token的结构如下：token：(种别码，属性值)，这很容易理解，种别码表示哪类词性，比如名词或是动词，而属性值就是这具体指哪个名词或是动词，而高级语言具体存在那些token，如下图：语法分析文法：短语组合规则，即语法规则，毕竟短语是由各种单词构造的，所以文法指的就是各种token构造成语法的规则，或者说称它为生成语法的函数语法分析：从词法分析器输出的token序列识别短语并构造语法分析树的过程，语法分析树描述了句子的语法结构语义分析高级语言大概分为声明语句和可执行语句，声明语句声明属性和对象，而属性和对象作为可执行语句的操作单元，重新赋值给新的属性或对象，而这些对象就属于token中的标识符，可见表示符是声明语句和可执行语句的重要组成部分所以语义分析的第一任务是提取这些属性，并且记录它们的种属（比如简单变量、数组、函数或者叫过程）、类型、值、作用域、位置、长度语义分析的第二任务是语义检查中间表示形式1.表现方式：三地址码和语法结构树三地址码：由三地址指令序列组成，每条指令最多有三个操作数，所以被称为三地址码，三地址指令形如：三地址指令的数据结构表示分为：四元式（类似汇编语句，前缀表达式）、三元式，间接三元式四元式形如：如此可见，中间表示形式已经非常像汇编代码，而目标代码生成器最终的任务就是为变量或对象选择合适的寄存器2.代码优化，分为机器无关代码优化器和机器相关代码优化器，在语言处理系统中所处的位置如下：词法语法分析基本概念字母表：有穷字符集合，这个字符包括大小写字母，数字，标点符号等，用∑表示，其中用ε表示空串字母表的基本运算：乘积、n次幂、正闭包、克林闭包正闭包：长度为正数的串的集合，是无穷的，不断的进行递归的幂运算得到的集合克林闭包与正闭包：克林闭包 equal （正闭包 并 空字母表）串：克林闭包的每个元素，都被称为一个串串的长度串运算：连接，幂运算文法定义首先看下图：该图表示的是自然语言中句子的文法我们可以看到文法是由一条条产生式构成，如果我们把产生式作为函数，那么产生式左端就是函数参数，右端就是函数输出如果把函数也作为属性，那么它表示就是产生规则，我们丢入原料就会输出产物，而把函数作为参数传给函数，就会形成更大的规则，甚至的递归的因而上图表示的是句子的产生规则其中未用尖括号的部分称为语言的基本符号（函数的最终输出），有括号的称为语法成分（函数）终结符和非终结符非终结符：表示语法成分的变量终结符：语言的基本符号，也叫token以上两者统称文法符号两者关系：产生式产生式左右端均是串，串是由终结符和非终结符组合而成，而产生式左端至少包含一个非终结符开始符号文法最终的输出符号约定终结符：非终结符：文法符号（以上两者均可以表示）、终结符号串、文法符号串：语言的定义推导和规约推导，按照产生式向右推导，最终得到只有终结符的式子，规约相反，向左推导，直至产生式左端是开始符号通过这两个方法可以判断一个词串是否是该语言的句子句型和句子S =&amp;gt;* x，即开始符号经过若干推导步骤得到的产物就可称为句型，而只有终结符的句型才称为句子短语、直接短语、句柄看下文：如何区别三者语言所有句子构成的集合就被称为语言，即L(G) = {w|S =&amp;gt;* w，w∈VT* }，其中VT* 表示终结符的克林闭包，w表示终结符号串文法解决了无穷语言的有穷表示，函数的递归表示不也可以实现这样的效果吗，这也是我为什么把文法比作函数的原因，也可以对应到MIT-Scheme流和表的定义，两者都有递归性质文法的分类四种文法之间的关系：正则文法正如我们用L(G)表示语言，其中G表示文法，同时也可以用L(r)表示，其中r，就是正则表达式1.正则文法（3型文法）包括右线性文法和左线性文法，即在上下文无关文法的基础上约束产生式右端要么是终结符号串，要么是非终结符和终结符号串的组合（文法符号串），而非终结符的位置则决定了是右线性文法还是左线性文法2.正则文法示例： 使用正则文法 其实正则文法和正则表达式很像，只不过多了空串和表达式引用，其他如*（0个或多个字符）， （或）等符号的意思是相同的 3.正则表达式，是正则文法的更加紧凑易读的写法，其实就是我们平时应用的正则表达式，而且这个*，其实就集合运算中的克林闭包；见下图： 4.运算符优先级：* 克林闭包 &amp;gt; 连接 &amp;gt; 5.正则定义为了方便我们可以给正则表达式命名，并在其他正则表达式中使用这些标识符，构造一个更加复杂的正则表达式例子：6.正则文法转正则表达式基本思路：1.根据正则文法G构造正则表达式联立方程组2.解联立方程组，求等价的正则表达式r3.求得结果 最终结果是 S=r的形式如何构造方程组：然后代入消元，解联立方程组，最终得到S=r的形式CFG（上下文无关文法）的分析树上下文无关文法相比正则文法使用更多，受到更多的研究并且相比正则文法能更熟练的表达句子，但是程序中的大多数单词可以用正则文法表示，下面是分析树的相关概念：句型的短语二义性文法一个文法可以为一个句子生成多颗分析树，则该句子存在二义性文法，二义性文法是不好的，我们可能需要引入非终结符来消除二义性，以便编译器能准确的翻译句子，或者定义一组规则，避免二义性文法，如：else与离它最近的if组合二义性文法的判定给定一个充分条件，满足这个条件则说明该文法无二义性，否则不能说明是否存在二义性有穷自动机（FA）它是一个数学模型，模型示意图如下：用一句话表示这个模型就是，有穷控制器根据读头指向的输入，和当前状态，判断是否进入下一状态有穷自动机可以通过转换图表示FA接收的语言对于串A，如果FA存在对应于串A的从初始状态到某个终止状态的转换序列，则称串A被FA接收，有FA所能接收的所有串组成的集合称为FA接收的语言，记为L(M)最长子串匹配原则简单来说就是匹配到最远的终止状态FA的分类FA又可以分为DFA、NFA，其中DFA表示确定的有穷自动机，即每读取一次输入，只会有一个输出，而NFA则可能有多个，相比于DFA，NFA更加直观，但程序实现更加复杂，DFA则相对容易DFA的算法表示：s = s0; // s0表示初始状态c = nextChar(); // 读取下个输入while(c != eof){ s = move(s,c) // ð函数，更新当前状态 c = nextChar();}if(s在F中) return &quot;yes&quot;; // F代表终止状态集else return &quot;no&quot;;如上，s0初始状态和F终止状态集是已知的，句子作为输入正则文法、正则表达式、NFA、DFA之间的关系正则文法 &amp;lt;==&amp;gt; 正则表达式 &amp;lt;==&amp;gt; NFA &amp;lt;==&amp;gt; DFA我们最终需要的是DFA，因为其用程序更容易实现，因而更适合构造我们的词法分析器，而在求DFA时一般按照上面的顺序一步步得到DFA，但其实目前从正则表示式也可以很容易直接构造DFA，例如有如下的正则表达式： (a b)* abb，我们可以把它分成四个部分，第一部分：(a b)* ，第二部分：a，第三部分：b，第四部分：b，按照从左往右的顺序，每连接一个部分就是一个新的句型，所以把每个句型作为FA模型中的状态，根据输入，判断是否应该转入下一句型，或是回溯到原来的句型，这样就能一步步构造出DFA了 NFA ==&amp;gt; DFA上例中我们可以发现，DFA中每个状态都是由NFA中的状态构成的集合，而每接收一个输入，会作用到集合中每个状态，从而又形成新的状态集合词法分析器的错误处理和错误恢复词法分析器检查单词的步骤：词法错误检测 ==&amp;gt; 调用错误处理程序 ==&amp;gt; 错误处理 ==&amp;gt; 错误恢复策略1.首先词法错误检测：如果当前状态遇到了不可能的输入，调用调用错误处理程序2.错误处理程序查找已扫描的字符串中最后一个于某终态对应的字符，如找到，将该字符和前面的字符识别为一个正确的单词，未找到则报错，并启用错误恢复策略3.错误恢复策略删除输入，知道遇到正确的字符开启下一轮错误检测，直至扫描完整个输入语法分析自顶向下的分析概述从分析树的根节点（文法开始符号）向叶节点（一般时文法终结符）方向构造分析树，其实就是之前判断一个词串是否是文法的句子，从开始符号推导得到终结字符串的过程，也就是S ==&amp;gt;* w的过程如何构造分析树：给定文法如下文法①E --&amp;gt; E + E②E --&amp;gt; E * E③E --&amp;gt; (E)④E --&amp;gt; id输入id + (id + id)其中我们发现每一步推导我么都需要做两个选择 用该非终结符的哪个候选式进行替换 替换当前句型中的哪个非终结符其实以我们上帝视角来看这个词串其实很简单，把最左边的id，作为一个句型，（id+id）作为一个句型，就可发现它符合产生式：E –&amp;gt; E + E，然后（id + id）本身其实就符合产生式 E –&amp;gt; E + E，所以还是很简单的，计算机不像我们可以看到整个输入，计算机只能一个个读入推导的方式 最左推导 最右推导两种推导产生的语法分析树具有唯一性自顶向下分析法总是采用最左推导为什么会需要预测分析器在自顶向下的递归下降分析法（计算机采用的自顶向下分析法）中，计算机根据输入选择候选式，如果该候选式不合适，就有必要回溯选择其他候选式，但回溯使得计算效率降低，所以我们通过预测分析器避免回溯，简单来说如果能够预测正确的候选式，就不会发生回溯了（听起来其实有点扯，什么叫做能够预测出正确式子，总之不急，慢慢来，继续学习下面的内容）预测分析我们前面也提到过计算机不像人能提前看到后面的输入，它只能一个个读入输入，而预测分析器中提到的向前看k个输入符号估计就是为了能模仿人类这种分析的方式文法转换不是所有文法适合自顶向下分析法，所以就存在文法转换，将不合适的转换成合适的回溯存在的例子：即句型存在公共前缀，容器出现回溯，如果前者不合适就需要回溯选择下一个，这种情况的解决办法是提取左公因子另外如果有形如：A –&amp;gt; Aα 的文法，对于计算机很容易陷入无限循环，而这种文法被称为左递归文法，如下：消除直接左递归基本上是套公式，如图：消除间接左递归通过代入消元，将间接左递归转换成直接左递归，如下例：" }, { "title": "Spring-step1-Bean容器的雏形", "url": "/posts/Spring-step1-Bean%E5%AE%B9%E5%99%A8%E7%9A%84%E9%9B%8F%E5%BD%A2/", "categories": "框架, Spring", "tags": "设计模式", "date": "2022-04-19 00:00:00 +0800", "snippet": "Spring 容器是什么？作为一名 Java 工程师，在工作中少不了接触 Spring，我对它最大的印象就是：只需要在类上面标注几个注解，像 @Component，@Service，@Controller 就再也不用去操心这些 Bean 对象的创建，使用的时候它们就已经创建好了。所以在我眼里 Spring 容器就是一个大的对象工厂。实际上：Spring 包含并管理应用对象的配置和生命周期，你可以配置你的每个 Bean 对象是如何被创建的，这些 Bean 在创建时可以是一个单独的实例 or 每次都生成一个新的实例，以及它们是如何相互构建和使用的。在 Spring 容器中，被管理的 Bean 对象并不是直接存在容器中，它会被拆解保存到 Bean 的定义中，然后由 Spring 容器统一进行装配，最终我们就可以使用到实例化后的对象了。目标定义一个简单的 Spring 容器，用于定义、存放和获取 Bean 对象。在实际Spring中，Spring IoC容器做的主要工作分为 Bean定义 Bean注册，所谓的注册就像DriveManger对数据库驱动进行注册的那样，实际就是将Bean或者与Bean直接关联的信息用容器进行保存，待要使用时就用索引（可以是名称、id、或其他任何能够唯一对应Bean的事务）取出 Bean对象创建 依赖注入我们为什么会需要Spring Ioc1.在了解到Spring Ioc的功能时，我又会有这样的问题：问题1，为什么Spring Ioc要按照Bean定义、Bean注册、Bean对象创建、依赖注入的流程去管理Bean；问题2，我们最初选择使用Spring IoC容器是为了什么？首先解答问题2： 举一个古老的例子public class UserService{ private UserDao userDao = new UserOracleDao(); // private UserDao userDao = new UserMysqlDao(); // private UserDao userDao = new UserSqlServerDao(); .....}我们与数据库交互的接口会随着数据库的改变而改变，这导致每次数据库发生变化，我们就需要修改代码，但当程序中有大量这样的代码，修改的成本就会很大；因而除了设置接口，我们还应该让客户能够主导我们的程序，也就是说要使用UserDao的哪一个实现由客户决定，于是：public class UserFactory { private static UserDao userDao; static { InputStream inputStream = UserFactory.class.getClassLoader().getResourceAsStream(&quot;application.properties&quot;); Properties prop = new Properties(); try { prop.load(inputStream); } catch (IOException e) { e.printStackTrace(); } String userDaoClassName = prop.getProperty(&quot;userDao&quot;); try { Class&amp;lt;?&amp;gt; clazz = Class.forName(userDaoClassName); userDao = (UserDao)clazz.newInstance(); } catch (Exception e) { System.out.println(&quot;类不存在&quot;); e.printStackTrace(); } } public static UserDao getUserDao() { return userDao; }}这样通过读取外界配置文件，就能实现要使用哪一个UserDao由用户自己决定，其实SpringIoc就相当于一个大大的工厂类，它帮助我们创建对象，注入对象，将对对象的控制权完全掌握在自己手里；避免了业务代码和创建对象耦合2.对于第二个问题，首先为什么要对Bean定义Bean定义，即对Bean重新定义，由于容器内部管理的Bean可能是不同类型的，同时我们还会对Bean做各种初始化，因此重新定义为统一的类是合理的然后是Bean注册，将每个Bean打好标记，并存入容器前两步做好后，为什么使用这些对象我们就的对其初始化，同时在需要使用Bean对象的地方注入step1程序类图缺陷1.在这一阶段最明显的问题就是：我们需要自己创建对象并注册到容器中，那么如何让容器能够自己创建Bean，定义Bean、注册Bean呢？答案是反射，我们都知道获取Class对象有三种方式，例如：String.class，str.getClass()，Class.forName();显然最后一种方式是目前我们用的上的，也就是说，我们想要实例化哪个Bean，只要获取它的全类名就可以了，那么怎么获取到全类名呢？是配置文件、注解、还是说有什么其他的办法？下一章节细讲！" }, { "title": "MIT-scheme", "url": "/posts/MIT-scheme/", "categories": "编程语言, MIT-scheme", "tags": "", "date": "2022-04-11 00:00:00 +0800", "snippet": "把MIT-scheme当作计算器使用1.每个表达式d都由()圈住，当跳出最外层()时，会在前端输出值。2.表达式之间可以嵌套，表达式形如(操作符 参数 参数 ...)，而这种表达式也被称为S-表达式3.每个操作符实际是个函数，既然MIT-scheme可以当作计算器使用，那么它也支持基本四大运算符，加、减、乘、除，分别对应+、-、*、/4.练习练习 1使用Scheme解释器计算下列式子：1.(1+39) * (53-45)2.(1020 / 39) + (45 * 2)3.求和：39, 48, 72, 23, 914.求平均值：39, 48, 72, 23, 91（结果取为浮点数）解答：1.(* (+ 1 39) (+ 53 45))2.(+ (/ 1020 39) (* 45 2))3.(+ 39 48 72 23 91)4.(exact-&amp;gt;inexact (/ (+ 39 48 72 23 91) 5)) exact-&amp;gt;inexact 分数-&amp;gt;浮点数5.指数函数exp和对数函数log两者的底数都是e，只不过目前我不知道如何在scheme中表示e6.expt，用来计算x的y次幂例如 (expt 4 1/2)，代表4的开平方数据结构练习1使用cons来构建在前端表现为如下形式的数据结构。1.(&quot;hi&quot; . &quot;everybody&quot;) (cons &quot;hi&quot; &quot;everybody&quot;)2.(0) (cons 0 &#39;())3.(1 10 . 100)4.(1 10 100) (cons 1 (cons 10 100))5.(#\\I &quot;saw&quot; 3 &quot;girls&quot;) (cons #\\I (cons &quot;saw&quot; (cons 3 (cons &quot;girls&quot; &#39;()))))6.(&quot;Sum of&quot; (1 2 3 4) &quot;is&quot; 10) (cons &quot;Sum of&quot; (cons (cons 1 (cons 2 (cons 3 (cons 4 &#39;())))) (cons &quot;is&quot; (cons 10 &#39;()))))1.cons单元cons单元由两部分构成，car和cdr，结构如下图：也就是说一个cons单元由两个内存单元，并且这两个内存单元存的均是地址，指向真实值的地址，所以cons单元可以理解为两个指针car、cdr组成的数据结构通常用cons构造cons单元，形如(cons 1 2) =&amp;gt; (1 . 2)由于car，和cdr存的是指针，因而它们可以指向任意类型的值另外(cons 1 2)表达式构造了一个cons单元，而cons单元实际是一块内存，因而它的返回值是一个地址，这也代表cons单元可以互相嵌套或者说进行串联2.表表是Cons单元通过用cdr部分连接到下一个Cons单元的开头实现的。这个定义显然具有递归性，即表(cons 1 表)，用图表示如下：其中&#39;()表示空表，就算数据仅由一个Cons单元组成，只要它的cdr单元是’()，那它就是一个表。在练习1中2、4、5、6均是表结构3.原子不使用Cons单元的数据结构称为原子（atom）。数字，字符，字符串，向量和空表’()都是原子。’()既是原子，又是表。4.引用所有的记号都会依据Scheme的求值规则求值：所有记号都会从最内层的括号依次向外层括号求值，且最外层括号返回的值将作为S-表达式的值。而引用能够阻止记号被求值，形如(quote (+ 1 2)),将会返回(+ 1 2)，而不是3，而quote一般简写为 &#39;，(quote (+ 1 2)) == ‘(+ 1 2)。**实际上MIT-Scheme用()表示空表，不过在程序中表示空表应该用&#39;()，显然&#39;(1, 2, 3, 4)则代表(1, 2, 3, 4)表。5.list函数list函数的存在使得表的构建变得简单（代码编写更简单）如练习1中所示，(“Sum of” (1 2 3 4) “is” 10)用cons构造是这样的：(cons “Sum of” (cons (cons 1 (cons 2 (cons 3 (cons 4 ‘())))) (cons “is” (cons 10 ‘()))))，但是如果用list函数，它是这样的：(list “Sum of” ‘(1 2 3 4) “is” 10)也就是说list接收任意数量的参数，并能将其构造串联成表6.car函数，cdr函数见名知意，分别是获取cons单元的car部分和cdr部分，如果是串联的cons单元，car获取的是第一个cons单元的car部分，而cdr获取的是第一个cons单元的cdr部分，也就是后面的整个串联的部分函数1.define和set!使用define来将一个符号与一个值绑定。可以通过这个操作符定义例如数、字符、表、函数等任何类型的全局参数。形如 (define sig value)2.自定义函数的两种方式 用lambda定义过程(define hello (lambda (name) (string-append &quot;hello &quot; name &quot;!&quot;)))这里的调用很想Java中的lambda表达式，(args) -&amp;gt; {method body}，只不过没有 -&amp;gt;，也许Java就是借鉴的scheme也说不定 函数的短定义形式(define (hello name) (string-append &quot;hello &quot; name &quot;!&quot;))函数的短定义与函数的调用格式非常相像，并且注意函数体可以是多个S—表达式3.define 定义全局变量; 定义全局变量name(define name &quot;chezscheme&quot;); 定义函数(define hello (lambda (name) (string-append &quot;hello &quot; name &quot;!&quot;))); 调用函数(hello name)4.define和set!的区别define定义的变量只在define所在的scope中可见，一个典型例子就是：在函数中define的变量在函数外部是无法访问的而set!定义的变量才是真正的全局变量eq?、eqv?、equal?都只接收两个参数，但三者有小小的区别，eq?比较地址值；eqv?适合比较数字（按照值和类型进行比较，如1+2和2+1相等，但3和3.0不同，因为类型不同）；equal?适合比较表和字符串等类似的序列and、or 接收任意数量的参数，但这两者不等同于C语言或Java中的&amp;amp;&amp;amp;和   ，但却继承了它们的短路特性 这两个操作符都会对传入的参数挨个求值，and遇到#f返回，否则返回最后一个参数，or遇到非#f返回，否则返回最后一个参数比较运算符=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt;=这些操作符允许传入任意数量的参数，只要参数传入的顺序符合操作符的语义，则返回#t，否则返回#f分支语句1.if语句形如：(if predicate then_value else_value)2.cond语句Java或者C语言中的switch语句，形如：(cond (predicate_1 clauses_1) (predicate_2 clauses_2) ...... (predicate_n clauses_n) (else clauses_else))(define (fee age) (cond ((or (&amp;lt;= age 3) (&amp;gt;= age 65)) 0) ((&amp;lt;= 4 age 6) 0.5) ((&amp;lt;= 7 age 12) 1.0) ((&amp;lt;= 13 age 15) 1.5) ((&amp;lt;= 16 age 18) 1.8) (else 2.0)))在clauses中可以写任意数量的表达式，但最终会返回最后一条表达式；不知道scheme中有没有return语句，这相当于return语句只能出现在语句最后了啊！let定义局部变量实际上，let表达式只是lambda表达式的一个语法糖：(let ((p1 v1) (p2 v2) ...) exp1 exp2 ...);⇒((lambda (p1 p2 ...) exp1 exp2 ...) v1 v2)p是变量，v是给p赋的值，或者说，v绑定给p尾递归1.尾递归于递归递归虽然可读性很强，但有两个明显的缺点：①占用内存（方法占用内存栈）②效率低（方法调用开销，要等待方法返回值）而尾递归参数中用一个来存最终的结果，最终结果出来的时候就直接返回了；因此在效率上是要比普通递归要好的，实际上尾递归就是循环命名let和letrec命名let就是let定义有了名字，形如：(define (fact-let n) (let loop((n1 n) (p n)) ; 1 (if (= n1 1) p (let ((m (- n1 1))) (loop m (* p m)))))) ; 2letrec和let很相似，但letrec能将一个过程（lambda定义的）与一个参数绑定（其实就相当定义了一个函数），形如：(define (fact-letrec n) (letrec ((iter (lambda (n1 p) (if (= n1 1) p (let ((m (- n1 1))) (iter m (* p m))))))) ; * (iter n n)))(fact-letrec 1000)流式计算; 构建一个以整数1为起点的无穷整数流(define (integers-from n) (cons-stream n (integers-from (+ n 1)))); 流s1(define s1 (integers-from 1)); 流s2(define s2 (integers-from 2)); 获取指定索引值下的流中的元素(define (nth-stream n s) (if (= n 0) (head s) (nth-stream (- n 1) (tail s)))); 获取索引为1000000的流的元素(nth-stream 1000000 s1); map流（对流的每个元素进行处理，最后返回流）(define (scale-stream stream factor) (stream-map (lambda (x) (* x factor)) stream))(nth-stream 0 (scale-stream s1 4)); 合并流(define (add-streams s1 s2) (cond ((empty-stream? s1) s2) ((empty-stream? s2) s1) (else (cons-stream (+ (head s1) (head s2)) (add-streams (tail s1) (tail s2)))))); Fibonacci 的流式计算(define fibs (cons-stream 0 (cons-stream 1 (add-streams (tail fibs) fibs))))(nth-stream 4 fibs)" }, { "title": "Stream API 设计原理浅析", "url": "/posts/Stream-API-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/", "categories": "编程语言, Java", "tags": "函数式接口, lambda表达式, 匿名类", "date": "2022-04-09 00:00:00 +0800", "snippet": "Stream API 基本执行流程如何理解stage首先我们们看看抽象类ReferencePipeline的继承链ReferencePipeline 实现Stream接口，实现了各个Stream API 操作，同时继承了PipelineHelper，根据JDK的描述，PipelineHelper是一个执行 Stream pipelines的helper，它能够捕获所以Stream相关的信息（意思是里面定义了可以获取到Stream信息的方法，不过都是都是抽象方法，具体都交由它的子类AbstractPipeline和ReferencePipeline实现了），所以实际上ReferencePipeline包含了所有Stream的信息和操作，而在Stream中用stage来描述一个完整的操作（中间操作、结束操作等等），所以其实Stream可看作是ReferencePipeline的一个实例，然而源码也确实是这么干的。正如下图：中间操作的stage初始化做了什么以peek()为例，由于中间操作的各个实现都在ReferencePipeline中，如下：另外中间操作的初始化会记录上个stage，上图stage的构造，this指的就是上个stage也就是upstream，之所以this是上个stage，是因为每个中间操作以上个stage进行调用，所以this自然指的是上个stage，而在代码中上个stage用previousStage表示下面介绍Stream API:Stream API 分两大类，中间操作和结束操作 中间操作：中间操作的返回值依然是Stream对象，也就是一个stage，中间操作又分为无状态操作和有状态操作 无状态操作如：filter、map等，即元素的操作只与自身相关，与其他元素无关 有状态操作如：sorted、limit、distinct等，即元素的操作与其他元素关联，例如sorted，元素与其他元素比较才能确定自己的位置 结束操作：返回值不再是Stream对象，它会触发之前的中间操作，正如“无状态中间操作的初始化”所述，最初的初始化只是记录操作，并未真正执行，只有在遇到结束操作时才会触发，结束操作又分短路操作和非短路操作 短路操作指不用处理所有元素就能返回结果，如findFirst 非短路操作则必须处理完所有元素才能返回结果，如collect 在介绍一下ReferencePipeline的三大静态内部类：这三大内部类都继承了ReferencePipeline以如下的Stream API 为例：list.stream().filter(e -&amp;gt; e.startsWith(&quot;A&quot;)).sorted((c1,c2) -&amp;gt; c1.length() - c2.length()).collect(Collectors.toList());List.stream()会被实例化为Head对象，.filter()会被实例化为StatelessOp对象，.sorted()会被实例化为StatefulOp对象链接stage上图“AbstractPipeline的stage属性”中，每个stage用previousStage保存upstream，这就形成了一条反向链表，把每个stage作为链表中的node的话，就有下图：链接SinkStream API 通过Sink链记录各个操作的顺序，而每个Sink记录了各个操作传递的lambda表达式；前面所过结束操作会触发中间操作的实际执行，实际上Sink的链接也是由结束操作触发的，毕竟先要确定操作的执行顺序然后才会正式执行操作，以collect()为例：我们进入了AbstractPipeline的wrapAndCopyInto()，这个方法方法返回Sink，并且内部调用了copyInto()而copyInto需要接收Sink类型的参数，而它传入了wrapSink()，我们进入它，发现它正是在链接Sink也就是说对于Sink链我们有下图：对比stage链和Sink链，我们发现Head是没有Sink的，终止操作也没有Sink，而每个Sink用downstream记录下个stage的Sink，到这就对应上我们最开始的那张图“Stream API基本执行流程”Sink链的执行前面说过Sink链接完成就准备执行了，我们关注AbstractPipeline#copyInto()函数，它接收一个Sink参数，这个参数由wrapAndCopyInto()传入，而传入的就是经过链接后的Sink链头，所以进入copyInto()，如下图：最后我们研究&amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? super T, A, R&amp;gt; collector);发现，其中T，也就是Stream&amp;lt;T&amp;gt;中的T，代表的是Stream中元素的类型，而A实际是Sink类型，R实际就是collect返回值类型到此整个Stream API的执行力流程就分析完毕了。如果让自己来设计Stream API在研究Stream API时会发现一个很奇怪很有意思的现象，在调用Stream API时，按理应该按照函数的语义执行，例如filter就应该执行过滤的操作，然而实际上，这些API的实现并没有如它语义样立即执行，而是将操作剥离交给了Sink，而它真正做的其实是生成了流结构（可以将其与链表类比）而将这些操作剥离之后，就形成了一整套有序的处理流的办法也就是Sink链这样就从最开始的将整个数据集统一处理到后面的foreach，一个个的在Sink链中处理；而从建模来看，我们把操作再集中，形成一整套的新的处理办法，对数据集进行操作，从而减少了重复遍历，类似一个电子组件，把微小的改变某个状态的多个这样的组件封装成一个新的组件从而达到我们的目的，因为我们的目的就是为了得到被这些操作统统处理之后的结果其中涉及到惰性求值（延迟计算）的技巧：程序中事件发生的逻辑顺序与机器中事件发生的实际顺序解耦开来，我们并没有让机器按照事物的逻辑顺序来了。这也就是我们最开始提到的很奇怪很有意思的现象，这种技巧能再一定程度上缓解机器的执行压力。正如一个盒子我们知道输入，也大概猜的出输出，只需要按需拉取结果就行了总结1.Sink链的链接和执行都是在结束操作中完成的2.stage实例化的同时也完成了执行操作的记录，通过lambda表达式传递给Sink，并由accept()记录，在这里其实用到了闭包的技术，也就是lambda作为参数其生命周期本应再函数执行结束后就结束，但因为被匿名类拷贝，赋值给了内部的私有成员也就是downStream，它的生命周期也因此得到了延长" }, { "title": "场景化二叉树遍历", "url": "/posts/%E5%9C%BA%E6%99%AF%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/", "categories": "算法与数据结构, 二叉树", "tags": "二叉树", "date": "2022-03-28 00:00:00 +0800", "snippet": "前言对于一道抽象的题目，将它放入实际的场景可以说是一个非常好的帮助理解的方式，对于二叉树的遍历方式，有前序遍历，中序遍历，后序遍历；用递归的方式求解这很容易，但是如果使用迭代的方式就有点抽象了，所以下面以中序遍历为例，讲讲如何设计它的迭代求解；场景再现现在有个迷宫，这个迷宫的结构其实就是一个二叉树，入口从根节点开始，迷宫的鸟瞰图如下：现在由我们自主设计的机器人，它每次选择二叉路口是都会优先选择左边（中序遍历优先遍历左子树–&amp;gt;节点–&amp;gt;右子树），碰壁后就会回到上一个路口，然后往右走，如果右边依然碰壁，说明这个路口是死路，所以回到上上个路口，当然每当第二次回到路口我们一定往右，并且机器人需要加一次由（输出节点的值）；好了，场景已经设计成功，下面就是将思路转变为代码代码1.首先是大框架：先一直走左，然后碰壁回到上一个路口才往右；显然我们的记录自己走过的路才知道怎么回去，于是机器人会在地图上记录下自己每次走过的路口，当遇到墙壁，我们就回到最近经过的路口，也就是上一个路口，并且加油，显然数据结构应该使用栈；public List&amp;lt;Integer&amp;gt; solution(TreeNode root){ // 1.我们的地图 Stack&amp;lt;TreeNode&amp;gt; stack = new Stack(); // 2.遍历的顺序 List&amp;lt;Integer&amp;gt; valList = new ArrayList&amp;lt;&amp;gt;(); // 3.路口是通的，优先往左 if(root != null){ // 4.记录经过的路口，方便下次回来 stack.push(root); // 5.往左寻找下一个路口 root = root.left; }else{ // 6.此路不通，回到地图上记录的最近经过的路口 root = stack.pop(); // 7.加一次油 valList.add(root.val); // 8.往右寻找路口 root = root.right; }}2.此时我们还不能到达重点，我们要一直重复先走左再走右的行为，才能最终到达终点，所以应该来个循环，不过条件是怎么样的呢？试想每次碰壁回头，说明该路口走不到终点，所以机器人在这个路口画了一个叉叉（出栈）；当机器人到达重点所以路口应该都已经画了叉叉（栈为空）；而终点后面没有路了（root == null）,这两个条件满足机器人就判断它真的到终点了；public List&amp;lt;Integer&amp;gt; solution(TreeNode root){ // 1.我们的地图 Stack&amp;lt;TreeNode&amp;gt; stack = new Stack(); // 2.遍历的顺序 List&amp;lt;Integer&amp;gt; valList = new ArrayList&amp;lt;&amp;gt;(); while(root != null || !stack.empty()){ // 3.路口是通的，优先往左 if(root != null){ // 4.记录经过的路口，方便下次回来 stack.push(root); // 5.往左寻找下一个路口 root = root.left; }else{ // 6.此路不通，回到地图上记录的最近经过的路口 root = stack.pop(); // 7.加一次油 valList.add(root.val); // 8.往右寻找路口 root = root.right; } } return valList;}" }, { "title": "Spring和SpringBoot常用注解", "url": "/posts/Spring%E5%92%8CSpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/", "categories": "框架, Spring", "tags": "注解", "date": "2022-03-25 00:00:00 +0800", "snippet": "SpringBoot自动配置相关注解@Import使用@Value(“${property}”)读取简单的配置信息@Value(&quot;${name}&quot;)String name;JPA相关注解使用@Table标注表名@Entity@Table(&quot;name = person&quot;)public class Person{ private String name; private Integer age; private Boolean gender;}表名一致性，如大小写，下划线请看：JPA映射数据库mysql表名,字段名大小写转化,下划线分割.JPA中自动使用@Table(name = “userTab”)后自动将表名、列名添加了下划线的问题" }, { "title": "我学二分查找遇到的坑与解决的办法", "url": "/posts/%E6%88%91%E5%AD%A6%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E7%9A%84%E5%8A%9E%E6%B3%95/", "categories": "算法与数据结构, 二分查找", "tags": "二分查找", "date": "2022-03-24 00:00:00 +0800", "snippet": "前言 本文聚焦最简单的二分查找，集中讨论那些我们不曾注意的问题，解开二分查找不简单的一面，在本文中笔者将带你重新认识二分查找引子 有数量为n的硬币，和一个天平，已知其中有一个假币，且假币比真币轻，请找出这枚假币我记得这种题目是在我小学遇到过的，那时候虽然不知道什么二分查找法，但脑袋一偏自然也能想到：把硬币两半分，假币就在轻的一堆，然后不断的分成均匀的两堆，最后总能找出假币，这么看来二分查找似乎是一种很常识的东西，对！它确实简单，如果要一个人手写快排，他可能不一定能写得出来，但要他写二分查找，那他肯定行！下面是常见的一种二分查找的 demo：public int search(int[] arr, int target){ int left = 0, right = arr.length-1; while (left &amp;lt;= right){ int mid = left+(right-left&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (arr[mid] &amp;lt; target){ left = mid+1; }else if (arr[mid] &amp;gt; target){ right = mid-1; } } return -1; }我就经常这样写，不过每次我都有几个地方拿不准： right = arr.length - 1 or right = arr.length while (left &amp;lt; right) or while (left &amp;lt;= right) mid = (left + right) / 2，mid = (left + right) &amp;gt;&amp;gt; 1 or mid = left + (right - left) / 2，这三种写法有什么区别？ mid = left + (right - left ) / 2 or mid = left + (right - left + 1) / 2 left = mid + 1 or left = mid，right = mid - 1 or right = mid 😮欸？被我这么一提，你是不是也发现事情好像根本没那么简单？！😮😁没事，下面跟着笔者一起来探讨，看看这二分查找到底是个什么妖怪？😁概念须知搜索区间可以说做二分查找这类的题目一定要有区间的概念，所谓的搜素区间就是我们指定的查找范围，也就是 left 和 right 之间的这段。而且随着我们不停的二分，搜索区间将会被不断分割并缩小直到找出目标数据或者搜索区间为空。这里先提一下：一定要让你的搜索区间能够正常缩小，否则会产生严重的问题！判空条件也就是 while 里面的条件判断，当搜索区间为空时循环跳出，对于不同的判空条件有以下三种情况： while(left &amp;lt;= right) left == right+1，跳出循环，此种情况下左右边界值也会被取到，搜索区间相当于 [left，right] while(left &amp;lt; right) left == right，循环跳出，搜索区间相当于 [left，right) while(left &amp;lt; right-1) left == right-1，循环跳出，搜索区间相当于 [left，right-1)，这个情况其实是我总结出来的一种技巧，对解决一种问题非常有用，在这容许笔者先卖个关子，后续会为你揭晓从这几种情况来看，判空条件决定了每次你进行搜索的有效区间，请看下面： 判空条件 搜索区间 while(left &amp;lt;= right) [left，right] while(left &amp;lt; right) [left，right) while(left &amp;lt; right-1) [left，right-1) 向下取整、向零取整 整数除法 / 右移运算 » 向零取整 向下取整 例如：(-4-5) ÷ 2 = -4.5，向零取整等于-4，向下取整等于-5验证：System.out.printf(&quot;整数除法%d，右移运算%d&quot;,(-4-5)/2, (-4-5)&amp;gt;&amp;gt;1);测试结果：整数除法-4，右移运算-5如何正确的搭配回到我们文章开头最初的写法，请稍稍思考下面的问题： 一定要这么写吗？ 我可以随意组合吗？ 随意组合后可能会出现什么问题？public int search(int[] arr, int target){ int left = 0, right = arr.length-1; while (left &amp;lt;= right){ int mid = left+(right-left&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (target &amp;gt; arr[mid]){ left = mid+1; }else if (target &amp;lt; arr[mid]){ right = mid-1; } } return -1; } 这段程序是为了在一个给出的搜索区间中找出目标数据，下面我们从头至尾分析：1.为什么是 left &amp;lt;= right前面已经说了，判空条件决定了你的搜索区间，也就是此时我们的搜索区间是 [0，arr.length-1]，假设你要选择左闭右开的搜索区间，也就是[0，arr.length-1)，那么当搜索区间缩小至 [arr.length-1，arr.length-1) 时，循环跳出，但有效数据 arr[arr.length-1] 还没来得及与 target 进行比较，显然这样的程序存在隐患，它并不完美。所以你可以选择修改判空条件为 left &amp;lt;= right，但你也可以选择加个补丁，就像下面这样：public class BinarySearch { public int search(int[] arr, int target){ int left = 0, right = arr.length-1; while (left &amp;lt; right){ int mid = left+(right-left&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (target &amp;gt; arr[mid]){ left = mid+1; }else if (target &amp;lt; arr[mid]){ right = mid-1; } }// 补丁：防止忽略本该比较的数据 if (arr[left] == target) return left; return -1; }}public class BinarySearchTest { public static void main(String[] args) { int[] nums = {9, 13, 17, 19, 25}; int[] target = {7, 9, 10, 13, 17, 19, 22, 25, 28}; BinarySearch binarySearch = new BinarySearch(); for (int i=0; i&amp;lt;target.length; ++i){ System.out.println(&quot;index：&quot; + binarySearch.search(nums, target[i])); } }}测试结果index：-1index：0index：-1index：1index：2index：3index：-1index：4index：-12.为什么是 mid = left+(right-left»1) ，mid = left+(right-left+1»1) 可以吗？ &amp;gt;&amp;gt; 与 / 只在数值为负值时会有区别，正数并没有区别 left+(right-left) 能在一定程度上避免因 (left+right) 过大而导致的数值溢出 当 right-left = 1 时，left+(right-left » 1) = left，left+(right-left+1 » 1) = right，下面笔者将给出一个示例告诉你后者的危险在哪？public class BinarySearch { public int search(int[] arr, int target){ int left = 0, right = arr.length-1; while (left &amp;lt; right){ int mid = left+(right-left+1&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (target &amp;gt; arr[mid]){ left = mid+1; }else if (target &amp;lt; arr[mid]){ right = mid-1; } } // 补丁：防止忽略本该比较的数据 if (arr[left] == target) return left; return -1; }}public class BinarySearchTest { public static void main(String[] args) { int[] nums = {19, 25}; int[] target = {28}; BinarySearch binarySearch = new BinarySearch(); for (int i=0; i&amp;lt;target.length; ++i){ System.out.println(&quot;index：&quot; + binarySearch.search(nums, target[i])); } }}测试结果：Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2 at cn.edu.huas.st.flameking.binarysearch.BinarySearch.search(BinarySearch.java:19) at cn.edu.huas.st.flameking.binarysearch.BinarySearchTest.main(BinarySearchTest.java:15)显然发生了数组越界，让我们来看看哪个地方出错了：可见在第一轮循环中，left = mid+1 = 2，已经超出了数组的有效访问范围。那么该如何解决呢？第一：如源程序所示：left = mid+1，right = mid-1，因此区间的分割和缩小并没有问题第二：判空条件产生的有效数据忽略比较的问题也因为打上了补丁得到了解决那么我们再对数组越界产生的问题打个补丁不就行了，如下：public class BinarySearch { public int search(int[] arr, int target){ int left = 0, right = arr.length-1; while (left &amp;lt; right){ int mid = left+(right-left+1&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (target &amp;gt; arr[mid]){ left = mid+1; }else if (target &amp;lt; arr[mid]){ right = mid-1; } }// 补丁：对数组越界做出反应 if (left &amp;gt;= arr.length) return -1;// 补丁：防止忽略本该比较的数据 if (arr[left] == target) return left; return -1; }}读者可以利用上面给出的测试数据进行测试，当然也可以自己设计测试数据进行验证。3.为什么是 left = mid+1，right = mid-1在判空条件的约束下我们的实际搜索区间是[left，right]，对于不合格的mid应当抛弃，如果left = mid 或者 right = mid 抑或是左右边界均没有正常取舍，就会导致区间不正常分割而达不到缩小的目的，这样会陷入一种很严重的错误：死循环。那么该如何解决呢？很简单，让区间能够正常缩小就行了。下面对三种情况依次进行解决：public class BinarySearch { /** * left = mid * @param arr * @param target * @return */ public int search(int[] arr, int target){ int left = 0, right = arr.length-1;// 3. 避免左右边界相等但没有找出目标，并由于左边界不正常分割导致死循环，所以要在 left=right 的时候及时跳出循环 while (left &amp;lt; right){// 2. 因为此时右边界正常缩小所以 让 mid = (left+right+1)/2 = right int mid = left+(right-left+1&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (target &amp;gt; arr[mid]){/** 1. 左边界分割错误 也就是说如果发生： left = （mid = （left+right）/2） 就会陷入死循环,那么我们让它不等于就 Ok 了,同时让它在边界相等时跳出循环 */ left = mid; }else if (target &amp;lt; arr[mid]){ right = mid-1; } }// 4. 对没来的及进行比较的数据，进行补充比较 return arr[left] == target ? left : -1; }}public class BinarySearch { /** * right = mid * @param arr * @param target * @return */ public int search(int[] arr, int target){// 4. 如果你不想打上麻烦的补丁，right = arr.length 这样在 [left，right) 的搜索区间下就不会忽略掉有效数据了 int left = 0, right = arr.length;// 2. 避免 left = right 没有退出循环的情况 while (left &amp;lt; right){ int mid = left+(right-left&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (target &amp;gt; arr[mid]){ left = mid+1; }else if (target &amp;lt; arr[mid]){/** 1. 右边界分割错误 由于左边界分割正常，同时 当 right-left=1 时 （left+right）/2 = left，所以可能出现的错误情况应当是 left = right但还没有找出目标数据而陷入死循环 */ right = mid; } }// 3. 补丁：比较在循环中被忽略的数据// return arr[left] == target ? left : -1; return -1; }}public class BinarySearch { /** * left = mid * right = mid * @param arr * @param target * @return */ public int search(int[] arr, int target){ int left = 0, right = arr.length-1;// 2. 在 right-left = 1 这个危险的时候尽快跳出循环 while (left &amp;lt; right-1){ int mid = left+(right-left&amp;gt;&amp;gt;1); if (target == arr[mid]){ return mid; }else if (target &amp;gt; arr[mid]){ left = mid; }else if (target &amp;lt; arr[mid]){ right = mid; } }/** 1. 经过前面的分析，我们发现死循环发生的时机都是在 right-left=1 or left = right 时发生所以我们及时在两种情况发生之前退出，从根本上消除死循环（😊这就是前面提到的技巧哦😜） */ if (arr[left] == target) return left; else if(arr[right] == target) return right; else return -1; }}好了三种情况笔者都已经分析好，并且给出了参考程序，当然解法有很多种就看你怎么组合，只要解决我列出的下列情况就 Ok 了常见错误清单 常见错误 出现的时机 有效数据被忽略比较 right = length-1， while(left &amp;lt; right) 数组越界访问 right = length，while(left &amp;lt;= right) or right = length-1，mid = left + (right-left+1 » 1)，left = mid+1 死循环 right - left = 1，left=mid，right=mid 基本上只要你规避了以上问题，并且保持区间正常缩小，程序应该就足够 nice 了，==不过也许还有笔者没有遇到的问题，读者可以在下方评论提醒笔者，笔者将会对新问题提出解决方案，并更新本篇文章==。至于上面的问题该怎么解决，程序中我已经写出了详细的分析过程，并给出了测试数据，如果读者不相信我的测试数据也可以自行设计测试数据。看到这想必你对这节开头提出的问题已经有答案了吧！ 一定要这么写吗？ 当然不是 我可以随意组合吗？ 是的，我们可以随意组合，只要解决我上面总结的错误即可 随意组合后可能会出现什么问题？ 请看上面的表格【常见错误清单】 应用场景那么上面的分析就是全部了，既然考前复习做好了，那么就该上考场了，请运用你刚刚学到的知识解决下面的问题，笔者将会给出参考程序寻找左右侧边界原题链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/题目：在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？示例 1：输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]示例 2：输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]示例 3：输入：nums = [], target = 0输出：[-1,-1]提示：0 &amp;lt;= nums.length &amp;lt;= 105-109 &amp;lt;= nums[i] &amp;lt;= 109nums 是一个非递减数组-109 &amp;lt;= target &amp;lt;= 109参考程序class Solution { public int[] searchRange(int[] nums, int target) { int[] border = {-1, -1};// 避免数组为空时，越界访问了 if (nums.length == 0) return border;// 3. right = nums.lenght 避免打补丁（对忽略数据进行比较） int left = 0, right = nums.length;// 寻找左边界// 2. 在 left = right 时及时跳出循环 while (left &amp;lt; right){ int mid = left + (right-left&amp;gt;&amp;gt;1); if(target == nums[mid]){/** 1. 由于我们寻找的是左边界，所以并不能立即返回，应当保持当前的值，并让区间向左缩小， 但在 right = left，nums[right] = target 时定会出现死循环 */ right = mid; }else if(target &amp;gt; nums[mid]){ left = mid+1; }else if(target &amp;lt; nums[mid]){ right = mid-1; } } if(left != nums.length) border[0] = nums[left] == target ? left : -1;// 寻找右边界 /** 注意别忘记重新初始化 */ left = 0; right = nums.length-1;// 2. 避免 right - left = 1 的情况 因为这样容易死循环 while (left &amp;lt; right-1){ int mid = left + (right-left&amp;gt;&amp;gt;1); if(target == nums[mid]){/** 1. 由于我们寻找的是右边界，所以并不能立即返回，应当保持当前的值，并让区间向右缩小， 但在 right = left+1，nums[left] = target 或者 right = left，nums[left] = target 时定会出现死循环 */ left = mid; }else if(target &amp;gt; nums[mid]){ left = mid+1; }else if(target &amp;lt; nums[mid]){ right = mid-1; } } if(nums[right] == target) border[1] = right; else if(nums[left] == target) border[1] = left; return border; }}在单调递增序列a中，查找 &amp;gt;= x 的数中最小的一个（即x或x的后继）public class BinarySearch { public int search(int[] a, int x){ if (a.length == 0) return -1; int left = 0, right = a.length-1;// 2. 为了避免 left == right 我们应当在这时跳出循环 所以应当是 left &amp;lt; right while (left &amp;lt; right){ int mid = left+(right-left&amp;gt;&amp;gt;1); if (x == a[mid]){/** 1. 由于我们要找 &amp;gt;= x 的最小一个，也许这个并不是最小的，所以我们并不能立即返回，而应当向左缩小区间但这样当 left = right 时程序会进入死循环*/ right = mid; }else if (x &amp;gt; a[mid]){ left = mid+1; }else if (x &amp;lt; a[mid]){ right = mid; } } if (a[left] &amp;gt;= x) return a[left]; return -1; }}public class BinarySearchTest { public static void main(String[] args) { int[] nums = {1, 3, 4, 6, 8, 10}; int[] target = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; BinarySearch binarySearch = new BinarySearch(); for (int i=0; i&amp;lt;target.length; ++i){ System.out.printf(&quot;%d的后继是：%d\\n&quot;, target[i], binarySearch.search(nums, target[i])); } }}测试结果：0的后继是：11的后继是：12的后继是：33的后继是：34的后继是：45的后继是：66的后继是：67的后继是：88的后继是：89的后继是：1010的后继是：1011的后继是：-1在单调递增序列a中，查找 &amp;lt;= x 的数中最大的一个（即x或x的前驱）public class BinarySearch { public int search(int[] a, int x){ if (a.length == 0) return -1; int left = 0, right = a.length-1;// 3. 为了避免 left == right 我们应当在这时跳出循环 所以应当是 left &amp;lt; right while (left &amp;lt; right){// 2. 解决 left = right-1 的死循环问题，那么我们就让 mid != left，等于 right 就行了 int mid = left+(right-left+1&amp;gt;&amp;gt;1); if (x == a[mid]){/** 1. 由于我们要找 &amp;lt;= x 的最大一个，也许这个并不是最大的，所以我们并不能立即返回，而应当向右缩小区间但这样当 left = right or left = right-1 时程序会进入死循环*/ left = mid; }else if (x &amp;gt; a[mid]){ left = mid; }else if (x &amp;lt; a[mid]){ right = mid-1; } } if (a[left] &amp;lt;= x) return a[left]; return -1; }}public class BinarySearchTest { public static void main(String[] args) { int[] nums = {1, 4, 6, 8, 10}; int[] target = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; BinarySearch binarySearch = new BinarySearch(); for (int i=0; i&amp;lt;target.length; ++i){ System.out.printf(&quot;%d的前驱是：%d\\n&quot;, target[i], binarySearch.search(nums, target[i])); } }}测试结果：0的前驱是：-11的前驱是：12的前驱是：13的前驱是：14的前驱是：45的前驱是：46的前驱是：67的前驱是：68的前驱是：89的前驱是：810的前驱是：1011的前驱是：10再次提一下之前提过的小技巧，因为真的很有用，如果害怕处理死循环的问题，那么可以在 right-left = 1 时跳出循环，达到消除死循环的目的，因为经总结死循环往往在 right-left = 1 或 right = left 也就是搜索区间只剩两个数亦或者是只剩一个数的时候出现，跳出循环之后你就可以对左右边界单独进行分析。尾声通常只要掌握其中一种标准匹配就已经 OK 了,比如文章开头给出的 demo，但如果想要深入了解二分查找，想要轻松解决二分查找的变式问题，那么就应该对不同写法，不同组合的二分查找有详细的了解，甚至是自己能够随意组合，就像一个魔方无论它怎么打乱，最后都能还原" }, { "title": "Java集合", "url": "/posts/Java%E9%9B%86%E5%90%88/", "categories": "编程语言, Java", "tags": "", "date": "2022-03-24 00:00:00 +0800", "snippet": "List接口ArrayList1.ArrayList扩容机制 以无参构造器创建的是一个空的数组，当添加第一个元素时，才会分配容量，并且容量为10 扩容机制源码没什么好深究的，因为肯定需要重新new一个容量更大的数组，然后将源数据复制进去" }, { "title": "JPA的小demo", "url": "/posts/JPA%E7%9A%84%E5%B0%8Fdemo/", "categories": "框架, JPA", "tags": "反射, 注解", "date": "2022-03-23 00:00:00 +0800", "snippet": "目标 模拟JPA的实现方式，封装底层的jdbc操作，让开发者专心于Java程序的编写而不是SQL语句 搞情况JPA与jdbc的关系，摸清Java程序与数据库交互的具体流程 练习注解与反射的配合使用方法1.抛入需要的jar包&amp;lt;!-- JdbcTemplate依赖的jar包，使用JdbcTemplate简化jdbc操作 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.9&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- Druid数据源 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.17&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- MySQL数据库驱动 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.8&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- 单元测试 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;2.要实现一个JPA规范，我们应该明白JPA处于Java程序与数据库交互的哪个阶段：Java程序 –&amp;gt; JPA –&amp;gt; JDBC –&amp;gt; 数据库驱动 –&amp;gt; 数据库；而JPA具体的作用就是建立实体类与表之间的关系，通过操作实体类就能将数据持久化到数据库，节省我们书写SQL的时间，以及将数据库字段与实体类属性一一对应进行转化的繁杂，大大提升开发效率；3.从第二点，JPA所处的阶段位于Java程序和JDBC之间，所以JPA终究还是要靠jdbc与数据库进行连接，实际上它的底层依然要依靠jdbc，所以我们才引入了JdbcTemplate；4.由于底层还是用了JDBC，所以写代码之前我们应该对JDBC与数据库建立连接的具体流程有个大概的流程，请看下图：5.所以底层我们还是需要写SQL，当然有了这个demo我们就只要写一次SQL，以后遇到相同的操作就不用再写一遍SQL了，没错JPA的其中一个优势就体现在这了；代码①@Table注解/** * 为实体类指定与它关联的表的名称 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Table { String value() default &quot;&quot;;}②准备实体类@Table(&quot;t_user&quot;)public class User { private Integer id; private String name; private Integer age; public User() { } public User(Integer id, String name, Integer age) { this.id = id; this.name = name; this.age = age; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;; }}③准备数据表CREATE TABLE t_user(`id` INT NOT NULL auto_increment,`name` VARCHAR(50),`age` TINYINT,PRIMARY KEY(id))④BaseDao 泛型类，这个里面就定义了具体的数据库操作public class BaseDao&amp;lt;T&amp;gt; { private final JdbcTemplate jdbcTemplate = JdbcUtil.getJdbcTemplate(); private Class&amp;lt;T&amp;gt; actualTypeArgument; private final HashMap&amp;lt;String, Object&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;(50); public BaseDao() { // 0.获取实际类型参数 ParameterizedType genericSuperclass = (ParameterizedType)this.getClass().getGenericSuperclass(); Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); actualTypeArgument = (Class&amp;lt;T&amp;gt;) actualTypeArguments[0]; } public int add(T obj){ // 1.获取实际类型参数的属性名和属性值，并存放在hashMap中（由于使用的泛型，显然我们需要使用反射获取运行时类型对象，以此获取对象的属性名和属性个数） Field[] declaredFields = actualTypeArgument.getDeclaredFields(); for (Field field : declaredFields) { // 通过反射获取对象的私有属性值，因而应该关闭Java语言的安全检查 field.setAccessible(true); try { hashMap.put(field.getName(), field.get(obj)); } catch (IllegalAccessException e) { e.printStackTrace(); } } // 2.拼装sql StringBuffer sqlBuffer1 = new StringBuffer(&quot;insert into &quot; + actualTypeArgument.getAnnotation(Table.class).value() + &quot;(&quot;); StringBuffer sqlBuffer2 = new StringBuffer(&quot;values(&quot;); // 3.获取属性名的集合 Object[] keyArray = hashMap.keySet().toArray(); // 4.获取属性个数 int size = hashMap.size(); for (int i = 0; i &amp;lt; size-1; i++) { sqlBuffer1.append(&quot;`&quot;+keyArray[i]+&quot;`&quot;+&quot;,&quot;); sqlBuffer2.append(&quot;?,&quot;); } sqlBuffer1.append(&quot;`&quot;+keyArray[size-1]+&quot;`)&quot;); sqlBuffer2.append(&quot;?)&quot;); String sql = sqlBuffer1.toString()+sqlBuffer2.toString(); // 5.获取对象属性值的集合 Object[] values = hashMap.values().toArray(); // 6.执行sql return jdbcTemplate.update(sql, values); }}使用时，让XXXDao继承BaseDao就可以使用了；结论与发现1.这个小demo只实现了insert操作，像创建数据库，查询、更新、删除都可以通过这种方式实现的2.核心代码ParameterizedType genericSuperclass = (ParameterizedType)this.getClass().getGenericSuperclass();Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments();actualTypeArgument = (Class&amp;lt;T&amp;gt;) actualTypeArguments[0];这段代码展示了：如何获取父类的实际类型参数的Class对象，比如UserDao extends BaseDao&amp;lt;User&amp;gt;，实际类型参数就是User；要做到这步我们需要做到下面几步：①首先我们要在父类中获取子类的Class对象，众所周知子类在初始化时实际上隐式的将this对象传递给了父类，所以在父类构造器中使用的this实际上是子类对象，这样我们就可以通过this.getClass()获取到②如何获取泛型超类，Class.getGenericSuperclass()就可以获取③如何获取实际类型参数的Class对象，ParameterizedType.getActualTypeArguments()，这一这是一个Type类型的数组，而Class类是它的实现类，而里面装的就是实际类型参数的Class对象，第一个数组元素就是我们要的啦" }, { "title": "Junit的小demo", "url": "/posts/Junit%E7%9A%84%E5%B0%8Fdemo/", "categories": "框架, Junit", "tags": "反射, 注解", "date": "2022-03-21 00:00:00 +0800", "snippet": "目标 模拟Junit中@Test、@Before、@After的实现方式 练习自定注解实现 探索注解的底层实现方法1.定义自定义注解@MyTest、@MyBefore、@MyAfter@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyTest {}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyBefore {}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyAfter {}2.使用注解public class MainClass { @MyTest public void testSave(){ System.out.println(&quot;保存成功&quot;); } @MyTest public void testUpdate(){ System.out.println(&quot;更新成功&quot;); } @MyBefore public void init(){ System.out.println(&quot;初始化&quot;); } @MyAfter public void destroy(){ System.out.println(&quot;销毁&quot;); }}3.读取并执行测试方法public class TestClass { public static void main(String[] args) throws IllegalAccessException, InstantiationException, InvocationTargetException { // 1.获取测试类的Class对象和实例对象 Class&amp;lt;MainClass&amp;gt; clazz = MainClass.class; MainClass instance = clazz.newInstance(); // 2.获取带有注解的方法 Method[] methods = clazz.getMethods(); // 3.并用map存储 Map&amp;lt;String, List&amp;lt;Method&amp;gt;&amp;gt; annotationListMap = new HashMap&amp;lt;&amp;gt;(20); // 4.遍历方法 for (Method method : methods) { // 5.获取方法上的注解信息 Annotation[] methodAnnotations = method.getAnnotations(); // 6.遍历注解 for (Annotation annotation : methodAnnotations){ // 7.获取带了这种注解的方法数组，注意：由于注解底层有jdk动态代理实现接口的实现，所以getClass是获取不到原类型的类对象的 // 但Annotation提供了annotationType()方法用于获取注解的类型对象 List&amp;lt;Method&amp;gt; methodList = annotationListMap.get(annotation.annotationType().getName()); // 8.如果数组不存在，新创建 if (methodList == null){ List&amp;lt;Method&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); // 并将方法对象存入数组 list.add(method); // 将注解：方法数组的键值对存入map annotationListMap.put(annotation.annotationType().getName(), list); }else { // 9.如果存在，直接在方法数组中添加该方法 methodList.add(method); } } } // 10.执行方法 List&amp;lt;Method&amp;gt; myBeforeList = annotationListMap.get(MyBefore.class.getName()); List&amp;lt;Method&amp;gt; myTestList = annotationListMap.get(MyTest.class.getName()); List&amp;lt;Method&amp;gt; myAfterList = annotationListMap.get(MyAfter.class.getName()); // 11.按流程执行方法 for (Method method1 : myTestList){ // 首先执行MyBefore标注的方法 for (Method method0 : myBeforeList){ method0.invoke(instance, (Object[]) null); } // 再执行MyTest标注的方法 method1.invoke(instance, (Object[]) null); // 最后执行带MyAfter标注的方法 for (Method method2 : myAfterList){ method2.invoke(instance, (Object[]) null); } } }}结论与发现1.注解本质上是接口，而注解内部属性会在底层被解析为同名的抽象方法2.Method对象通过getAnnotations()获取的注解对象是jdk代理对象，因为jdk底层通过动态代理对注解做了实现，所以通过getClass(),我们获取不到Class&amp;lt;? extends Annotation&amp;gt;的类对象，而是Proxy类对象；但是Annotation内部定义了一个annotationType()的方法，该方法可以帮助我们获取到注解的Class对象" }, { "title": "建造者模式", "url": "/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2022-03-18 00:00:00 +0800", "snippet": "为什么需要建造者模式已知建造者模式是用来创建对象的，工厂模式也能创建对象，或者直接使用构造函数或者配合set方法也能创建对象，那么为什么还需要建造者模式呢？建造者模式适合什么样的应用场景呢？ 事实上静态工厂和构造函数都有一个局限：它们不能对大量可选参数做很好的扩展。举个例子：一个类表示包装食品上的营养标签。这些标签上有一些字段是必需的，如：净含量、毛重和每单位份量的卡路里，另有超过 20 个可选的字段，如：总脂肪、饱和脂肪、反式脂肪、胆固醇、钠等等。大多数产品只有这些可选字段中的少数，且具有非零值。对于这样的类什么样的创建方式是合适的呢？目前有两种方式：第一种-构造器public class NutritionFacts { private final int servingSize; // 净含量 required private final int servings; // 毛重 required private final int calories; // 卡路里 optional private final int fat; // 脂肪 optional private final int sodium; // 钠 optional private final int carbohydrate; // 碳水化合物 optional public NutritionFacts(int servingSize, int servings) { this(servingSize, servings, 0); } public NutritionFacts(int servingSize, int servings, int calories) { this(servingSize, servings, calories, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat) { this(servingSize, servings, calories, fat, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) { this(servingSize, servings, calories, fat, sodium, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) { this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; }}当你现在想要创建一个对象时你可以这样：NutritionFacts cocaCola =new NutritionFacts(240, 8, 100, 0, 35, 27);虽然现在看起来没什么问题，构造器的可选参数最多有 6 个，但如果新的业务场景希望 NutritionFacts 包含剩下的 20 个可选参数，我想使用这种方式去创建对象的开发者一定会疯掉。（为什么？因为他至少需要写 20 个这样的构造器，并且如果参数类型相同，调用者就容易传递错误的参数，虽然编译器不会报错，但程序可能在运行时出错！）但是幸好我们还有另外一种方式：第二种-Setter在这种模式中，可以调用一个只传必传参数的构造函数来创建对象，然后调用 setter 方法来设置每个感兴趣的可选参数：public class NutritionFacts { private int servingSize; // Required private int servings; // Required private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } // Setters public void setServingSize(int val) { servingSize = val; } public void setServings(int val) { servings = val; } public void setCalories(int val) { calories = val; } public void setFat(int val) { fat = val; } public void setSodium(int val) { sodium = val; } public void setCarbohydrate(int val) { carbohydrate = val; }}相对于构造器的方式，Setter 明显就不用编写更多的构造器了，可读性和易用性也强于构造器方式，虽然创建对象的方式会显得冗余：NutritionFacts cocaCola = new NutritionFacts(240, 8);cocaCola.setCalories(100);cocaCola.setSodium(35);cocaCola.setCarbohydrate(27); 遗憾的是这种方式也存在巨大的缺陷实际上采用这种先创建后 set 的构建方式，JavaBean 容易处在不一致的状态：NutritionFacts cocaCola = new NutritionFacts(240, 8); //invalidcocaCola.setCalories(100); //invalidcocaCola.setSodium(35); //invalidcocaCola.setCarbohydrate(27); //valid在不一致的状态下尝试使用对象可能会导致错误的发生，为了避免这种情况，就应该让对象一次性创建出来，但是这种方式它天然的做不到。同时又因为暴露了修改内部状态的 Setter 方式，想要生成的对象是不可变对象，也做不到！还好方法总比困难多，除了上面的 A 计划、B 计划，我们还有 Plan C！look this：// Builder Patternpublic class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder { // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calories = val; return this; } public Builder fat(int val) { fat = val; return this; } public Builder sodium(int val) { sodium = val; return this; } public Builder carbohydrate(int val) { carbohydrate = val; return this; } public NutritionFacts build() { return new NutritionFacts(this); } } private NutritionFacts(Builder builder) { servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; }}这便是本章的主题：建造者模式。在这种模式下客户端并不直接创建所需的对象，首先获取一个 builder 对象（build 通常是它构建的类的静态成员，当然也可以独立成为一个类），然后调用像 Setter 一样的方法设置每个感兴趣的可选参数，不过这种方法通常返回 builder 对象，最后客户端调用一个无参数的构建方法 build() 来生成所需对象，就像下面这样：NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();这样的客户端代码易于编写，更加易于阅读，并且创建的对象是不可变的（因为所需对象的构造器是 private，并且只接受 builder 对象参数，然后没有暴露 Setter）而且是一次性创建，所以也不会存在不一致的情况，简直完美解决了另外两种方法的缺点。当然这里举得例子忽略了参数的非法校验，比如显示指定了 param1，就应该显示指定 param2 和 param3，或者 parame2 和 param3 都应该小于等于 param1。这样我们可以统一在最后的 build() 方法内部进行校验，就像下面这样：public ResourcePoolConfig build() { // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等 if (StringUtils.isBlank(name)) { throw new IllegalArgumentException(&quot;...&quot;); } if (maxIdle &amp;gt; maxTotal) { throw new IllegalArgumentException(&quot;...&quot;); } if (minIdle &amp;gt; maxTotal || minIdle &amp;gt; maxIdle) { throw new IllegalArgumentException(&quot;...&quot;); } return new ResourcePoolConfig(this);}上面的校验包括：名称（name）不能为空，最大空闲资源数量（maxIdle）不能大于最大总资源数量（maxTotal），最小空闲资源数量（minIdle）不能大于最大总资源数量（maxTotal），还有最小空闲资源数量（minIdle）不能大于最大空闲资源数量（maxIdle）。建造者模式的缺点由于使用建造者模式时，每次客户端创建所需对象时需要首先创建 builder 对象，虽然在实际应用中创建这个构建器的成本可能并不显著，但在以性能为关键的场景下，这可能会是一个问题。而且建造者的代码有点重复，builder 的状态变量与它构建的对象是一样的，同时相比构造器方法，builder 的客户端代码会更加的冗余些。其实我觉得建造者的缺点都不算缺点，假使你用 Constructor or Setter 都不能满足客户端创建所需对象的要求，那么大胆的选择建造者模式吧，它就是为此而生的！而且针对代码重复的问题，也不是没有解决办法，像下面这样：class EntityCreator&amp;lt;T&amp;gt; { private Class&amp;lt;T&amp;gt; classInstance; private T entityObj; public EntityCreator(Class&amp;lt;T&amp;gt; classInstance, Object... initParams) throws Exception { this.classInstance = classInstance; //这段 for 循环就是为了匹配对应的构造器，没什么其他作用 Class&amp;lt;?&amp;gt;[] paramTypes = new Class&amp;lt;?&amp;gt;[initParams.length]; for (int index = 0, length = initParams.length; index &amp;lt; length; index++) { String checkStr = initParams[index].getClass().getSimpleName(); if (checkStr.contains(&quot;Integer&quot;)) { paramTypes[index] = int.class; } if (checkStr.contains(&quot;Double&quot;)) { paramTypes[index] = double.class; } if (checkStr.contains(&quot;Boolean&quot;)) { paramTypes[index] = boolean.class; } if (checkStr.contains(&quot;String&quot;)) { paramTypes[index] = initParams[index].getClass(); } } //匹配正确的构造器创建出对象 Constructor&amp;lt;T&amp;gt; constructor = classInstance.getDeclaredConstructor(paramTypes); constructor.setAccessible(true); this.entityObj = constructor.newInstance(initParams); } public EntityCreator&amp;lt;T&amp;gt; setValue(String paramName, Object paramValue) throws Exception { Field field = classInstance.getDeclaredField(paramName); field.setAccessible(true); field.set(entityObj, paramValue); return this; } public T build() { return entityObj; }}这个方法适合那些没有独特校验规则，并且适合用建造者模式创建的对象。这样就可以将 builder 类从所需对象中完全移除，并且适应一大批相似结构对象的创建需求。" }, { "title": "工厂模式", "url": "/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2022-03-18 00:00:00 +0800", "snippet": "工厂模式的定义程序设计中的工厂类往往是对象创建、初始化过程的封装，而工厂方法 (Factory Method) 则可以升华为一种设计模式，它对工厂制造方法进行接口规范化，以允许子类工厂决定具体制造哪类产品的实例，最终降低系统耦合，使系统的可维护性、可扩展性等得到提升。一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂应用工厂模式下面以一个实际案例：空战游戏的角色建模，来介绍他们的用法如图所示，游戏中的敌人有飞机和坦克，虽然种类不同但它们总会有一些共同属性，比如描述位置状态的坐标，以及一个绘制方法（show）将它绘制到图层上，下面是对敌人的父类设计：public abstract class Enemy { //x，y 轴坐标 protected int x; protected int y; public Enemy(int x, int y) { this.x = x; this.y = y; } /** * 绘制方法 */ public abstract void show();}下面是具体的子类设计：/** * 飞机类 */public class Airplane extends Enemy{ public Airplane(int x, int y) { super(x, y); } @Override public void show() { System.out.printf(&quot;坐标（%d,%d），出现敌机\\n&quot;, x, y); System.out.println(&quot;对方发动攻击&quot;); }}/** * 坦克类 */public class Tank extends Enemy{ public Tank(int x, int y) { super(x, y); } @Override public void show() { System.out.printf(&quot;坐标（%d,%d），出现敌方坦克\\n&quot;, x, y); System.out.println(&quot;对方发动攻击&quot;); }}然后是我们的客户端程序：public class Client { public static void main(String[] args) { int screenWidth = 100; System.out.println(&quot;游戏开始&quot;); Random random = new Random(); int x = random.nextInt(screenWidth); Enemy airplane = new Airplane(x, 0); airplane.show(); x = random.nextInt(screenWidth); Enemy tank = new Tank(x, 0); tank.show(); }}/*输出结果游戏开始坐标（85,0），出现敌机对方发动攻击坐标（9,0），出现敌方坦克对方发动攻击*/我们发现游戏正常运行起来了，但是有个问题，没有 Boss 啊！这时我们需要添加一个 Boss 类，然后又写一段重复的创建敌人的代码，于是一旦增加敌人我们就要修改客户端程序，显然敌人的创建、初始化逻辑耦合在了客户端当中，这时简单工厂就发挥作用了：public class SimpleFactory { private int screenWidth; private Random random; public SimpleFactory(int screenWidth, Random random) { this.screenWidth = screenWidth; this.random = random; } public Enemy create(String type){ int x = random.nextInt(screenWidth); Enemy enemy = null; switch (type){ case &quot;airplane&quot;: enemy = new Airplane(x, 0); break; case &quot;tank&quot;: enemy = new Tank(x, 0); break; case &quot;boss&quot;: enemy = new Boss(screenWidth / 2, 0); break; default: throw new RuntimeException(&quot;不允许的敌人类型&quot;); } return enemy; }}这时如果新增其他类别的敌人，只需要在 switch 语句里加个 case 分支就可以了，客户端的代码也会更加简单：但是如果业务不断的变化，敌人的种类越来越多，每次都需要修改简单工厂，使得它变得越来越臃肿，从设计上缺乏灵活性和可扩展性，同时不符合开闭原则这时便可使用工厂方法对生产模式进行抽象，为每类敌人专门提供一个工厂，这样每次敌人种类增加，只需要新增对应的工厂类就可以了，符合开闭原则。首先定义一个工厂接口，以确立统一的生产标准：public interface EnemyFactory { Enemy create(int screenWidth);}下面是将简单工厂拆分后的类设计：public class AirplaneFactory implements EnemyFactory{ @Override public Enemy create(int screenWidth) { Random random = new Random(); int x = random.nextInt(screenWidth); return new Airplane(x, 0); }}public class TankFactory implements EnemyFactory{ @Override public Enemy create(int screenWidth) { Random random = new Random(); int x = random.nextInt(screenWidth); return new Tank(x, 0); }}public class BossFactory implements EnemyFactory{ @Override public Enemy create(int screenWidth) { return new Boss(screenWidth / 2, 0); }}最后就是客户端程序：public class Client { public static void main(String[] args) { int screenWidth = 100; System.out.println(&quot;游戏开始&quot;); EnemyFactory factory; factory = new AirplaneFactory(); Enemy airplane = factory.create(screenWidth); factory = new TankFactory(); Enemy tank = factory.create(screenWidth); factory = new BossFactory(); Enemy boss = factory.create(screenWidth); airplane.show(); tank.show(); boss.show(); }}通过工厂方法的改造，不仅敌人需要分类，工厂也同样需要分类，这样一旦敌人种类增加，只需要按照生产规范新增一类工厂，而不需要修改其他工厂方法，相比工厂方法，抽象工厂应用的场景如下：简单来说，每个工厂不再单纯生产一种对象，经接口规范生产方法后，每种工厂将会生产多种对象。" }, { "title": "原型模式", "url": "/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2022-03-18 00:00:00 +0800", "snippet": "什么是原型模式如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。为什么要使用原型模式耗时操作有哪些： 如果用 new 创建就会触发类加载，对象实例化，初始化等操作，效率远低于拷贝，例如数据初始化需通过排序、计算哈希值这些步骤 数据需经过慢速的 IO 操作获取（RPC、网络、数据库和文件系统）这种情况下往往可以复用旧的数据，采用原型模式更新数据，而原型模式就是基于 Clone数据一致性常见的数据一致性问题，如： Redis 与数据库，ES 与数据库，内存与数据库，分布式一致性等在 Java 中如何设计原型模式 对象应该实现Cloneable接口 首先得有原型对象，才能实现拷贝基于浅拷贝 or 基于深拷贝的原型模式浅拷贝：只复制对象引用，or 基本数据类型；深拷贝：复制基本数据类型，同时复制对象的数据创建新的对象如何实现深拷贝 递归拷贝对象 先将对象序列化，然后再反序列化成新的对象" }, { "title": "单例模式", "url": "/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2022-03-18 00:00:00 +0800", "snippet": "什么是单例模式保证整个系统中一个类只有一个实例，并且提供一个可以全局访问的入口，实现这种功能的方式就叫做单例模式为什么要使用单例模式节省公共资源一些对象频繁的创建和销毁会非常耗费性能和资源，比如，频繁访问数据库或文件的对象（DruidDataSource、SqlSessionFactory） 这些操作往往很费时，如：查询数据库并对查到的数据做大量计算、加解密、解压缩和读取文件等解决在多线程下资源访问冲突的情况以日志管理为例：public class Logger { private FileWriter writer; public Logger() { File file = new File(&quot;/path/log.txt&quot;); writer = new FileWriter(file, true); //true表示追加写入 } public void log(String message) { writer.write(message); }}单例模式配合线程安全的 writer()，能避免资源访问冲突问题如果 Logger 不是单例，那么在多个线程同时操作文件 “/path/log.txt” 时可能出现线程安全问题，如下图所示：有些数据在内存中只需保存一份，如配置信息类、Class&amp;lt;?&amp;gt; 类如何实现一个单例思路： 构造器私有 静态方法返回实例 是否支持延迟加载 ？懒汉 ：饿汉饿汉模式/** * 声明时初始化 */public class SingletonDemo1 { private final static SingletonDemo1 INSTANCE = new SingletonDemo1(); public static getInstance(){ return INSTANCE; }}/** * 静态代码块初始化 */public class SingletonDemo2 { private final static SingletonDemo2 INSTANCE; static { INSTANCE = new SingletonDemo2(); } public static getInstance(){ return INSTANCE; }}/** * 巧用枚举，当只有一个枚举实例时，其实就是单例模式 */public enum SingletonDemo3 { INSTANCE;} 上面的单例对象都是在类加载时就已经被创建了，所以不存在线程安全问题懒汉模式/** * 虽然是内部类但也是独立的，只有在使用到时才会加载 */public class SingletonDemo6 { private SingletonDemo6(){} /** * 静态内部类相对于外部类是独立的，只有在被使用时或者方法被调用时会被加载 */ private static class Inner{ private static SingletonDemo6 INSTANCE = new SingletonDemo6(); } public static SingletonDemo6 getINSTANCE() { return Inner.INSTANCE; }}/** * 双重检测（提高并发量） */public class SingletonDemo6 { private static volatile SingletonDemo6 INSTANCE; private SingletonDemo6(){} public static SingletonDemo6 getINSTANCE() { //最外层检测避免每个线程都去获得/释放 class 的锁（耗时操作） if(INSTANCE == null){ synchronized(SingletonDemo6.class) { if(INSTANCE == null){ INSTANCE = new SingletonDemo6(); } } } return INSTANCE; }}双重检测中的 volatile在双重检查锁模式中为什么需要使用 volatile 关键字new SingletonDemo6() 实际不是一个原子操作，在 JVM 中这条语句至少做了下面这 3 件事： 给 INSTANCE 分配内存空间 调用构造器初始化 INSTANCE 将 INSTANCE 对象指向分配的内存空间（执行完这步 INSTANCE 就不是 null 了）但是由于指令重排优化，创建对象的顺序不一定是 1 -&amp;gt; 2 -&amp;gt; 3，也可能是 1 -&amp;gt; 3 -&amp;gt; 2，这样有个问题：对象还未初始化，却已经不为空了，这样双重检查就会失效，那么 INSTANCE 的使用就会报错，具体如下图：总结使用了 volatile 之后，相当于是表明了该属性的更新可能是在其他线程中发生的，而 volatile 的意义主要在于它可以避免拿到没完成初始化的对象，从而保证了线程安全。" }, { "title": "代理模式", "url": "/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "", "date": "2022-03-18 00:00:00 +0800", "snippet": "通用工作模式上图中，Subject 是一个抽象类/接口，RealSubject 是实现方法类，是具体的业务执行，Proxy 则是 RealSubject 的代理，它同样继承/实现 Subject，并直接和 Client 接触的。进一步来说代理模式可以在不直接修改被代理对象（RealSubject）的基础上，通过扩展代理类（Proxy）进行一些功能的附加和增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。举个现实中的例子：4s店和汽车生产厂家就是代理和被代理的关系，汽车生产厂家把造好的车交给4s店代为销售，而4s店除了销售汽车外还会为顾客提供汽车维修、配件和信息反馈等一系列售后服务。显然顾客想买车肯定不是去汽车制造厂，直接去4s店就行了。又比如： 房屋中介，客户手里没有房源信息，那么可以找中介。 商品代购，代购者拥有价格更加低廉的购买渠道。为什么要使用代理模式总之代理模式又被称为委托模式。作为被委托方/机构往往会在前者的基础上为客户提供更加便利的服务。那么作为消费者（客户）可以挑选房源租到好的住房/通过更加低廉的价格购买物品。概述代理模式（Proxy Pattern）：是 23 中设计模式中的一种，属于结构型模式，它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。客户端不直接操作原始类，而是通过它的代理类意义原始类只需要关注自己的业务实现，通过代理类对业务进行增强以扩展原始类的功能。实现以性能计数器为例，下面是一个用户接口 UserController 提供了登录（login）和注册（register）的功能。性能计数器则会在这些接口执行完毕后打印出它的相应时间。public class UserController { //性能计数器类 private MetricsCollector metricsCollector; public UserVo login(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); // ... 省略login逻辑... long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; log.debug(&quot;响应时间是{}毫秒&quot;, responseTime); //...返回 UserVo 数据... } public UserVo register(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); // ... 省略register逻辑... long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; log.debug(&quot;响应时间是{}毫秒&quot;, responseTime); //...返回 UserVo 数据... }}但是，不难看出这样的实现有一个很严重的问题： 性能计数器代码与业务代码耦合，如果未来需要替换这种实现，成本将会比较昂贵 增强代码没有得到复用，每个业务方法内部都需要实现一遍。而为了将框架代码和业务代码解耦，代理模式就派上用场了。通过代理模式改造如下：代理类（UserControllerProxy）和被代理类（UserController）实现相同的接口 IUserController。UserController 类只负责业务功能，代理类（UserControllerProxy）通过组合的方式调用被代理类（UserController）来执行业务代码，并在业务代码执行前后附加额外的功能。public interface IUserController { UserVo login(String telephone, String password); UserVo register(String telephone, String password);}public class UserControllerProxy implements IUserController { //性能计数器 private MetricsCollector metricsCollector; //组合被代理类 private UserController userController; //省略无参有参构造器 @Override public UserVo login(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); //业务逻辑调用 UserVo userVo = userController.login(telephone, password); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; log.debug(&quot;响应时间是{}毫秒&quot;, responseTime); //...返回 UserVo 数据... } @Override public UserVo register(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); //业务逻辑调用 UserVo userVo = userController.register(telephone, password); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; log.debug(&quot;响应时间是{}毫秒&quot;, responseTime); //...返回 UserVo 数据... }}这样修改后被代理类（UserControll）的业务更加单一，当需要替换性能计数器实现时就不用动 UserController，更改它的代理类就行了。同样的如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。code 如下：public class UserControllerProxy extends UserController { //性能计数器 private MetricsCollector metricsCollector; //省略有参无参构造器 public UserVo login(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); //super 调用父类方法 UserVo userVo = super.login(telephone, password); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; log.debug(&quot;响应时间是{}毫秒&quot;, responseTime); //返回结果 } //regiter 代码格式同 login}动态代理经过上面的改造，虽然业务代码和性能计数器代码解耦了，但增强逻辑没法复用的问题依然存在，并且还产生了新的问题：由于代理模式的特点，每个原始类需要创建一个代理类，这样如果有大量的类需要进行增强，那么就会生产大量的代理类，大大增加维护的难度其实上面的实现被称为静态代理，而在静态代理的基础之上又诞生了动态代理下面看看动态代理是如何解决静态代理的问题呢？所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类。那如何实现动态代理呢？/** * 代理类 */public class MetricsCollectorProxy { //性能计数器 private MetricsCollector metricsCollector; public MetricsCollectorProxy() { this.metricsCollector = new MetricsCollector(); } public Object createProxy(Object proxiedObject) { Class&amp;lt;?&amp;gt;[] interfaces = proxiedObject.getClass().getInterfaces(); DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject); //newProxyInstance 是 JDK 提供的 Proxy 类的方法，通过它可以创建代理对象 return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler); } /** * handler 内部其实就是封装了增强逻辑的模板式代码 */ private class DynamicProxyHandler implements InvocationHandler { //原始对象 private Object proxiedObject; public DynamicProxyHandler(Object proxiedObject) { this.proxiedObject = proxiedObject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long startTimestamp = System.currentTimeMillis(); //被代理类通过反射调用内部方法 Object result = method.invoke(proxiedObject, args); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; //打印日志 //返回结果 } }}//MetricsCollectorProxy 使用MetricsCollectorProxy proxy = new MetricsCollectorProxy();IUserController userController = (IUserController) proxy.createProxy(new UserController());JDK 动态代理Java 本身提供了动态代理语法，我们称之为 JDK 动态代理。在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。public static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException{ ......}这个方法一共有 3 个参数： loader :类加载器，用于加载代理对象。 interfaces : 被代理类实现的一些接口； h : 实现了 InvocationHandler 接口的对象；使用与我们自定义的 MetricsCollectorProxy 使用方法相同实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。代理模式不仅能增强原业务功能，更重要的是还能对其进行业务管控。对用户来讲，隐藏于代理中的实际业务被透明化了，而暴露出来的是代理业务，以此避免客户端直接进行业务访问所带来的安全隐患，从而保证系统业务的可控性、安全性。静态代理和JDK动态代理的区别 JDK 动态代理不用自定义代理类，由 jdk 为我们提供的 Proxy 作为代理类，在动态代理中我们只在意代理对象和增强代码，因而代理类对我们来说是多余的，我们只要能获取到代理对象就 OK 了 JDK 动态代理的增强代码（InvocationHandler 封装的内容）不与代理类耦合，可以复用 代理就是俄罗斯套娃，层层封装，层层屏蔽代理模式的应用场景业务系统的非功能性需求开发代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。代理模式在RPC、缓存中的应用实际上，RPC框架也可以看作一种代理模式，GoF的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。RPC demo再来看代理模式在缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于Spring框架来开发的话，那就可以在AOP切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在AOP切面中拦截请求，如果请求中带有支持缓存的字段（比如http://…?..&amp;amp;cached=true），我们便从缓存（内存缓存或者Redis缓存等）中获取数据直接返回。" }, { "title": "Java字节码技术", "url": "/posts/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/", "categories": "JVM", "tags": "", "date": "2022-03-16 00:00:00 +0800", "snippet": "为什么要学习字节码技术 从技术人员的角度看，Java 字节码是 JVM 的指令集，JVM 加载字节码格式的 class 文件，校验之后通过 JIT 编译器转换为本地机器代码执行，也就是说Java字节码就是我们给JVM的指令，为了让JVM能够按照我们的计划执行，我们就应该熟悉Java字节码技术 了解字节码及其工作原理，对于编写高性能代码至关重要，对于深入分析和排查问题也有一定作用，所以我们要想深入了解 JVM 来说，了解字节码也是夯实基础的一项基本功 对于工具领域和程序分析来说, 字节码就是必不可少的基础知识了，通过修改字节码来调整程序的行为是司空见惯的事情，而且想了解分析器(Profiler)，Mock 框架，AOP 等工具和技术这一类工具，则必须完全了解 Java 字节码Java字节码简介Java字节码（Java bytecode），就如名称所示, Java bytecode 由单字节(byte)的指令组成，理论上最多支持256（2^8）个操作码（操作指令），实际只使用了200左右，还有一些操作码保留给了调试操作操作码（指令）结构操作码， 下面称为 指令, 主要由类型前缀和操作名称两部分组成，如：iadd，i代表类型前缀，即integer，add代表操作名称，即加法操作，所以合起来就是对integer类型的数据执行加法操作指令的分类根据指令的性质，分为4大类： 栈操作指令，包括与局部变量交互的指令 程序流程控制指令 对象操作指令，包括方法调用指令 算术运算以及类型转换指令此外还有一些执行专门任务的指令，比如同步(synchronization)指令，以及抛出异常相关的指令等等获取字节码清单即通过javap工具反编译获取class文件的指令清单对于下面的类：package demo.jvm0104;public class HelloByteCode { public static void main(String[] args) { HelloByteCode obj = new HelloByteCode(); }} 我们首先通过javac命令编译获得class文件：javac demo/jvm0104/HelloByteCode.java，另外可以通过-d参数指定.class文件放置的目录，默认与.java文件同目录，除此之外，javac命令默认开始了优化功能，会将字节码中的局部变量表擦除，如果想在反编译的指令集中看到局部变量表，请在编译时追加-g指令 执行命令：javap -c demo/jvm0104/HelloByteCode.class，反编译成功后结果如下：Compiled from &quot;HelloByteCode.java&quot;public class demo.jvm0104.HelloByteCode { public demo.jvm0104.HelloByteCode(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class demo/jvm0104/HelloByteCode 3: dup 4: invokespecial #3 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return}解读字节码清单 public demo.jvm0104.HelloByteCode();，这是反编译后的第一个注意点，这是默认的无参构造函数，也就是编译器会默认生成构造函数，而不是运行时JVM自动生成的 明明未编译的默认构造函数体内什么都没有，但是这里却有一些指令，根据常识，每个构造函数会默认调用super()，而下面的这些指令就是做的这个工作 public demo.jvm0104.HelloByteCode(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return查看class文件的常量池信息常量池（Constant pool），大多数时候指的是 运行时常量池。但运行时常量池里面的常量是从哪里来的呢? 主要就是由 class 文件中的 常量池结构体 组成的。如何查看常量池信息javap -c -verbose HelloByteCode，要加上-verbose参数处理结果如下：Classfile /C:/Users/wangwei/Documents/JVM/HelloByteCode.class Last modified Sep 1, 2022; size 441 bytes MD5 checksum 844ef2f6966e464d707692d8dc22f594 Compiled from &quot;HelloByteCode.java&quot;public class demo.jvm0104.HelloByteCode minor version: 0 major version: 55 flags: (0x0021) ACC_PUBLIC, ACC_SUPER this_class: #2 // demo/jvm0104/HelloByteCode super_class: #4 // java/lang/Object interfaces: 0, fields: 0, methods: 2, attributes: 1Constant pool: #1 = Methodref #4.#19 // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V #2 = Class #20 // demo/jvm0104/HelloByteCode #3 = Methodref #2.#19 // demo/jvm0104/HelloByteCode.&quot;&amp;lt;init&amp;gt;&quot;:()V #4 = Class #21 // java/lang/Object #5 = Utf8 &amp;lt;init&amp;gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 LocalVariableTable #10 = Utf8 this #11 = Utf8 Ldemo/jvm0104/HelloByteCode; #12 = Utf8 main #13 = Utf8 ([Ljava/lang/String;)V #14 = Utf8 args #15 = Utf8 [Ljava/lang/String; #16 = Utf8 obj #17 = Utf8 SourceFile #18 = Utf8 HelloByteCode.java #19 = NameAndType #5:#6 // &quot;&amp;lt;init&amp;gt;&quot;:()V #20 = Utf8 demo/jvm0104/HelloByteCode #21 = Utf8 java/lang/Object{ public demo.jvm0104.HelloByteCode(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return LineNumberTable: line 2: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Ldemo/jvm0104/HelloByteCode; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: new #2 // class demo/jvm0104/HelloByteCode 3: dup 4: invokespecial #3 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return LineNumberTable: line 4: 0 line 5: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; 8 1 1 obj Ldemo/jvm0104/HelloByteCode;}SourceFile: &quot;HelloByteCode.java&quot;什么是ACC_PUBLIC和ACC_SUPER ACC_PUBLIC：代表该类是public类 ACC_SUPER：由于历史原因，JDK 1.0 的 BUG 修正中引入 ACC_SUPER 标志来修正 invokespecial 指令调用 super 类方法的问题，从 Java 1.1 开始， 编译器一般都会自动生成ACC_SUPER 标志。指令后面的编号#1, #2, #3是什么意思这就是对常量池的引用常量池Constant pool: #1 = Methodref #4.#19 // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V #2 = Class #20 // demo/jvm0104/HelloByteCode #3 = Methodref #2.#19 // demo/jvm0104/HelloByteCode.&quot;&amp;lt;init&amp;gt;&quot;:()V #4 = Class #21 // java/lang/Object #5 = Utf8 &amp;lt;init&amp;gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 LocalVariableTable #10 = Utf8 this ......显然每个编号代表一个常量，其中常量之间可以相互引用、组合称为一个新的常量如第一行：#1 = Methodref #4.#19 // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V，解读如下： #1 常量编号, 该文件中其他地方可以引用。 = 等号就是分隔符. Methodref 表明这个常量指向的是一个方法；具体是哪个类的哪个方法呢? 类指向的 #4, 方法签名指向的 #19; 当然双斜线注释后面已经解析出来可读性比较好的说明了。常量池小总结常量池就是一个常量的大字典，使用编号的方式把程序里用到的各类常量统一管理起来，这样在字节码操作里，只需要引用编号即可。查看方法信息经过javap -verbose，方法信息里面新增了更多的内容：public static void main(java.lang.String[]);descriptor: ([Ljava/lang/String;)Vflags: (0x0009) ACC_PUBLIC, ACC_STATICCode: stack=2, locals=2, args_size=1在descriptor这一栏： 小括号内是形参 左方括号表示数组 L代表对象 java/lang/String，是参数对应的类型 V，方法返回值是voidflags这一栏，表示main方式是static，public修饰的另外stack=2, locals=2, args_size=1这一栏： stack表示执行方法需要的栈（stack）的深度 locals表示需要在局部变量表中保留多少个槽位 args_size，方法参数的个数实际上我们一般把方法修饰符，返回值，名称，参数类型清单合在一起叫做方法签名，即这些信息可以表示一个唯一的方法注意无参构造函数的变化public demo.jvm0104.HelloByteCode();descriptor: ()Vflags: (0x0001) ACC_PUBLICCode: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V 4: return LineNumberTable: line 2: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Ldemo/jvm0104/HelloByteCode;我们发现args_size=1，也就是无参构造函数实际却有一个参数，其实在 Java 中, 如果是静态方法则没有 this 引用。 对于非静态方法，this 将被分配到局部变量表的第 0 号槽位中，因此这里locals=1。线程栈和字节码执行模型 JVM 是一台基于栈的计算机器。每个线程都有一个独属于自己的线程栈(JVM stack)，用于存储栈帧(Frame) 每一次方法调用，JVM都会自动创建一个栈帧。栈帧包括： 局部变量表：存放方法参数和局部变量 操作数栈：存放计算值和方法返回值 class引用，class 引用 指向当前方法在运行时常量池中对应的 class局部变量表 局部变量数组 也称为 局部变量表(LocalVariableTable), 其中包含了方法的参数，以及局部变量。 部变量数组的大小在编译时就已经确定: 和局部变量+形参的个数有关，还要看每个变量/参数占用多少个字节。操作数栈 操作数栈是一个 LIFO 结构的栈， 用于压入和弹出值。 它的大小也在编译时确定。 操作数栈还用于接收调用其他方法时返回的结果值。方法体中的字节码解读其实这些数字就代表了字节码指令的存储地址的起始索引，众所周知每个操作码的大小是一个字节，由于操作数也需要占用空间，所以指令前面的数字间隔不同对象初始化指令：new 指令, init 以及 clinit 简介对象初始化指令解析public static void main(java.lang.String[]);descriptor: ([Ljava/lang/String;)Vflags: (0x0009) ACC_PUBLIC, ACC_STATICCode: stack=2, locals=2, args_size=1 0: new #2 // class demo/jvm0104/HelloByteCode 3: dup 4: invokespecial #3 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: return 如果同时看到 new, dup 和 invokespecial 指令在一起时，那么一定是在创建类的实例对象！ new 指令只是创建对象，但没有调用构造函数，也就是说对象还未初始化（实例变量，实例代码块等等都还未执行初始化） dup 指令用于复制栈顶的值，在这里就是复制new指令创建的对象引用 invokespecial 指令用来调用某些特殊方法的, 当然这里调用的是构造函数。 astore_1，将对象引用赋值给1号槽位的局部变量，也就是obj注意，由于构造函数调用不会有返回值，所以在执行初始化时，栈顶的引用被弹出初始化，但初始完成后没有压入操作数栈，这样新创建的对象就会丢失，因此使用dup命令在初始化之前复制对应引用init和clinit的区别1.init和clinit执行时机不同init在类构造函数被调用时执行，clinit在类加载流程的初始化过程中执行 init和clinit执行目的不同init对非静态变量初始化，clinit对静态变量和静态代码块进行初始化，如下方程序：class X { static Log log = LogFactory.getLog(); // &amp;lt;clinit&amp;gt; private int x = 1; // &amp;lt;init&amp;gt; X(){ // &amp;lt;init&amp;gt; } static { // &amp;lt;clinit&amp;gt; }}clinit详解 实际上在类加载流程中的准备阶段，会为类变量（静态变量）在方法区分配内存，并设置零值。 而在初始化阶段会根据程序员通过程序制定的主观计划去初始化类变量和其他资源（调用clinit） ＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，收集的顺序是由语句在源文件中出现的顺序所决定的 静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以对其执行赋值操作，但是不能访问，如下代码演示：public class Test{ static{ i=0；//给变量赋值可以正常编译通过 System.out.print（i）；//这句编译器会提示&quot;非法向前引用&quot; } static int i=1；} 虚拟机会保证在子类的＜clinit＞（）方法执行之前，父类的＜clinit＞（）方法已经执行完毕，这也意味着父类的静态语句块要优先于子类的变量赋值操作 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞（）方法。 但接口与类不同的是，执行接口的＜clinit＞（）方法不需要先执行父接口的＜clinit＞（）方法。 只有当父接口中定义的变量使用时，父接口才会初始化。 另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞（）方法。final static int a=2；final static int b=a;在这种情况下clinit会被调用，另外接口中的属性都是static final类型的常量，因此在准备阶段就已经初始化clinit触发的条件，或者说类初始化触发的条件 静态字段被访问 静态方法被调用局部变量表与操作数栈的交互有下面两个类：获取动态平均数package demo.jvm0104;//移动平均数public class MovingAverage { private int count = 0; private double sum = 0.0D; public void submit(double value){ this.count ++; this.sum += value; } public double getAvg(){ if(0 == this.count){ return sum;} return this.sum/this.count; }}调用上诉类的方法package demo.jvm0104;public class LocalVariableTest { public static void main(String[] args) { MovingAverage ma = new MovingAverage(); int num1 = 1; int num2 = 2; ma.submit(num1); ma.submit(num2); double avg = ma.getAvg(); }}其中 main 方法中向 MovingAverage 类的实例提交了两个数值，并要求其计算当前的平均值。经过下列命令： javac -g demo/jvm0104/*.java javap -c -verbose demo/jvm0104/LocalVariableTest对应的字节码清单如下：public static void main(java.lang.String[]);descriptor: ([Ljava/lang/String;)Vflags: ACC_PUBLIC, ACC_STATICCode: stack=3, locals=6, args_size=1 0: new #2 // class demo/jvm0104/MovingAverage 3: dup 4: invokespecial #3 // Method demo/jvm0104/MovingAverage.&quot;&amp;lt;init&amp;gt;&quot;:()V 7: astore_1 8: iconst_1 9: istore_2 10: iconst_2 11: istore_3 12: aload_1 13: iload_2 14: i2d 15: invokevirtual #4 // Method demo/jvm0104/MovingAverage.submit:(D)V 18: aload_1 19: iload_3 20: i2d 21: invokevirtual #4 // Method demo/jvm0104/MovingAverage.submit:(D)V 24: aload_1 25: invokevirtual #5 // Method demo/jvm0104/MovingAverage.getAvg:()D 28: dstore 4 30: return LineNumberTable: line 5: 0 line 6: 8 line 7: 10 line 8: 12 line 9: 18 line 10: 24 line 11: 30 LocalVariableTable: Start Length Slot Name Signature 0 31 0 args [Ljava/lang/String; 8 23 1 ma Ldemo/jvm0104/MovingAverage; 10 21 2 num1 I 12 19 3 num2 I 30 1 4 avg D下面对陌生的命令进行说明： 8: iconst_1 9: istore_210: iconst_211: istore_3 iconst_1 和 iconst_2 用来将常量值1和2加载到栈里面（常量是存储在堆内存中的方法区的常量池中，我们现在讨论的时线程栈，也就是栈内存） istore_2 和 istore_3 将它们存储到在 LocalVariableTable 的槽位 2 和槽位 3 中 20: i2di2d这个指令将int值转换未double值给局部变量赋值时，需要使用相应的指令来进行 store，如 astore_1。store 类的指令都会删除栈顶值。 相应的 load 指令则会将值从局部变量表压入操作数栈，但并不会删除局部变量中的值。另外有个有意思的地方，main方法的局部变量表的0号槽位被方法参数占用，而非this，毕竟静态方法不需要this" }, { "title": "Java基础知识", "url": "/posts/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/", "categories": "编程语言, Java", "tags": "", "date": "2022-03-16 00:00:00 +0800", "snippet": "方法1.静态方法为什么不能调用非静态成员 静态方法在类初始化时分配内存，此时对象还没初始化，也就是说还不存在this，而非静态成员需要this进行调用 静态方法和静态变量是可以被子类继承的，但是会被隐藏，因为它们本身是属于类的，也就是说你调用静态成员时可以直接通过类名，既然如此你还有必要用子类来调用静态成员吗？2.子类可以重写父类的静态方法吗：不能 根据实验，向上转型的子类，调用静态方法不能体现多态，说明子类并不能重写父类的静态方法3.equals()和==的区别 对于基本数据类型，==比较的是两者的值；对于引用数据类型，==比较的是对象的内存地址 equals()是Object类中的实例方法，效果与==比较对象是一样的 在其他类型基本重写了equals()方法，例如String类重写equals()方法后的效果是：①比较两个对象变量指向的内存变量是否相同；②判断对象是否同类型或者是父子类关系；③判断对象属性是否相同4.为什么重写equals，需要同时重写hashCode方法 有如下Java规范：obj1.equals(obj2) == true —&amp;gt; obj1.hashCode()==obj2.hashCode()，反之，如果obj1.hashCode()==obj2.hashCode()，obj1.equals(obj2)不一定等于true，但为了提高hash表的效率，应该使其相等 hashCode方法存在的意义就是为了提高hash表的查询效率，这样就可以减少equals的次数，比如HashSet和HashMap，其中HashSet底层就是利用的HashMap的key特性保证了元素的唯一性 对于HashMap的put方法，对于put(key,value)，首先会比较key.hashCode的值在HashMap中是否有与之相等的，如果不等直接存入，如果相等会再比较equals，判断是否为同一对象，如果确实为同一对象，那么就会覆盖原来的value，如果不为同一对象，就是存在拉链后面，该拉链的底层数据结构是链表5.this()和super()调用的先后顺序 有显式this()调用的构造器就会抑制掉该构造器里隐式的super()调用；没有显式this()调用的构造器则会得到隐式的super()调用。 this()调用会借助别的重载版本的构造器来做部分初始化，而一连串this()最后来到的构造器必然是没有显式this()调用的，这里就会有显式或隐式的super()调用。 并不是构造子类对象的同时会构造父类对象，而是一个子类对象的实例会包含其所有基类所声明的字段，外加自己新声明的字段。那些父类声明的字段并不构成一个完整的父类的实例。super()是让父类封装对自己所声明的字段做初始化的手段。多态1.重写与重载的区别 方法是否冲突，跟方法名和参数类型以及参数顺序有关，与返回值、方法修饰符（这里应该指的是private、protected、public）无关 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。其中返回值、修饰符、参数个数和顺序都可以不同但方法名必须相同 调用哪个重载的方法是在编译期就决定了的 重写就是对父类方法的改造，当子类方法中根据相同的参数需要返回不同的处理结果，就需要对方法进行重写 调用重写方法是在运行起决定的 重写方法的参数类型、个数和顺序必须与父类方法相同；返回值的类型如果是void或基本数据类型，则不能修改，如果是引用数据类型可以是该类型的子类；抛出的异常类型范围小于等于父类，访问修饰符的范围大于等于父类 重载方法的参数列表必须修改，重写方法的参数列表不能修改2.使用重载的方法的版本是依据调用者和方法参数，而调用者和方法参数的确定都是在编译器就确定了的；所以用了哪一个重载方法是在编译器就确定了的；相比之下，重写调用的是哪个子类的方法则是在运行期才确定的3.分派调用 方法调用过程：指确定被调用方法的版本（即调用哪一个方法），并不包括方法执行过程； 分派调用的种类： 静态分派：依赖于静态类型来定位方法执行版本的分派动作（如重载）称为静态分派 动态分派：运行时期，依赖于实际类型来定位方法执行的分派动作（重写 Override）属于动态分派 单分派与多分派：方法的接受者与方法的参数统称为方法的宗量。根据分派基于多少宗量，可以将分派划分为单分派和多分派两种运算符1.右移运算符»和无符号右移运算符»&amp;gt; ex1»ex2，其中ex2表示移动的位数，ex1移动时，向右移出的位被丢弃，左边用符号位填充（是正数就用0，负数就用1） ex1»&amp;gt;ex2，无论ex1为负数还是正数，左边统一用0填充2.异或运算符^类和对象1.怎么理解Java对象：把现实中不同的数据绑定在一起形成的单一整体，称它为对象；简单来说对象就是用来存储一些关联数据的有机结合体，或者说对象可以看成是一个容器，一个集合，这个里面存放的逻辑相关的数据2.null是所有引用类型的默认值，可以赋值给任何引用类型变量，但是不能赋值给基本类型变量；null可以转换成任何引用类型；3.Java里float、double、long，需要在赋值直接量后面分别添加f或F、d或D、l或L尾缀来说明。不添加容易引发编译错误，丢失精度等问题4.包装类底层的常量池技术 什么是常量池，就是说事先准备了一个范围的数据放在池子(在底层叫缓存数组)里，那么基本数据类型进行自动装箱时，如果在这个范围内就会用常量池中的数据赋值，因此只要实在这个范围的基本数据类型，被装箱后指向的都是同一个对象；（注意如果是new创建的包装类对象那么就是不同的对象，所以建议在比较包装类对象时使用equals()方法） 除了浮点类型float、double其他基本数据类型的包装类都实现了常量池技术 常量池技术本身是用来提高性能的，试想每次包装时都需要new出对象效率是不是很低，如果在池子里事先准备好，赋值时直接指向就好了，这样就大大提高了性能，同时如果重复创建相同的数据，相当于浪费存储空间了；当然由于性能和占用空间资源的权衡，底层池子里数据的范围不会很大，不应该造成数组的长度过长，过度占用空间的情况 自动装箱和拆箱：编译器自动会我们做了转换，经查看字节码，装箱其实就是调用了包装类的valueOf()，实际就调用了构造器Integer(int i)方法，拆箱其实就是调用了xxxValue()，这个方法其实就是返回final int value；所以自动装箱和拆箱也就是Java语法糖 String类的不可变性：对于String变量，每次重新赋值都是重新指向了一个对象而不是修改了原来的对象，这就导致String对象一经创建值就再也不会改变，因此需要大量修改字符串的操作不建议使用String；而它的不可变性究其原因是因为底层使用了final修饰的private变量存储字符串，同时没有提供任何的getter和setter；至于Java9后为什么改用byte数组存储字符串，原因是为了节省存储空间成员变量和局部变量1.局部变量是在代码块或方法中声明的变量，或是方法的参数深拷贝、浅拷贝、引用拷贝1.什么是拷贝：给定一个场景，我们需要多个相同的对象它们的各项属性都应该相同，那么我们应该采用拷贝的形式生产对象而不是new新对象，因为new新对象需要初始化操作，这样就会进行大量相同的初始化操作影响性能；而拷贝会新申请内存空间，同时保持属性值与原对象相同2.深拷贝和浅拷贝的区别：对于内部属性是引用类型的对象来说，浅拷贝最终的复制品内部属性与原对象是同一个，而深拷贝会另外申请空间存放这个内部属性；3.如何实现深拷贝：让内部属性在对象拷贝的同时也进行拷贝就行了；这样两者都会申请新的内存空间4.何为引用拷贝：即多份引用变量指向同一个对象，其他引用变量对于该引用变量就是引用拷贝抽象类和接口1.抽象类主要用于代码复用，而接口用于限制行为，比如实现了某种接口就拥有了某个行为2.什么叫做声明式接口：里面没有任何方法和属性，实现该接口就表示该类本身拥有某种能力；注意本身具有某种能力，也就是说并不是实现了声明式接口具有了某种能力，而是类本身就有这种能力，声明式接口只是作为一个标志，标识它由某种能力；Java种的两个声明式接口：Cloneable、Serializable；3.如果两个接口具有相同的方法，一个类又同时实现这两个接口，对于类来说实现这一个方法就等于同时实现了这两个接口中的方法Java反射机制1.在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法称为java语言的反射机制。2.反射的主要用法 创建实例 反射调用方法3.反射的应用场景 松耦合，通过工厂模式+配置模式的方式替换new生成对象的方法4.Method对象：现有一个问题：子类继承父类，并重写了父类中的方法A，那么此时在子类的Class对象中，Method数组对于A()是只有一个子类重写了的A()，还是说，父类的A()和子类的A()都在？ 经过源码分析：isAssignableFrom()该方法在searchMethod()方法用于判断方法返回类型是否属于父子类关系，如果returnType更小，则getMethod()会获得更小类型的那个方法，也就是说就算子类方法返回值类型与父类不同，最终调用的方法也还是子类的方法，另外，如果方法返回值相同，那么Method数组内部就只有一个子类重写的方法5.（Class&amp;lt;?&amp;gt;）clazz.newInstance()底层默认调用的依然是无参构造器，因而我们在声明了有参构造器的同时一定要显式声明无参构造器，因为Java底层很多都是利用无参构造器生成的对象；当然我们也可以手动调用有参构造器对象的newInstance()生成对象；注解1.注解是什么？ 注解和类、接口、枚举是同一级别的 注解是写给程序看的，往往出现在类、方法、成员变量、形参位置 它主要为当前读取该注解的程序提供判断依据及少量附加信息；如程序读到加了@Test的方法就知道这个方法是待测试方法；又比如@Before，程序读到它就知道该方法要放在@Test方法之前执行；还有@RequestMapping(“/user/info”)提供了Controller某个接口的URL； 总的来说，注解作为给程序读取的标注信息，往往利用完就会被抛弃，而这就涉及到保留策略了2.自定义注解的三步骤 定义注解 在程序中（类上、方法上、域上）使用注解 在其他程序读取注解信息，并执行3.注解的保留策略 注解通过保留策略，控制自己可以保留到哪个阶段。 保留策略也是通过注解实现，它属于元注解，也叫元数据。具体来说是通过元数据@Retention实现的 保留策略的实现有三种：SOURCE、ClASS、RUNTIME；分别对应着.java文件，.class文件，jvm的Class对象； 如果在自定义注解时不加@Retention，注解的保留策略默认是CLASS 使用各保留策略的注解例子：①@Override对应SOURCE，编译成.class文件就会消失 通常情况我们只会使用jdk注解、第三方框架注解，，三步骤中的定义注解、读取执行两个步骤用不着我们来做，都被jdk和框架封装隐藏了，这其实也导致了大部分人对注解的陌生异常1.不受检查异常，在Java编译过程当中，如果不受检查异常不以catch/throw处理就没办法通过编译2.并不是说finally子句一定会执行，finally子句不会执行的情况如下：①在finally之前，jvm被终止运行（System.exit(1)）②程序所在线程死亡③关闭CPU2.捕获异常 try-with-resource，jdk9之前： // 1.将配置文件加载进内存（自动关闭InputStream）try (InputStream inputStream = JdbcUtil.class.getResourceAsStream(&quot;/jdbc.properties&quot;)) { // 2.获取Properties参数 Properties prop = new Properties(); prop.load(inputStream); // 3.配置数据源 DruidDataSource dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(prop); // 4.配置JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);} catch (Exception e) { e.printStackTrace();}jdk9版本之后，不用在try语句块中声明变量了，直接在里面写上引用变量，多个变量之间用分号分隔就ok了 try-with-resource的出现也是为了解决finally语句的冗余，因为这些语句与业务代码没什么关系，放在代码里可读性会变得很差；泛型1.泛型是一种编译期的代码模板技术，具有存入时类型检查和取出时自动转型的优点。尤其要注意编译器；2.泛型的的出现是为了解决什么问题：以ArrayList为例，它的底层数组是Object数组类型的，也就是说当往Object数组中存入数据并且取出时就会产生两个问题： 需要强制类型转换 强制类型转换容易产生问题（比如如果有人在不经意的情况下传入了int类型的数据，而取出时强制转换成String，这样就会报错）3.泛型类型擦除与自动类型转换 仍然以ArrayList&amp;lt;T&amp;gt;为例，虽然这个时候ArrayList是个泛型类，并且我们传入类型参数User，但是ArrayList底层数组其实还是Object数组类型的；但是这与我们实际情况有点矛盾：传入不合适的数据编译器会报错；取出数据我们不需要类型强制转换；其实这些事情都由编译器自动帮我们完成了； 泛型是JDK专门为编译器创造的语法糖，只在编译期，由编译器负责解析，虚拟机不知情 存入：普通类继承泛型类并给变量类型T赋值后，就能强制让编译器帮忙进行类型校验 取出：代码编译时，编译器底层会根据实际类型参数自动进行类型转换，无需程序员在外部手动强转 ArrayList&amp;lt;T&amp;gt;在实际被编译后泛型参数就已经被擦除了，最终类型就是ArrayList；所以实际上根本不存在ArrayList&amp;lt;User&amp;gt;类型等泛型类型4.List&amp;lt;? extends Number&amp;gt; list对于传入的list只能做读操作，不能做写操作。5.泛型边界 泛型边界是为了让泛型操作模板化，一般会作为参数接收其他的泛型类，如果想要充分理解泛型边界那么理解这句话尤其重要 ArrayList&amp;lt;? extends Integer&amp;gt;，ArrayList&amp;lt;? super Integer&amp;gt;，前者add操作是不被允许的，后者可以存入Integer和它的子类；当我们考虑存入操作时往往要考虑取出操作，同时要明确引用具体的指向；例如前者它可以指向ArrayList&amp;lt;?&amp;gt;，这个？是Integer的子类，也就是说同一时刻ArrayList&amp;lt;? extends Integer&amp;gt;它只能指向一个，但是这些子类相互可能并没有继承关系，但实现强制转换时就容易出错，而后者之所以可以存入，是因为它指向的实际对象它们都有公共子类也就是Integer，也就是说只要存入的是Integer或它的子类就能正常向上转型 如果存入操作比较多，推荐使用ArrayList&amp;lt;? super Integer&amp;gt;，取出操作比较多推荐使用ArrayList&amp;lt;? extends Integer&amp;gt;，因为它接收的类型是Integer，而不是Object，相较而言更加精确，能使用的方法会更多 6.泛型类和泛型方法常见使用场景：封装统一结果类和工具方法时使用比较频繁7.静态方法不能使用泛型类的类型参数，因为类型参数的指定通常是在创建泛型类的时候；5.什么叫做Java语法糖语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。JDK动态代理 动态代理的使用场景多个实现了某个接口的类们，这些接口方法都需要调用一类通用方法，这样每个实现类就需要在方法内部调用这个方法，这样确实实现的代码复用，但是（按照内联方法的思想，方法经调用之后就被替换成方法体，也就是说实际上本身对这些方法的调用是不是就是冗余了）由于每个实现类对于这个方法都要调用同一段代码，这本身似乎就是代码冗余，有没有一种方法可以让各个实现类在实现方法时只关心它本身的业务而不用关心通用的那部分，这就需要用到JDK动态代理，利用调用处理器的invoke()规定好通用方法与实现方法的关系，然后创建实现类的代理对象，实现调用方法时，调用的就是代理对象的invoke方法 使用动态代理的流程，如下图：静态代理 静态代理的实现流程，如下图：静态代理和JDK动态代理的区别 JDK动态代理不用可以编写代理类，由jdk为我们提供的Proxy作为代理类，在动态代理中我们只在意代理对象和增强代码，因而代理类对我们来说是多余的，我们只要能获取到代理对象就OK了 JDK动态代理的增强代码不与代理类耦合 代理就是俄罗斯套娃，层层封装，层层屏蔽序列化和反序列化1.通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化2.被transient关键字修饰的属性值不会被保存进序列化文件，故反序列化后的属性值是变量类型的默认值。3.虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（private static final long serialVersionUID）4.static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。5.在SpringMVC中用@RequestBody将json对象转换成java对象是反序列化吗？高内聚低耦合1.松耦合的目的 某一模块更改下，不会影响到其他模块；模块之家更加独立，这样在维护代码时就不会产生该一处代码，带动其他模块大量的代码改动匿名内部类1.在方法内部定义的匿名内部类（局部匿名类）如何使用方法中定义的局部变量，包括基本数据类型、字符字面量、引用变量源代码：反编译结果：1.可见局部匿名类使用外部基本数据类型或者字符串常量时会直接用字面量替换，而使用引用类型变量时会在内部定义相同的有final修饰的属性，并通过构造器用外部引用变量初始化，保证二者操作同一个对象（语义相同）2.如果局部变量被内部类引用，要么变量用final修饰，要么就不在内部修改（最终还是保证：内部类的final变量与外部变量操作的是同一个对象），否则会报编译错误（另外final修饰的基本数据类型变量和字符字面量赋值的变量，经过编译后不会使用变量（或许是jvm中提到的字符引用），而会直接用字面量替换（或许是jvm中提到的直接引用））函数式接口1.Java内置四大核心函数式接口，java.util.function包下定义了各式各样的函数式接口2.如何理解函数式接口lambda表达式1.为什么Comparator可以使用lambda表达式，它明明由两个抽象方法：如下：总的来说：如果一个接口没有直接父接口，就会隐式声明一个与Object公共方法（非final）相同（或者说符合子类覆盖原则的方法）；当然如果直接显示声明了一个Object中的方法，就不是再隐式声明一个了。注意接口在被实现类实现时这个方法会自动实现2.函数式接口只能有一个抽象方法，而对于匿名类的实现，接口中可以有多个抽象方法，只需要再匿名类中全部实现就可以了3.lambda表达式与匿名类的区别下面看看lambda表达式的反编译结果：原始lambda：反编译lambda：可见lambda和匿名类的实现并不相同，lambda并不是匿名类的语法糖。2.lambda的本质3.lambda的独特性lambda可以让我们决定方法的实现，也就是说实现了方法的多态，这是Java函数式编程与其他脚本语言函数式编程的区别" }, { "title": "JVM", "url": "/posts/JVM/", "categories": "JVM", "tags": "", "date": "2022-03-16 00:00:00 +0800", "snippet": "类加载1.字节码文件经过类加载器加载后会获得Class对象，也可以说Class对象是类加载的最终产品2.类加载过程 类加载过程分三个阶段：1.Loading；2.Linking；3.Initialization3.类变量的加载过程 在linking/prepare阶段进行零值初始化 在Initialization阶段按照语句（赋值动作和静态代码块）在源文件出现的顺序执行clinit方法，对类变量进行重新赋值4.Class对象是存放在堆区的，不是方法区。 类的元数据（元数据并不是类的Class对象！Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的）才是存在方法区的。在一个JVM实例的内部，类型信息被存储在一个称为方法区的内存逻辑区中。5.静态方法和私有方法都是在类加载阶段解析的，它们的符号引用在类加载阶段或者第一次使用时被转化成直接引用，同时这种转化被称作静态解析；静态方法和私有方法不可被重写就与这条机制有关实际类型和静态类型class Human{ } class Man extends Human{ } class Woman extends Human{ } Human man = new Man（）; 这里的Human就称为静态类型，而后面的Man称为实际类型；静态类型在编译器就可知，而实际类型需要在JVM运行时才可知；" }, { "title": "关系型数据库和数据模型相关概念", "url": "/posts/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/", "categories": "数据库, MySQL", "tags": "", "date": "2022-03-05 00:00:00 +0800", "snippet": "数据库阶段学习数据库初级、中级、高级知识点介绍：数据库相关概念1.数据库：存储数据的地方，数据是有组织的存储在数据库的2.数据库管理系统（DBMS）：操纵和管理数据库的大型软件3.SQL：操作关系型数据的编程语言，定义了一套操作关系型数据库的统一标准（不同数据库都遵照该标准，都可以用SQL语句操作）MySQL数据库的安装和启动注意：安装新的MySQL之前需要先卸载已经下载的旧的MySQLMySQL8.0.26配置界面：MySQL默认端口号是3306启动MySQL服务有两种方式：1.win+s ==&amp;gt; services.msc打开Windows服务 ==&amp;gt; 找到mysql，右键打开/关闭2.以管理员身份启动PowerShell打开/关闭MySQL服务 打开命令：net start mysql关闭命令：net stop mysql注意：mysql是MySQL在Windows中注册的服务名，可能会有不同，比如MySQL8.0.* ,默认的服务名是mysql80MySQL客户端连接MySQL服务 连接本机的MySQL服务 在PowerShell下输入mysql -u root -p，然后输入密码,密码正确则成功连接MySQL服务，注意：在任意目录下使用msyql命令需要配置Windows环境变量 连接远程主机的的MySQL服务 mysql -h 192.168.0.195 -P 3306 -uroot -p，h代表远程主机的IP地址，大写的P代表MySQL服务监听的端口号 关系型数据库-数据模型MySQL数据模型建立在关系模型基础上，由多张相互连接的二维表组成的数据库，特点： 统一使用表格式存储数据，便于维护统一使用SQL标准操作" }, { "title": "msyql数据库", "url": "/posts/msyql%E6%95%B0%E6%8D%AE%E5%BA%93/", "categories": "数据库, MySQL", "tags": "", "date": "2022-03-05 00:00:00 +0800", "snippet": "触发器触发器是特殊的存储过程（一段能产生特定影响的sql语句），它没有参数，相比于sql约束（像非空约束，唯一约束，check约束）触发器能完成更复杂的约束。创建触发器create trigger 触发器名after|before update|insert|delete on 联系表名 for each rowbegin 触发体end例如：create trigger delete_triggerafter delete on department for each rowinsert into merch_log(who, oper_date) values(user(), sysdate());删除触发器drop trigger 触发器名;触发器性质for each row 任何一条记录上的操作满足触发事件都会激活该触发器，毫无疑问触发器对联系表具有访问权，同时MySQL定义了new表和old表，new表是update或insert之后的联系表，old表是delete或update之前的联系表，触发器对这两个表也具有访问权限。数据库索引1.索引是为了加快查询效率的一种数据结构，例如主键会自动加上唯一索引以加快查询效率（比如我们通常以主键为条件select）2.唯一索引 任何与null比较的返回值都是null，包括null与null比较，但是带唯一约束的字段可以为null，但不能存在两个null，因为唯一约束规定null和null相同2.外键 为了保证数据的一致性和正确性，我们往往会使用外键。例如1，在级联更新下，学生表中stu_id是主键，成绩表中stu_id是外键，如果在主表中stu_id发生变化，那么为了保证一致性从表中也会更新；例如2，当我们向成绩表中插入数据时，为了保证正确性会检查stu_id在学生表中是否存在，如果不存在则会插入失败； 添加外键索引 创建成绩表时添加：foreign key(stu_id) references t_student(stu_id)； 创建表后才添加：ALTER TABLE t_score add constraint &quot;t_score_fk1&quot; foreign key(stu_id) references t_student(stu_id)； 外键的优点 保证了数据库数据的一致性和完整性； 级联操作方便，减轻了程序代码量； 外键的缺点 外键影响数据库的插入速度； 级联更新是强阻塞，存在数据库更新风暴的风险； 使用外键存在的问题 外键的主从关系是定的，但是需求确实变化的，如果字段不在需要与其他表关联就会增加麻烦； 由于外键约束的存在，每次做级联更新和删除时都需要仔细考虑后果； 外键还会因为需要请求对其他表内部加锁而容易出现死锁情况； 对分库分表不友好 ：因为分库分表下外键是无法生效的； 外键的适用场景：外键与级联更新适用于单机低并发，不适合分布式、高并发集群；数据库设计1.三大范式 第一范式：字段不可再分 第二范式：在第一范式的基础上，所有非主属性完全依赖主键 第三范式：在第二范式的基础上，所有非主属性直接依赖主键2.ER图：实体关系图，适用它可以清楚的表示实体之间的关系，例如：由角色，和权限两种实体，其中一个角色可以拥有多条权限，而一条权限可以被不同的角色拥有，因此角色和权限之间是多对多的关系，另外还有一对一，一对多等关系 正方形表示实体 菱形表示关系实体 圆形表示实体属性3.字符集 不同字符集能表示的字符范围不同，存储字符使用的字节数也不同 Unicode 字符集是如今使用最多的一种字符集，它有多种编码实现，其中包括utf-8、utf-16、utf-32。 在数据库中对于utf-8有两套实现，分别是utf-8、utfmb4。而utfmb4能表示的字符范围更广、可以表示emoji字符以及一些复杂的汉字。 如果往CHARSET=utf-8的数据库中存入emoji字符会报错，因此应该使用utfmb4字符集。数据库事务1.事务ACID特性：以MySQL的InnoDB存储引擎为例 A：原子性（atom），即以事务为最小单位，事务内的所有操作要么都成功要么都失败；依靠回滚日志（undo log）实现 I：隔离性（Isolation），并发事务不会互相影响；依靠锁机制和MVCC实现 D：持久性（durable），事务执行成功后对数据产生的影响是持久的，及时数据库发生故障，影响依然存在；依靠重做日志（redo log）实现 C：一致性（consistency），即事务执行前后，数据依然保持逻辑一致性，这个逻辑一致性一般符合现实逻辑，或由DBA指定的规则；上述三者实现后，一致性才能实现2.事务并发产生的响应 幻读和不可重复读的区别：不可重复读在于对同一条记录进行多次查询时发现某些列被改变，而幻读在于多次查询时发现记录增加或者减少了，而实际查询得到的结果又不同（由于可重复读生效，导致每次读到的结果与第一次读到的结果相同）。3.MySQL的默认事务隔离级别 命令行查看方式 select @@tx_isolation; InnoDB默认隔离级别是repeatable-read，需要应用加锁读实现，这个加锁实现依靠的就是next-key Locks（兼具记录锁和间隙锁的特点，既锁行又锁范围） InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。数据持久化1.什么叫做持久化：把数据存入可掉电式存储设备中以供后续使用；而持久化的过程大多通过关系型数据库完成2.数据库存取技术之JDBC：是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口；而JDBC和数据库驱动的关系其实就是接口和实现类的关系；3.对于Java程序来说如果没有JDBC程序会怎么样：与不同的数据库管理系统进行连接的时候，每针对一个数据库管理系统我们就需要写一套实现；显然对开发做出了很高的要求，不利于开发效率，而有了JDBC的存在，我们就只需要写一套实现就OK了，其实有点类似于工厂方法，JDBC就像抽象工厂用于涉及一整套连接数据库的规范，而针对不同的数据库的工厂实现类（数据库驱动）就由数据库开发商开发4.使用JDBC实现数据库连接的具体实现流程是怎样的？5.JDBC URL：如jdbc:mysql://localhost:3306，注意jdbc称为协议名，mysql称为子协议名主要用于表示数据库驱动，后面的称为子名称主要用于定位数据库，整个URL主要提供给驱动器管理器DriverManager选择正确的数据库驱动；跟Http协议比起来它并不是传输数据的协议6.注册数据库驱动这一步骤主要干了什么？在一个项目中有可能会使用多种数据库系统，而这一步就是将这些数据库对象的数据库驱动信息保存在一个数组里，但获取连接时会用URL去这个数组进行一一比对，以获取到正确的数据库驱动程序去连接对应的数据库7.jpa和jdbc的区别：jpa是orm规范，orm旨在通过操作实体类就能直接操作数据表，尽量避免大量的SQL语句的编写；jdbc是Java程序访问数据库的统一规范；jpa的实现底层还是要借助jdbc的，毕竟还是要和数据库交互，只不过如果使用jpa我们就不用去管怎么去编写具体的SQL语句，不用关心怎么将关系字段与对象属性一一对应；" }, { "title": "SQL分类", "url": "/posts/SQL%E5%88%86%E7%B1%BB/", "categories": "数据库, MySQL", "tags": "", "date": "2022-03-05 00:00:00 +0800", "snippet": "SQLSQL语句通用语法1.SQL语句可单行也可多行书写，以分号结尾。2.SQL关键词应该大写，统一规范SQL分类DDL数据库操作查询所有数据库mysql&amp;gt; show databases;创建数据库mysql&amp;gt; create database [if not exists] test_db [default charset utf8mb4];注意：UTF8字符集长度为3字节，有些符号占4字节，如Emoji表情符号，所以推荐用utf8mb4字符集使用数据库mysql&amp;gt; use test_db;查询当前使用的数据库mysql&amp;gt; select database();删除数据库mysql&amp;gt; drop database [if exists] test_db;表操作创建表mysql&amp;gt; create table [if not exists] t_user( id int [comment &#39;编号&#39;], name varchar(20) [comment &#39;姓名&#39;], age int comment [&#39;年龄&#39;], gender varchar(1) comment [&#39;性别&#39;])comment &#39;用户表&#39;;int 类型默认11位；查询所有的表mysql&amp;gt; show tables;查询表的结构mysql&amp;gt; desc t_user;查询表的创建语句mysql&amp;gt; show create table t_user;重命名表MySQL&amp;gt; alter table t_user rename to user;删除表-- 第一种方法mysql&amp;gt; drop table [if exists] employee; # 删除整张表，从内存清除-- 第二种方法mysql&amp;gt; truncate table employee; # 删除表，并重新创建，自增值重置，索引恢复初始大小-- 第三种方式mysql&amp;gt; delete from table; # 删除所有表记录，并生成日志以便回滚处理效率：drop &amp;gt; trustcate &amp;gt; delete字段操作添加字段mysql&amp;gt; alter table t_user add address varchar(100) comment &#39;住址&#39;;删除字段mysql&amp;gt; alter table t_user drop address;修改字段类型mysql&amp;gt; alter table t_user modify address varchar(200) comment &#39;住址&#39;;修改字段名和字段类型mysql&amp;gt; alter table t_user change address family_address varchar(234) comment &#39;家庭住址&#39;;DDL数据类型数值类型字符串类型varchar需要指明长度，即varchar(length)，否则报错，而char不指定长度为1，即char(1)；varchar会根据存储的内容决定需要多大的存储空间，而char的长度一经指定不在改变，总是申请固定长度的空间日期类型示例mysql&amp;gt; create table employee( id int comment &#39;编号&#39;, empno varchar(10) comment &#39;员工工号&#39;, name varchar(10) comment &#39;员工姓名&#39;, gender char(1) comment &#39;性别&#39;, age tinyint unsigned comment &#39;年龄&#39;, identifyno char(18) comment &#39;身份证号&#39;, employdate date comment &#39;入职时间&#39;)comment &#39;员工信息表&#39;;从我们的设计可见，对于长度固定的字符串，我们使用char，对于绝对非负的数据就用unsigned修饰DDL语句总结相比DML,DDL语句通常需要加上table/database关键词，毕竟DDL操作的对象有数据库、表、和字段，而且增删改等使用的关键词可能相同，因而要指明操作的是什么对象，即是数据库还是表，或者是哪个表的哪个字段例如：-- DDLdrop database test1;drop table t_user;truncate table t_user; alter table t_user ADD constraint foreign key(user_id) references t_score(user_id);-- DMLselect * from t_user;insert into t_user(id, username, password) values(1, &quot;flameking&quot;, &quot;123456&quot;);update t_user set name=&quot;Casflawed&quot;,password=&quot;654321&quot; where id=1;DMLDML全称Data Maniputation language（数据操作语言），用来对数据库表记录进行增删改操作，即insert，delete，updateinsert添加数据给指定字段添加数据mysql&amp;gt; insert into user(`id`, `name`, `age`) values(1, &#39;flameking&#39;, 21);给全部字段添加数据mysql&amp;gt; insert into user values(1, &#39;flameking&#39;, 21, &#39;男&#39;, &#39;河南&#39;, &#39;1&#39;);批量添加数据mysql&amp;gt; insert into user(`id`, `name`, `age`) values(1, &#39;flameking&#39;, 21),(2, &#39;Casflawed&#39;,22),(3,&#39;oneway&#39;,23);mysql&amp;gt; insert into user values(1, &#39;flameking&#39;, 21, &#39;男&#39;, &#39;河南&#39;, &#39;1&#39;),(5,&#39;casflawed&#39;,28,&#39;女&#39;,&#39;湖南&#39;,&#39;0&#39;);注意： 字符串和日期型数据应该包含在引号中 插入数据顺序必须和指定的数据一一对应 插入的数据大小应该在字段范围内update更新记录形如：update 表名 set 字段名1=值1, 字段名2=值2,.....[where 条件]mysql&amp;gt; update user set name=&quot;Casflawed&quot; where id=1;-- 如果没有条件则会修改整张表的数据mysql&amp;gt; update user set family_address=&quot;湖南&quot;;delete删除记录形如：delete from 表名 [where 条件]mysql&amp;gt; delete from user where id = 1;-- 如果不带条件则会删除整张表的记录delete from user;DQL单表查询基本查询操作的表结构和记录：1.查询指定字段select name, workno, age from emp;2.查询所有字段select * from emp;3.查询所有员工的工作地址，起别名-- 别名的意义是为了更好的理解字段，因此这里使用中文别名方便用户更容易理解select workaddress as 工作地址 from emp;4.查询不重复的员工地址-- 关键词 distinctselect distinct workaddress from emp;条件查询可能的条件： 注意：1.MySQL 使用三值逻辑 —— TRUE, FALSE 和 UNKNOWN。任何与 NULL 值进行的比较都会得到第三种值 UNKNOWN。这个“任何值”包括 NULL 本身！这就是为什么 MySQL 提供 IS NULL 和 IS NOT NULL 两种操作来对 NULL 特殊判断。2.is关键词不能随便用，在null中可以用，但在in中不可以用，注意语法正确1.查询年龄等于88的员工select * from emp where age = 88;2.查询年龄小于20的员工信息select * from emp where age &amp;lt; 20;3.查询年龄小于等于20的员工信息select * from emp where age &amp;lt;= 20;4.查询没有身份证号的员工信息select * from emp where idcard is null;5.查询有身份证号的员工信息select * from emp where idcard is not null;6.查询年龄不等于88的员工信息select * from emp where age != 88;select * from emp where age &amp;lt;&amp;gt; 88;7.查询年龄在15岁（包含）到20岁（包含）之间的员工信息select * from emp where age between 15 and 20;select * from emp where 15 &amp;lt;= age and age &amp;lt;= 20;select * from emp where 15 &amp;lt;= age &amp;amp;&amp;amp; age &amp;lt;= 20;-- 如果between后跟大值会怎么样select * from emp where age between 20 and 15; # 语句部分报错，但返回空的结果集（Empty set）8.查询性别为女且年龄小于25岁的员工信息select * from emp where gender = &#39;女&#39; &amp;amp;&amp;amp; age &amp;lt; 25;9.查询年龄等于18或20或40的员工信息select * from emp where age = 18 or age = 20 or age = 40;select * from emp where age in(18,20,40);in可以用来简写有多个or语句的条件10.查询姓名为两个字的员工信息select * from emp where name like &#39;__&#39;;11.查询身份证信息最后一位是X的员工信息select * from emp where idcard like &#39;%X&#39;;select * from emp where idcard like &#39;_________________X&#39;; #有17个下划线聚合函数聚合函数简介：1.统计该企业员工数量select count(*) from emp;-- 或者是任意字段select count(id) from emp;2.统计该企业员工的平均年龄select avg(age) from emp;3.统计该企业员工的最大年龄select max(age) from emp;4.统计该企业员工的最小年龄select min(age) from emp;5.统计西安地区员工的年龄之和select sum(age) from emp where workaddress=&#39;西安&#39;分组查询形如：select * from 表名 [where 条件] group by 分组字段名 [having 分组后的过滤条件]where条件和having条件的区别：1.执行时机不同，where条件在分组前执行，不符合的记录不参与分组，having条件对分组后的结果集执行2.判断条件不同，where条件不能对聚合函数进行判断，having可以练习：1.根据性别分组，统计男性员工和女性员工的数量select gender, count(*) from emp group by gender;2.根据性别分组，统计男性员工和女性员工的平均年龄select gender, avg(age) from emp group by gender;3.查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress,count(*) emp_count from emp where age &amp;lt; 45 group by workaddress having emp_count &amp;gt;= 3;注意：1.执行顺序where条件&amp;gt;聚合函数&amp;gt;having条件2.分组之后一般select分组字段和聚合函数，查询其他字段没有意义排序查询-- 由此可见：SQL支持多字段排序，排序规则是，如果字段1相同就按字段2排序形如：select 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;-- 排序方式1.ASC，升序（默认）2.DESC，降序练习：1.根据年龄对公司的员工进行升序排序select * from emp order by age asc;2.更具入职时间，对员工进行降序排序select * from emp order by entrydate desc;3.根据年龄对公司的员工进行升序排序，年龄相同再按入职时间进行降序排序select * from emp order by age, entrydate desc;分页查询练习：1.查询第1页员工数据，每页展示10条数据-- 如果起始索引是0，可以省略select * from emp limit 10;2.查询第2页员工数据，每页展示10条记录select * from emp limit 1, 10;单表查询案例练习1.查询年龄为20,21,22,23岁的员工信息select * from emp where age in(20,21,22,23);2.查询性别为男，并且年龄在20-40岁(含)以内的姓名为三个字的员工select * from emp where gender=&#39;男&#39; and (age between 20 and 40) and name like &#39;___&#39;;3.统计员工表中，年龄小于60岁的，男性员工和女性员工的人数select gender,count(*) from emp where age &amp;lt; 60 group by gender;4.查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排列，如果年龄相同按入职时间降序排序select name, age from emp where age &amp;lt;= 35 order by age, entrydate desc;5.查询性别为男，且年龄在20-40岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序select * from emp where gender=&#39;男&#39; and (age between 20 and 40) order by age,entrydate desc limit 5;补充知识：1.WHERE子句 where作为筛选语句会根据表记录从头到尾进行比较where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。在MySQL中，false也可以用0表示，true也可以用1表示2.连接查询 即将两个表的字段连接起来3.存储过程(预编译的SQL集合) 优点：因为是预编译过的，因此执行速度会更快难以调试和扩展DQL语句执行顺序注意：group by和having都可以使用select中的别名DCL用来管理数据库用户，控制数据库的访问权限（简单来说就是哪些数据库能被那些用户访问）DCL-管理用户查询用户use mysql; # 用户信息表放在了系统数据库mysql中select * from user;Host和User两个字段共同定义一个用户，表示当前用户能在哪台主机上访问数据库服务器，localhost代表用户只能从本地访问数据库，@%代表用户可以从任意远程计算机访问数据库创建用户1.创建只能本都访问数据库的用户create user &#39;flameking&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;2.创建能在任意主机访问数据库服务的用户create user if not exists &#39;casflawed&#39;@&#39;%&#39; identified by &#39;123456&#39;;-- 如果不加@&#39;%&#39;，默认是允许访问任意主机上的数据库服务器create user if not exists &#39;casflawed&#39; identified by &#39;123456&#39;;用通配符%代表任意主机，同时上面两种方式创建的用户没有分配任何权限；修改用户密码alter user &#39;flameking&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;123&#39;;其中mysql_native_password代表MySQL的密码加密方式删除用户drop user &#39;flameking&#39;@&#39;localhost&#39;;DCL-权限控制前面我们创建用户的时候，发现刚被创建出来的用户可以登录但做不了任何事情，这是因为我们还没分配任何权限查询用户的权限show grants for &#39;casflawed&#39;@&#39;%&#39;;授予用户权限形如：grant 权限列表 on 数据库名.表名 to 用户;grant all on *.* to &#39;casflawed&#39;@&#39;%&#39;; # 经过这段sql授权后，casflawed相当于root，即超级管理员撤销用户权限形如：revoke 权限列表 on 数据库名.表名 from 用户;revoke drop,update on *.* from &#39;casflawed&#39;@&#39;%&#39;;注意：多个权限之间用‘，’分隔" } ]
