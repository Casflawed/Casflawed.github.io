---
title: 详解桶排序及排序大总结
date: 2022-07-06 +/-TTTT
categories: [算法与数据结构]
tags: []     # TAG names should always be lowercase
---

# 二叉树
## 完全二叉树和满二叉树
![完全二叉树和满二叉树](/blog/202207071033429.jpg "Optional title")

## 二叉树的高度
如果二叉树只有根节点，那么高度为1

## 数组与完全二叉树
按照数组的顺序，依次填满完全二叉树：我们发现<br>
![数组对应成二叉树](/blog/202207071041816.jpg "数组对应成二叉树")

即对于节点A，下标为n，左孩子对应下标为：`2n+1`，右孩子对应下标为：`2n+2`，父节点对应下标为：`n-1/2`

# 堆、大根堆和小根堆
堆本质上就是完全二叉树，大根堆特性：对于任意根节点n都有`value(n)>=value(2n+1)&&value(n)>=value(2n+2)`，即对于任意父节点所有的子树节点都比它小；小根堆则相反

## 数组与堆
![heapInsert调堆](/blog/202207071103859.jpg "heapInsert调堆")

像这样大根堆起初的heapSize为0，不断追加数组中的元素，heapSize++，同时会执行heapInsert过程调正大根堆，heapInsert是由子节点不断往上替换小值的过程<br>
**直到`value(n)\<value((n-1/2))`或`n=0`**

## 移除堆的根元素
首先如何从堆中排除根元素：<br>
![排除根元素](/blog/202207071142336.jpg "排除根元素")

**因为经过heapInsert过程，堆的首元素就是根元素，将根元素与堆末尾元素交换，然后heapSize--就排除了根元素，此时数组长度-堆长度等于1**

然后heapify：<br>
![heapify过程](/blog/202207071151898.jpg "heapify过程")

heapify过程大致如下：<br>
父元素等于左右子树中较大者比较，如果父元素小，交换，否则不动，直到没有左右子树，即2n+1>=heapSize停止heapify过程；<br>
我们发现heapify是一个向下的过程

## 替换堆的某个节点
需要先判断是应该执行heapInsert还是heapify过程，如果以该数为根节点的子树依然满足大根堆，说明不用执行heapify过程，如果该数所在的子树也满足大根堆说明也不用heapInsert过程