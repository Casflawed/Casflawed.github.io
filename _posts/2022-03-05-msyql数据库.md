---
title: msyql数据库
date: 2022-03-05 +/-TTTT
categories: [数据库, MySQL]
tags: []     # TAG names should always be lowercase
---

## 数据库阶段学习
下面是数据库初级、中级、高级的知识内容：
![数据库学习概况](/blog/202205052232877.png "数据库学习概况")

## 数据库相关概念

1.数据库：存储数据的地方，数据是有组织的存储
2.数据库管理系统（DBMS）：操纵和管理数据库的大型软件
3.SQL：操作关系型数据的的编程语言，定义了一套操作关系型数据库的统一标准（为什么说是统一标准？因为对于不同的数据库我们都是统一用SQL编程语言操作）

![用户、SQL、DBMS、DB](/blog/202205052244913.png "用户、SQL、DBMS、DB")

## MySQL数据库的安装和启动
**注意**：安装新的MySQL之前需要先卸载已经下载的旧的MySQL

MySQL8.0.26配置界面：

![MySQL配置界面](/blog/202205052254380.png "MySQL配置界面")

可见MySQL默认端口号是3306

### 启动MySQL服务
有两种方式：

1.win+s，services.msc 打开Windows服务，找到mysql，右键打开/关闭即可

2.命令行打开关闭MySQL

**注意**：需要以管理员身份运行命令行

打开命令：net start mysql 关闭命令：net stop mysql，其中mysql是注册的MySQL服务名，可能会有不同，比如MySQL8.0.* ,默认的服务名是mysql80

### 客户端连接
其实客户端就是命令行中输入的mysql，连接客户端需要登录，验证用户身份，默认用户身份是root，连接命令如下：

mysql -uroot -p，然后输入密码即可

**当然要想在任意目录下使用Windows命令行连接客户端的前提是你配置了环境变量**

如何是远程连接不同主机的的MySQL，命令应该是这样的：

mysql -h 127.0.0.1 -P 3306 -uroot -p，注意是大写的P，否则命令不成功

## MySQL数据模型
### 关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库

特点：

1.使用表存储数据，格式统一，便于维护

2.使用SQL编程语言操作，标准统一，便于使用

### 关系型数据库-数据模型
![数据模型](/blog/202205052333543.png "数据模型")

## SQL
### SQL语句通用语法
1.SQL语句可单行也可多行书写，以分号结尾。

2.SQL关键词应该大写，统一规范

### SQL分类
![SQL分类](/blog/202205062331875.png "SQL分类")


### DDL
#### 数据库操作
1.查询所有数据库
```sql
mysql> show databases;
```

2.创建数据库
```sql
mysql> create database [if not exists] test_db [default charset utf8mb4];
```

3.使用数据库
```sql
mysql> use test_db;
```

4.查询当前使用的数据库
```sql
mysql> select database();
```

5.删除数据库
```sql
mysql> drop database [if exists] test_db;
```

#### 表操作
1.创建表

```sql
mysql> create table [if not exists] t_user(
    id int [comment '编号'],
    name varchar(20) [comment '姓名'],
    age int comment ['年龄'],
    gender varchar(1) comment ['性别']
)comment '用户表';

int 类型默认11位；
```

2.查询所有的表

```sql
mysql> show tables;
```

3.查询表的结构

```sql
mysql> desc t_user;
```

4.查询表的创建语句

```sql
mysql> show create table t_user;
```

5.重命名表

```sql
MySQL> alter table t_user rename to user;
```

6.删除表

```sql
-- 第一种方法
mysql> drop table [if exists] employee; # 删除整张表，从内存清除

-- 第二种方法
mysql> truncate table employee; #删除表，并重新创建
```

相比truncate，delete语句在执行时会生成日志，以便回滚；而truncate会重置自增值，并恢复索引为初始大小；drop语句会直接清空表内存

#### 字段操作
1.添加字段

```sql
mysql> alter table t_user add address varchar(100) comment '住址';
```

2.删除字段

```sql
mysql> alter table t_user drop address;
```

3.修改字段类型

```sql
mysql> alter table t_user modify address varchar(200) comment '住址';
```

4.修改字段名和字段类型

```sql
mysql> alter table t_user change address family_address varchar(234) comment '家庭住址';
```

#### DDL数据类型
##### 数值类型
![数值类型](/blog/202205072339382.png "数值类型")

##### 字符串类型
![字符串类型](/blog/202205072346561.png "字符串类型")

varchar需要指明长度，即varchar(length)，否则报错，而char不指定长度为1，即char(1)；

##### 日期类型
![日期类型](/blog/202205072348614.png "日期类型")

##### 示例
![示例](/blog/202205072349213.png "示例")

```sql
mysql> create table employee(
    id int comment '编号',
    empno varchar(10) comment '员工工号',
    name varchar(10) comment '员工姓名',
    gender char(1) comment '性别',
    age tinyint unsigned comment '年龄',
    identifyno char(18) comment '身份证号',
    employdate date comment '入职时间'
)comment '员工信息表';
```

**从我们的设计可见，对于长度固定的字符串，我们使用char，对于绝对非负的数据就用unsigned修饰**


#### DDL语句总结
![DDL语句总结](/blog/202205090026639.png "DDL语句总结")

- 相比DML,DDL语句通常需要加上table关键词，毕竟DDL操作的对象有数据库、表、和字段，而且增删改等使用的关键词可能相同，因而要指明操作的是什么对象，即是数据库还是表，或者是哪个表的哪个字段例如：
```SQL
-- DDL
drop database test1;
drop table t_user;
truncate table t_user; 
alter table t_user ADD constraint foreign key(user_id) references t_score(user_id);

-- DML
select * from t_user;<!DOCTYPE html>
insert into t_user(id, username, password) values(1, "flameking", "123456");
update t_user set name="Casflawed",password="654321" where id=1;
```


2.WHERE子句

- where作为筛选语句会根据表记录从头到尾进行比较
- where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
- 在MySQL中，false也可以用0表示，true也可以用1表示

3.连接查询

- 即将两个表的字段连接起来

3.存储过程：预编译的SQL集合

- 优点：因为是预编译过的，因此执行速度会更快
- 难以调试和扩展

## 触发器
触发器是特殊的存储过程（一段能产生特定影响的sql语句），它没有参数，相比于sql约束（像非空约束，唯一约束，check约束）<br/>
触发器能完成更复杂的约束。
### 创建触发器
```sql
create trigger 触发器名
after|before update|insert|delete on 联系表名 for each row
begin
    触发体
end
```
例如：
```sql
create trigger delete_trigger
after delete on department for each row
insert into merch_log(who, oper_date)
    values(user(), sysdate());
```
### 删除触发器
```sql
drop trigger 触发器名;
```
### 触发器性质
`for each row` 任何一条记录上的操作满足**触发事件**都会激活该触发器，毫无疑问触发器对联系表具有访问权，<br/>
同时MySQL定义了new表和old表，new表是update或insert之后的联系表，old表是delete或update之前的联系表，<br/>
触发器对这两个表也具有访问权限。

## 数据库索引
1.索引是为了加快查询效率的一种数据结构，例如主键会自动加上唯一索引以加快查询效率（比如我们通常以主键为条件select）
2.唯一索引

- 任何与null比较的返回值都是null，包括null与null比较，但是带唯一约束的字段可以为null，但不能存在两个null，因为唯一约束规定null和null相同

2.外键

- 为了保证数据的一致性和正确性，我们往往会使用外键。例如1，在级联更新下，学生表中stu_id是主键，成绩表中stu_id是外键，如果在主表中stu_id发生变化，那么为了保证**一致性**从表中也会更新；例如2，当我们向成绩表中插入数据时，为了保证**正确性**会检查stu_id在学生表中是否存在，如果不存在则会插入失败；
- 添加外键索引
    + 创建成绩表时添加：`foreign key(stu_id) references t_student(stu_id)`；
    + 创建表后才添加：`ALTER TABLE t_score add constraint "t_score_fk1" foreign key(stu_id) references t_student(stu_id)`；
- 外键的优点
    + 保证了数据库数据的一致性和完整性；
    + 级联操作方便，减轻了程序代码量；
- 外键的缺点
    + 外键影响数据库的插入速度；
    + 级联更新是强阻塞，存在数据库更新风暴的风险；
- 使用外键存在的问题
    + 外键的主从关系是定的，但是需求确实变化的，如果字段不在需要与其他表关联就会增加麻烦；
    + 由于外键约束的存在，每次做级联更新和删除时都需要仔细考虑后果；
    + 外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；
    + 对分库分表不友好 ：因为分库分表下外键是无法生效的；
- 外键的适用场景：外键与级联更新适用于单机低并发，不适合分布式、高并发集群；


## 数据库设计
1.三大范式

- 第一范式：字段不可再分
- 第二范式：在第一范式的基础上，所有非主属性完全依赖主键
- 第三范式：在第二范式的基础上，所有非主属性直接依赖主键

2.ER图：实体关系图，适用它可以清楚的表示实体之间的关系，例如：由角色，和权限两种实体，其中一个角色可以拥有多条权限，而一条权限可以被不同的角色拥有，因此角色和权限之间是多对多的关系，另外还有一对一，一对多等关系

- 正方形表示实体
- 菱形表示关系实体
- 圆形表示实体属性

3.字符集

- 不同字符集能表示的字符范围不同，存储字符使用的字节数也不同
- Unicode 字符集是如今使用最多的一种字符集，它有多种编码实现，其中包括utf-8、utf-16、utf-32。
- 在数据库中对于utf-8有两套实现，分别是utf-8、utfmb4。而utfmb4能表示的字符范围更广、可以表示emoji字符以及一些复杂的汉字。
- 如果往CHARSET=utf-8的数据库中存入emoji字符会报错，因此应该使用utfmb4字符集。

## 数据库事务
1.事务ACID特性：以MySQL的InnoDB存储引擎为例

- A：原子性（atom），即以事务为最小单位，事务内的所有操作要么都成功要么都失败；依靠回滚日志（undo log）实现
- I：隔离性（Isolation），并发事务不会互相影响；依靠锁机制和MVCC实现
- D：持久性（durable），事务执行成功后对数据产生的影响是持久的，及时数据库发生故障，影响依然存在；依靠重做日志（redo log）实现
- C：一致性（consistency），即事务执行前后，数据依然保持逻辑一致性，这个逻辑一致性一般符合现实逻辑，或由DBA指定的规则；上述三者实现后，一致性才能实现

2.事务并发产生的响应

- 幻读和不可重复读的区别：不可重复读在于对同一条表记录进行多次查询时发现某些列被改变，而幻读在于多次查询时发现记录增加或者减少了。

3.MySQL的默认事务隔离级别

- 命令行查看方式
```SQL
select @@tx_isolation;
```
- InnoDB默认隔离级别是repeatable-read，需要应用加锁读实现，这个加锁实现依靠的就是next-key Locks（兼具记录锁和间隙锁的特点，既锁行又锁范围）
- InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。

## 数据持久化
1.什么叫做持久化：把数据存入可掉电式存储设备中以供后续使用；而持久化的过程大多通过关系型数据库完成

2.数据库存取技术之JDBC：是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口；而JDBC和数据库驱动的关系其实就是接口和实现类的关系；

3.对于Java程序来说如果没有JDBC程序会怎么样：与不同的数据库管理系统进行连接的时候，每针对一个数据库管理系统我们就需要写一套实现；显然对开发做出了很高的要求，不利于开发效率，而有了JDBC的存在，我们就只需要写一套实现就OK了，其实有点类似于工厂方法，JDBC就像抽象工厂用于涉及一整套连接数据库的规范，而针对不同的数据库的工厂实现类（数据库驱动）就由数据库开发商开发

4.使用JDBC实现数据库连接的具体实现流程是怎样的？

5.JDBC URL：如jdbc:mysql://localhost:3306，注意jdbc称为协议名，mysql称为子协议名主要用于表示数据库驱动，后面的称为子名称主要用于定位数据库，整个URL主要提供给驱动器管理器DriverManager选择正确的数据库驱动；跟Http协议比起来它并不是传输数据的协议

6.注册数据库驱动这一步骤主要干了什么？在一个项目中有可能会使用多种数据库系统，而这一步就是将这些数据库对象的数据库驱动信息保存在一个数组里，但获取连接时会用URL去这个数组进行一一比对，以获取到正确的数据库驱动程序去连接对应的数据库

7.jpa和jdbc的区别：jpa是orm规范，orm旨在通过操作实体类就能直接操作数据表，尽量避免大量的SQL语句的编写；jdbc是Java程序访问数据库的统一规范；jpa的实现底层还是要借助jdbc的，毕竟还是要和数据库交互，只不过如果使用jpa我们就不用去管怎么去编写具体的SQL语句，不用关心怎么将关系字段与对象属性一一对应；