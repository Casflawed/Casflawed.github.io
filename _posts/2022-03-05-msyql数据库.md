---
title: msyql数据库
date: 2022-03-05 +/-TTTT
categories: [数据库, MySQL]
tags: []     # TAG names should always be lowercase
---

## 数据库阶段学习
下面是数据库初级、中级、高级的知识内容：
![数据库学习概况](/blog/202205052232877.png "数据库学习概况")

## 数据库相关概念

1.数据库：存储数据的地方，数据是有组织的存储<br>
2.数据库管理系统（DBMS）：操纵和管理数据库的大型软件<br>
3.SQL：操作关系型数据的编程语言，定义了一套操作关系型数据库的统一标准（为什么说是统一标准？因为对于不同的数据库我们都是统一用SQL编程语言操作）<br>

![用户、SQL、DBMS、DB](/blog/202205052244913.png "用户、SQL、DBMS、DB")

## MySQL数据库的安装和启动
**注意**：安装新的MySQL之前需要先卸载已经下载的旧的MySQL

MySQL8.0.26配置界面：

![MySQL配置界面](/blog/202205052254380.png "MySQL配置界面")

可见MySQL默认端口号是3306

### 启动MySQL服务
有两种方式：

1.win+s，services.msc 打开Windows服务，找到mysql，右键打开/关闭即可

2.命令行打开关闭MySQL

打开命令：net start mysql<br>
关闭命令：net stop mysql<br>
其中mysql是注册的MySQL服务名，可能会有不同，比如MySQL8.0.* ,默认的服务名是mysql80

**注意**：需要以管理员身份运行命令行

### 客户端连接
其实客户端就是命令行中输入的mysql，连接客户端需要登录，验证用户身份，默认用户身份是root，连接命令如下：

mysql -uroot -p，然后输入密码即可

**当然要想在任意目录下使用Windows命令行连接客户端的前提是你配置了环境变量**

如何是远程连接不同主机的的MySQL，命令应该是这样的：

mysql -h 127.0.0.1 -P 3306 -uroot -p，注意是大写的P，否则命令不成功

## MySQL数据模型
### 关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库

特点：

1.使用表存储数据，格式统一，便于维护

2.使用SQL编程语言操作，标准统一，便于使用

### 关系型数据库-数据模型
![数据模型](/blog/202205052333543.png "数据模型")

## SQL
### SQL语句通用语法
1.SQL语句可单行也可多行书写，以分号结尾。

2.SQL关键词应该大写，统一规范

### SQL分类
![SQL分类](/blog/202205062331875.png "SQL分类")


### DDL
#### 数据库操作
1.查询所有数据库
```sql
mysql> show databases;
```

2.创建数据库
```sql
mysql> create database [if not exists] test_db [default charset utf8mb4];
```

3.使用数据库
```sql
mysql> use test_db;
```

4.查询当前使用的数据库
```sql
mysql> select database();
```

5.删除数据库
```sql
mysql> drop database [if exists] test_db;
```

#### 表操作
1.创建表

```sql
mysql> create table [if not exists] t_user(
    id int [comment '编号'],
    name varchar(20) [comment '姓名'],
    age int comment ['年龄'],
    gender varchar(1) comment ['性别']
)comment '用户表';

int 类型默认11位；
```

2.查询所有的表

```sql
mysql> show tables;
```

3.查询表的结构

```sql
mysql> desc t_user;
```

4.查询表的创建语句

```sql
mysql> show create table t_user;
```

5.重命名表

```sql
MySQL> alter table t_user rename to user;
```

6.删除表

```sql
-- 第一种方法
mysql> drop table [if exists] employee; # 删除整张表，从内存清除

-- 第二种方法
mysql> truncate table employee; # 删除表，并重新创建
```

删除表的三种方法：

1.truncate会重置自增值，并恢复索引为初始大小；<br>
2.相比truncate，delete语句在执行时会生成日志，以便回滚；（这里的delete语句特指不带条件的，因为会删除所有记录）<br>
3.drop语句会直接清空表内存;

#### 字段操作
1.添加字段

```sql
mysql> alter table t_user add address varchar(100) comment '住址';
```

2.删除字段

```sql
mysql> alter table t_user drop address;
```

3.修改字段类型

```sql
mysql> alter table t_user modify address varchar(200) comment '住址';
```

4.修改字段名和字段类型

```sql
mysql> alter table t_user change address family_address varchar(234) comment '家庭住址';
```

#### DDL数据类型
##### 数值类型
![数值类型](/blog/202205221429823.png "数值类型")

##### 字符串类型
![字符串类型](/blog/202205072346561.png "字符串类型")

varchar需要指明长度，即varchar(length)，否则报错，而char不指定长度为1，即char(1)；<br>
varchar会根据存储的内容决定需要多大的存储空间，而char的长度一经指定不在改变，总是申请固定长度的空间

##### 日期类型
![日期类型](/blog/202205072348614.png "日期类型")

##### 示例
![示例](/blog/202205072349213.png "示例")

```sql
mysql> create table employee(
    id int comment '编号',
    empno varchar(10) comment '员工工号',
    name varchar(10) comment '员工姓名',
    gender char(1) comment '性别',
    age tinyint unsigned comment '年龄',
    identifyno char(18) comment '身份证号',
    employdate date comment '入职时间'
)comment '员工信息表';
```

**从我们的设计可见，对于长度固定的字符串，我们使用char，对于绝对非负的数据就用unsigned修饰**


#### DDL语句总结
![DDL语句总结](/blog/202205221439535.png "DDL语句总结")

- 相比DML,DDL语句通常需要加上table关键词，毕竟DDL操作的对象有数据库、表、和字段，而且增删改等使用的关键词可能相同，因而要指明操作的是什么对象，即是数据库还是表，或者是哪个表的哪个字段例如：

```SQL
-- DDL
drop database test1;
drop table t_user;
truncate table t_user; 
alter table t_user ADD constraint foreign key(user_id) references t_score(user_id);

-- DML
select * from t_user;
insert into t_user(id, username, password) values(1, "flameking", "123456");
update t_user set name="Casflawed",password="654321" where id=1;
```

### DML
DML全称Data Maniputation language（数据操作语言），用来对数据库表记录进行增删改操作，即insert，delete，update

#### insert添加数据
1.给指定字段添加数据

```sql
mysql> insert into user(`id`, `name`, `age`) values(1, 'flameking', 21);
```

2.给全部字段添加数据

```sql
mysql> insert into user values(1, 'flameking', 21, '男', '河南', '1');
```

3.批量添加数据

```sql
mysql> insert into user(`id`, `name`, `age`) values(1, 'flameking', 21),(2, 'Casflawed',22),(3,'oneway',23);
mysql> insert into user values(1, 'flameking', 21, '男', '河南', '1'),(5,'casflawed',28,'女','湖南','0');
```

**注意**：

- 字符串和日期型数据应该包含在引号中
- 插入数据顺序必须和指定的数据一一对应
- 插入的数据大小应该在字段范围内

#### update更新记录

```sql
形如：update 表名 set 字段名1=值1, 字段名2=值2,.....[where 条件]
mysql> update user set name="Casflawed" where id=1;

-- 如果没有条件则会修改整张表的数据
mysql> update update user set family_address="湖南";
```

#### delete删除记录

```sql
形如：delete from 表名 [where 条件]
mysql> delete from user where id = 1;

-- 如果不带条件则会删除整张表的记录
delete from user;
```

### DQL

#### 单表查询
##### 基本查询
操作的表结构和记录：<br>
![emp表](/blog/202205221601974.png "emp表")

1.查询指定字段

```sql
select name, workno, age from emp;
```

2.查询所有字段

```sql
select * from emp;
```

3.查询所有员工的工作地址，起别名

```sql
-- 别名的意义是为了更好的理解字段，因此这里使用中文别名方便用户更容易理解
select workaddress as 工作地址 from emp;
```

4.查询不重复的员工地址

```sql
-- 关键词 distinct
select distinct workaddress from emp;
```

##### 条件查询
可能的条件：

![可能的条件](/blog/202205221705187.png "可能的条件")
1.查询年龄等于88的员工

```sql
select * from emp where age = 88;
```

2.查询年龄小于20的员工信息

```sql
select * from emp where age < 20;
```

3.查询年龄小于等于20的员工信息

```sql
select * from emp where age <= 20;
```

4.查询没有身份证号的员工信息

```sql
select * from emp where idcard is null;
```

5.查询有身份证号的员工信息

```sql
select * from emp where idcard is not null;
```

6.查询年龄不等于88的员工信息

```sql
select * from emp where age != 88;
select * from emp where age <> 88;
```

7.查询年龄在15岁（包含）到20岁（包含）之间的员工信息

```sql
select * from emp where age between 15 and 20;
select * from emp where 15 <= age and age <= 20;
select * from emp where 15 <= age && age <= 20;

-- 如果between后跟大值会怎么样
select * from emp where age between 20 and 15; # 语句部分报错，但返回空的结果集（Empty set）
```

8.查询性别为女且年龄小于25岁的员工信息

```sql
select * from emp where gender = '女' && age < 25;
```

9.查询年龄等于18或20或40的员工信息

```sql
select * from emp where age = 18 or age = 20 or age = 40;
select * from emp where age in(18,20,40);
```

**in可以用来简写有多个or语句的条件**

10.查询姓名为两个字的员工信息

```sql
select * from emp where name like '__';
```

11.查询身份证信息最后一位是X的员工信息

```sql
select * from emp where idcard like '%X';
select * from emp where idcard like '_________________X'; #有17个下划线
```

##### 聚合函数
聚合函数简介：

![聚合函数简介](/blog/202205221714905.png "聚合函数简介")

1.统计该企业员工数量

```sql
select count(*) from emp;
-- 或者是任意字段
select count(id) from emp;
```

2.统计该企业员工的平均年龄

```sql
select avg(age) from emp;
```

3.统计该企业员工的最大年龄

```sql
select max(age) from emp;
```

4.统计该企业员工的最小年龄

```sql
select min(age) from emp;
```

5.统计西安地区员工的年龄之和

```sql
select sum(age) from emp where workaddress='西安'
```

##### 分组查询
```sql
形如：select * from 表名 [where 条件] group by 分组字段名 [having 分组后的过滤条件]
```

where条件和having条件的区别：<br>
1.执行时机不同，where条件在分组前执行，不符合的记录不参与分组，having条件对分组后的结果集执行
2.判断条件不同，where条件不能对聚合函数进行判断，having可以

练习：<br>
1.根据性别分组，统计男性员工和女性员工的数量

```sql
select gender, count(*) from emp group by gender;
```

2.根据性别分组，统计男性员工和女性员工的平均年龄

```sql
select gender, avg(age) from emp group by gender;
```

3.查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址

```sql
select workaddress,count(*) emp_count from emp where age < 45 group by workaddress having emp_count >= 3;
```

**注意：<br>
1.执行顺序where条件>聚合函数>having条件<br>
2.分组之后一般查询分组字段和聚合函数，查询其他字段没有意义**

##### 排序查询
```sql
-- 由此可见：SQL支持多字段排序，排序规则是，如果字段1相同就按字段2排序
形如：select 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;

-- 排序方式
1.ASC，升序（默认）
2.DESC，降序
```

练习：<br>
1.根据年龄对公司的员工进行升序排序

```sql
select * from emp order by age asc;
```

2.更具入职时间，对员工进行降序排序

```sql
select * from emp order by entrydate desc;
```

3.根据年龄对公司的员工进行升序排序，年龄相同再按入职时间进行降序排序

```sql
select * from emp order by age, entrydate desc;
```

##### 分页查询
![分页查询](/blog/202205221802067.png "分页查询")

练习：<br>
1.查询第1页员工数据，每页展示10条数据

```sql
-- 如果起始索引是0，可以省略
select * from emp limit 10;
```

2.查询第2页员工数据，每页展示10条记录

```sql
select * from emp limit 10, 10;
```

#### 单表查询案例练习
1.查询年龄为20,21,22,23岁的员工信息

```sql
select * from emp where age in(20,21,22,23);
```

2.查询性别为男，并且年龄在20-40岁(含)以内的姓名为三个字的员工

```sql
select * from emp where gender='男' and (age between 20 and 40) and name like '___';
```

3.统计员工表中，年龄小于60岁的，男性员工和女性员工的人数

```sql
select gender,count(*) from emp where age < 60 group by gender;
```
4.查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排列，如果年龄相同按入职时间降序排序

```sql
select name, age from emp where age <= 35 order by age, entrydate desc;
```

5.查询性别为男，且年龄在20-40岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序

```sql
select * from emp where gender='男' and (age between 20 and 40) order by age,entrydate desc limit 5;
```

补充知识：<br>
```sql
1.WHERE子句

- where作为筛选语句会根据表记录从头到尾进行比较
- where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
- 在MySQL中，false也可以用0表示，true也可以用1表示

2.连接查询

- 即将两个表的字段连接起来

3.存储过程：预编译的SQL集合

- 优点：因为是预编译过的，因此执行速度会更快
- 难以调试和扩展
```

#### DQL语句执行顺序
![DQL语句执行顺序](/blog/202205221846912.png "DQL语句执行顺序")

**注意：group by和having都可以使用select中的别名**


### DCL
用来管理数据库用户，控制数据库的访问权限（简单来说就是哪些数据库能被那些用户访问）

#### DCL-管理用户

##### 查询用户
```sql
use mysql;  # 用户信息表放在了系统数据库mysql中
select * from user;
```

![表结构](/blog/202205251851236.png "表结构")<br>
Host和User两个字段共同定义一个用户，表示当前用户能在哪台主机上访问数据库服务器，localhost代表用户只能访问本地数据库，不能远程访问


##### 创建用户
1.创建只能在本机访问数据库的用户<br>
```sql
create user 'flameking'@'localhost' identified by '123456';
```

2.创建能访问任意主机数据库的用户<br>
```sql
create user if not exists 'casflawed'@'%' identified by '123456';
-- 如果不加@'%'，默认是允许访问任意主机上的数据库服务器
create user if not exists 'casflawed' identified by '123456';
```

用通配符%代表任意主机，同时上面两种方式创建的用户没有分配任何权限；

##### 修改用户密码
```sql
alter user 'flameking'@'localhost' identified with mysql_native_password by '123';
```

其中mysql_native_password代表MySQL的密码加密方式

##### 删除用户
```sql
drop user 'flameking'@'localhost';
```

#### DCL-权限控制

前面我们创建用户的时候，发现刚被创建出来的用户可以登录但做不了任何事情，这是因为我们还没分配任何权限<br>
![常用权限](/blog/202205261321552.png "常用权限")

##### 查询用户的权限
```sql
show grants for 'casflawed'@'%';
```

##### 授予用户权限
```sql
形如：grant 权限列表 on 数据库名.表名 to 用户;
grant all on *.* to 'casflawed'@'%';    # 经过这段sql授权后，casflawed相当于root，即超级管理员
```

##### 撤销用户权限
```sql
形如：revoke 权限列表 on 数据库名.表名 from 用户;
revoke drop,update on *.* from 'casflawed'@'%';
```

**注意：多个权限之间用‘，’分隔**


## 触发器
触发器是特殊的存储过程（一段能产生特定影响的sql语句），它没有参数，相比于sql约束（像非空约束，唯一约束，check约束）<br/>
触发器能完成更复杂的约束。

### 创建触发器
```sql
create trigger 触发器名
after|before update|insert|delete on 联系表名 for each row
begin
    触发体
end
```

例如：

```sql
create trigger delete_trigger
after delete on department for each row
insert into merch_log(who, oper_date)
    values(user(), sysdate());
```

### 删除触发器

```sql
drop trigger 触发器名;
```

### 触发器性质
`for each row` 任何一条记录上的操作满足**触发事件**都会激活该触发器，毫无疑问触发器对联系表具有访问权，<br/>
同时MySQL定义了new表和old表，new表是update或insert之后的联系表，old表是delete或update之前的联系表，<br/>
触发器对这两个表也具有访问权限。

## 数据库索引
1.索引是为了加快查询效率的一种数据结构，例如主键会自动加上唯一索引以加快查询效率（比如我们通常以主键为条件select）
2.唯一索引

- 任何与null比较的返回值都是null，包括null与null比较，但是带唯一约束的字段可以为null，但不能存在两个null，因为唯一约束规定null和null相同

2.外键

- 为了保证数据的一致性和正确性，我们往往会使用外键。例如1，在级联更新下，学生表中stu_id是主键，成绩表中stu_id是外键，如果在主表中stu_id发生变化，那么为了保证**一致性**从表中也会更新；例如2，当我们向成绩表中插入数据时，为了保证**正确性**会检查stu_id在学生表中是否存在，如果不存在则会插入失败；
- 添加外键索引
    + 创建成绩表时添加：`foreign key(stu_id) references t_student(stu_id)`；
    + 创建表后才添加：`ALTER TABLE t_score add constraint "t_score_fk1" foreign key(stu_id) references t_student(stu_id)`；
- 外键的优点
    + 保证了数据库数据的一致性和完整性；
    + 级联操作方便，减轻了程序代码量；
- 外键的缺点
    + 外键影响数据库的插入速度；
    + 级联更新是强阻塞，存在数据库更新风暴的风险；
- 使用外键存在的问题
    + 外键的主从关系是定的，但是需求确实变化的，如果字段不在需要与其他表关联就会增加麻烦；
    + 由于外键约束的存在，每次做级联更新和删除时都需要仔细考虑后果；
    + 外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；
    + 对分库分表不友好 ：因为分库分表下外键是无法生效的；
- 外键的适用场景：外键与级联更新适用于单机低并发，不适合分布式、高并发集群；


## 数据库设计
1.三大范式

- 第一范式：字段不可再分
- 第二范式：在第一范式的基础上，所有非主属性完全依赖主键
- 第三范式：在第二范式的基础上，所有非主属性直接依赖主键

2.ER图：实体关系图，适用它可以清楚的表示实体之间的关系，例如：由角色，和权限两种实体，其中一个角色可以拥有多条权限，而一条权限可以被不同的角色拥有，因此角色和权限之间是多对多的关系，另外还有一对一，一对多等关系

- 正方形表示实体
- 菱形表示关系实体
- 圆形表示实体属性

3.字符集

- 不同字符集能表示的字符范围不同，存储字符使用的字节数也不同
- Unicode 字符集是如今使用最多的一种字符集，它有多种编码实现，其中包括utf-8、utf-16、utf-32。
- 在数据库中对于utf-8有两套实现，分别是utf-8、utfmb4。而utfmb4能表示的字符范围更广、可以表示emoji字符以及一些复杂的汉字。
- 如果往CHARSET=utf-8的数据库中存入emoji字符会报错，因此应该使用utfmb4字符集。

## 数据库事务
1.事务ACID特性：以MySQL的InnoDB存储引擎为例

- A：原子性（atom），即以事务为最小单位，事务内的所有操作要么都成功要么都失败；依靠回滚日志（undo log）实现
- I：隔离性（Isolation），并发事务不会互相影响；依靠锁机制和MVCC实现
- D：持久性（durable），事务执行成功后对数据产生的影响是持久的，及时数据库发生故障，影响依然存在；依靠重做日志（redo log）实现
- C：一致性（consistency），即事务执行前后，数据依然保持逻辑一致性，这个逻辑一致性一般符合现实逻辑，或由DBA指定的规则；上述三者实现后，一致性才能实现

2.事务并发产生的响应

- 幻读和不可重复读的区别：不可重复读在于对同一条表记录进行多次查询时发现某些列被改变，而幻读在于多次查询时发现记录增加或者减少了。

3.MySQL的默认事务隔离级别

- 命令行查看方式
```SQL
select @@tx_isolation;
```
- InnoDB默认隔离级别是repeatable-read，需要应用加锁读实现，这个加锁实现依靠的就是next-key Locks（兼具记录锁和间隙锁的特点，既锁行又锁范围）
- InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。

## 数据持久化
1.什么叫做持久化：把数据存入可掉电式存储设备中以供后续使用；而持久化的过程大多通过关系型数据库完成

2.数据库存取技术之JDBC：是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口；而JDBC和数据库驱动的关系其实就是接口和实现类的关系；

3.对于Java程序来说如果没有JDBC程序会怎么样：与不同的数据库管理系统进行连接的时候，每针对一个数据库管理系统我们就需要写一套实现；显然对开发做出了很高的要求，不利于开发效率，而有了JDBC的存在，我们就只需要写一套实现就OK了，其实有点类似于工厂方法，JDBC就像抽象工厂用于涉及一整套连接数据库的规范，而针对不同的数据库的工厂实现类（数据库驱动）就由数据库开发商开发

4.使用JDBC实现数据库连接的具体实现流程是怎样的？

5.JDBC URL：如jdbc:mysql://localhost:3306，注意jdbc称为协议名，mysql称为子协议名主要用于表示数据库驱动，后面的称为子名称主要用于定位数据库，整个URL主要提供给驱动器管理器DriverManager选择正确的数据库驱动；跟Http协议比起来它并不是传输数据的协议

6.注册数据库驱动这一步骤主要干了什么？在一个项目中有可能会使用多种数据库系统，而这一步就是将这些数据库对象的数据库驱动信息保存在一个数组里，但获取连接时会用URL去这个数组进行一一比对，以获取到正确的数据库驱动程序去连接对应的数据库

7.jpa和jdbc的区别：jpa是orm规范，orm旨在通过操作实体类就能直接操作数据表，尽量避免大量的SQL语句的编写；jdbc是Java程序访问数据库的统一规范；jpa的实现底层还是要借助jdbc的，毕竟还是要和数据库交互，只不过如果使用jpa我们就不用去管怎么去编写具体的SQL语句，不用关心怎么将关系字段与对象属性一一对应；