---
title: 事务隔离：为什么你改了我还看不见？
date: 2023-03-12 +/-TTTT
categories: [数据库,MySQL]
tags: []     # TAG names should always be lowercase
---

# 事务隔离级别
1.读未提交（read uncommitted）
    事务未提交，它做的变更就可被其他事务看见
2.读已提交（read committed）
    事务提交后，它做的变更才可见
3.可重复读（repeatable read）
    事务在执行过程中看到的数据，与事务开启时看到的数据是一致的
4.串行化（serializable）
    顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

# 事务隔离级别的实现机理
## 事务上的视图
事实上，当一个事务访问一条记录时，**数据库服务器会为这个这条记录生成一个视图**，而事务访问时都会以这个视图的逻辑结果为准；

1.读未提交没有视图的概念，它总是读取一条记录的最新值
2.读已提交，视图是在每个SQL执行的时候生成的，因此如果是同一条SQL，每次执行的视图可能会不一样（也就是如果当前记录被已提交事务修改）
3.可重复读，视图是在事务开启的时候生成的，因而事务的整个存在期间（未提交前）都是以这个视图为准的
4.串行化，直接用加锁的方式避免事务的并行访问

查看当前事务的隔离级别：

```sql
show variables like 'transaction_isolation';
```

## 事务上的回滚日志
我们知道事务的原子性通过回滚日志实现，而对于一条记录的回滚日志，如下图：

![一条记录的回滚日志](https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202204280831840.png "一条记录的回滚日志")

其中read-view是视图，我们发现当查询这条记录的时候，不同时刻启动的事务会用不同的视图，使得同一条记录在不同的事务居然会有呈现不同的值，这就是数据库的多版本并发控制(MVCC)，知道系统中事务使用的视图都比回滚日志中靠后，那么该回滚日志就会被删除了；

回滚日志应该不会只存一条记录，所以如果是长事务，他就可能占用一个很古老的视图，这样会导致回滚日志越来越长，事务提交前这些回滚日志都会保留下来，这样就会消耗大量的存储空间，因此我们应该将事务的提交控制在自己的手里；

手动操作事务：

```sql
set autocommit=0 #关闭事务的自动提交
begin 或者 start transaction #开启事务
commit #提交事务
rollback #回滚事务
commit work and chain #提交事务并自动开启下一个事务
#查找持续时间超过60s的事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
```