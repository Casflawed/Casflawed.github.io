---
title: Java字节码技术
date: 2022-03-16 +/-TTTT
categories: [JVM]
tags: []     # TAG names should always be lowercase
---
# 为什么要学习字节码技术
1. 从技术人员的角度看，Java 字节码是 JVM 的指令集，JVM 加载字节码格式的 class 文件，校验之后通过 JIT 编译器转换为本地机器代码执行，也就是说Java字节码就是我们给JVM的指令，为了让JVM能够按照我们的计划执行，我们就应该熟悉Java字节码技术
2. 了解字节码及其工作原理，对于编写高性能代码至关重要，对于深入分析和排查问题也有一定作用，所以我们要想深入了解 JVM 来说，了解字节码也是夯实基础的一项基本功
3. 对于工具领域和程序分析来说, 字节码就是必不可少的基础知识了，通过修改字节码来调整程序的行为是司空见惯的事情，而且想了解分析器(Profiler)，Mock 框架，AOP 等工具和技术这一类工具，则必须完全了解 Java 字节码

# Java字节码简介
Java字节码（Java bytecode），就如名称所示, Java bytecode 由单字节(byte)的指令组成，理论上最多支持256（2^8）个操作码（操作指令），实际只使用了200左右，还有一些操作码保留给了调试操作

**操作码（指令）结构**

操作码， 下面称为 指令, 主要由类型前缀和操作名称两部分组成，如：iadd，i代表类型前缀，即integer，add代表操作名称，即加法操作，所以合起来就是**对integer类型的数据执行加法操作**

**指令的分类**

根据指令的性质，分为4大类：
1. 栈操作指令，包括与局部变量交互的指令
2. 程序流程控制指令
3. 对象操作指令，包括方法调用指令
4. 算术运算以及类型转换指令

此外还有一些执行专门任务的指令，比如同步(synchronization)指令，以及抛出异常相关的指令等等

# 获取字节码清单
即通过javap工具反编译获取class文件的指令清单

对于下面的类：

```java
package demo.jvm0104;

public class HelloByteCode {
    public static void main(String[] args) {
        HelloByteCode obj = new HelloByteCode();
    }
}
```

1. 我们首先通过javac命令编译获得class文件：`javac demo/jvm0104/HelloByteCode.java`，另外可以通过-d参数指定.class文件放置的目录，默认与.java文件同目录，**除此之外，javac命令默认开始了优化功能，会将字节码中的局部变量表擦除，如果想在反编译的指令集中看到局部变量表，请在编译时追加`-g`指令**
2. 执行命令：`javap -c demo/jvm0104/HelloByteCode.class`，反编译成功后结果如下：

```java
Compiled from "HelloByteCode.java"
public class demo.jvm0104.HelloByteCode {
  public demo.jvm0104.HelloByteCode();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class demo/jvm0104/HelloByteCode
       3: dup
       4: invokespecial #3                  // Method "<init>":()V
       7: astore_1
       8: return
}
```

# 解读字节码清单


# 查看class文件的常量池信息

# 查看方法信息

# 线程栈和字节码执行模型
线程栈，用来存储栈帧，每一次方法调用JVM就会创建一个栈帧

栈帧包括：

1. 局部变量表：存放方法参数和局部变量
2. 操作数栈：存放计算值和方法返回值
3. class引用

# 方法体中的字节码解读
1. 字节索引
2. 指令占用字节，和操作数占用字节

# 对象初始化指令：new 指令, init 以及 clinit 简介
1. clinit：类静态初始化方法，它不能直接调用，是由指令触发的，像访问静态字段，调用静态方法就会触发对应类的静态初始化方法（如果尚未初始化）