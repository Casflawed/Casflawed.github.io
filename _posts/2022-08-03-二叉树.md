---
title: 二叉树
date: 2022-08-03 +/-TTTT
categories: [算法与数据结构]
tags: []     # TAG names should always be lowercase
---

# 二叉树节点结构
![二叉树节点结构](/blog/202208032258195.png "Optional title")

# 递归序
## 什么是递归序
1. 递归序是二叉树递归遍历的一种套路
2. 按照递归序，每个节点会经过3次，第一次是初次进入节点，第二次是左树返回节点，第三次是右树返回节点

例如，存在下面的树：

![树结构](/blog/202208041007628.png "Optional title")

那么按照头节点、左树、有树的遍历顺序，一定有这样的递归序：<br>
1 2 3 3 3 2 4 4 4 2 1 5 6 6 6 5 7 7 7 5 1，根据递归序，我们可以轻松得到前序遍历、中序遍历、后续遍历的序列：

1. 前序遍历，第一次经过节点的序列：1 2 3 4 5 6 7
2. 中序遍历，第二次经过节点的序列：3 2 4 1 6 5 7
3. 后序遍历，第三次经过节点的序列：3 4 2 6 7 5 1

递归序是一种思想，它便于我们更加容易的写出二叉树递归的code，像下面这样：

```java
public class Solution {
  public static class Node{
    private int value;
    private Node left;
    private Node right;

  }
  public void f(Node head){
    if (head == null){
      return;
    }
    // 这里是第一次进入head节点
    f(head.left);
    // 这里是从左树返回后，第二次进入head节点
    f(head.right);
    // 这里是从右树返回后，第三次进入head节点
  }
}
```

如果是前序遍历，就在第一次进入节点的时候打印value，中序遍历、后序遍历同理


# 非递归遍历二叉树
任何递归都可被改成非递归，二叉树递归也不例外，只要我们不使用系统压栈，而是自己手动压栈就行了

## 先序遍历
准备好一个栈：

1. 先入头节点
2. 弹出并输出节点value，如果节点有左右孩子节点，先压入右节点，再压入左节点
3. 重复1、2操作，直到栈为空

![非递归先序](/blog/202208032300942.png "Optional title")

## 中序遍历
准备一个栈：

1. 先压入头节点，再依次压入左边界（每棵树的左节点）
2. 弹出节点并打印value，如果有右节点，压入右节点，再依次压入右节点所在子树的左边界
3. 重复1、2操作，直到栈为空

![非递归中序](/blog/202208032300497.png "Optional title")

## 后序遍历
准备两个栈，s1压入栈，s2收集栈：

1. 先压入头节点
2. 弹出节点，不打印保存到收集栈，如果有左右孩子，先左孩子后右孩子压入栈
3. 重复1、2操作，直到压入栈为空，然后弹出收集栈，直至收集栈为空，弹出的序列就是后续遍历

![非递归](/blog/202208032302454.png "Optional title")

# 如何直观的打印一棵树
这类题目通常是设计题

# 宽度优先遍历（层序遍历）
准备一个队列（在Java中，LinkedList虽然底层结构是双向链表但也可以作为队列使用）：

1. 先压入头节点
2. 队列弹出节点并打印，如果存在左右孩子节点，先左后右压入队列
3. 重复1、2操作，直至队列为空

![层序遍历](/blog/202208032302964.png "Optional title")

## 宽度优先遍历例题
1. 求二叉树的最大宽度（leetcode104真题）

