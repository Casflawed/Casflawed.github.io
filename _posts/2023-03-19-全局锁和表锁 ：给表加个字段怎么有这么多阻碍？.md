---
title: 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
date: 2023-03-19 +/-TTTT
categories: [MySQL]
tags: []     # TAG names should always be lowercase
---

# MySQL 为什么需要锁
数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。

# 全局锁
即对整个数据库实例加锁。MySQL 中提供了一个加全局读锁的命令：

Flush tables with read lock (在这里就简称 FTWRL)

因为全局锁的常见应用场景就是对整个库做备份，所以一般可以执行这条命令。使用这个命令之后其他线程的以下语句会被阻塞：

1. 数据更新语句（数据的增删改）
2. 数据定义语句（包括建表、修改表结构等）
3. 更新类事务的提交语句。

简单来说，在备份期间，所有的业务都得停摆。

## 那么备份为什么要加锁呢

举个简单的例子，小红在某 APP 上充值了会员，所以账户余额就减少了。但如果备份的次序是这样的：备份会员数据 --> 用户充值会员 ---> 备份账户余额数据。显然在备份结果里小红明明充值了但却不是会员。

即不加锁的话，系统备份的库不是一个逻辑时间点，这个视图是逻辑不一致的。

## MySQL 的逻辑备份工具 mysqldump

实际上 MySQL 自带备份工具 mysqldump，当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

## 既然有 mysqldump，为什么还需要 FTWRL 呢？

因为除了 InnoDB，还有很多存储引擎压根不支持事务，比如 MyISAM，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。

## 既然要全库只读，为什么不使用 set global readonly=true 的方式呢？

确实 readonly 方式也可以让全库进入只读状态，但还是建议用 FTWRL 方式，主要有两个原因：

1. 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。
2. 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据（DML），还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。

但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。

# 表级锁
## 表锁

**限制其他线程的同时限制自身**

语法：`lock tables ... read/write`，与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。**注意**lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程 A 中执行 `lock tables t1 read, t2 write;` 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。当然线程 A 对其他表的操作不受影响，因为 MySQL 的表级锁是针对指定的表而非整个数据库的。

**一般不用表锁，除非存储引擎不支持行锁**

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，直到出现 InnoDB 这种支持行锁的引擎。毕竟表锁对业务的影响也不次于全局锁。

## 元数据锁（metadata lock，MDL）
MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。比如：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此在 MySQL 5.5 版本中引入了 MDL

**MDL 的使用**

当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

1. 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
2. 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

**MDL 是 MySQL 的一个自动机制，但请不要忽视它**

**事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。**假设你正在修改一个小表，如下图所示：

![](https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202303192146024.png)

可以看到 session A 先启动时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。

如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。

**如何安全地给小表加字段？**

解决长事务，事务不提交就会一直占着 MDL 锁，在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。

**如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，怎么办呢？**

这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。
