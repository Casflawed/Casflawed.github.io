---
title: MySQL45讲
date: 2022-04-22 +/-TTTT
categories: [中间件,MySQL]
tags: [极客时间]     # TAG names should always be lowercase
---

## 01 基础架构：一条SQL查询语句是如何执行的？
### 架构流程图

![架构流程图](/blog/202204261432962.png "架构流程图")
### 连接器
#### 长连接可能出现的问题
当连接器使用长连接管理MySQL客户端和服务端的连接时，容易因为内存过大，导致MySQL服务重启；原因是因为：MySQL执行过程中内存是被管理在了连接对象中，连接断开，内存才会释放，所以当我们全部使用长连接时，内存就会涨的特别快，甚至导致服务被系统强制杀死，从现象看就是MySQL服务异常重启。

如何解决：

1.定期断开连接
2.在MySQL5.7和更新版本，使用mysql_reset_connection命令重新初始化连接资源，该过程不需要重连或重新进行权限验证，但是会将连接重置为刚刚创建完成的状态

### 查询缓存
#### 为什么不建议使用查询缓存
弊大于利：

1.一旦执行更新操作，缓存会全部清除，意思是辛辛苦苦维护缓存，结果还没来得及用就被删除了，白白浪费了资源；所以如果要使用缓存，尽量是更新操作比较少的数据库
2.MySQL8.0之后完全割掉了查询缓存的功能

#### 按需使用查询缓存
件参数query_cache_type参数设置成demand，这样默认对于SQL语句不使用查询缓存，如果要针对特定语句使用查询缓存，操作如下：

```sql
mysql> select SQL_CACHE * from T where id=10;
```

## 02 日志系统：一条SQL更新语句是如何执行的？
### 预知
1.MySQL的数据以数据页为单位，按偏移量寻找记录的具体位置，所以每次IO操作都是一个个数据页加载到内存，但是我们需要查询或修改的数据也许就是一条记录，甚至对于更新操作，又会将数据页整个的刷新到磁盘，所以IO成本非常高，因而为了降低IO操作的成本，MySQL做了大量的努力

### 更新操作牵涉两个重要的日志：redo log和binlog
#### redo log怎么起作用的
redo log可以简单分为两个部分

- 内存层面的redo log buffer
- 持久化层面的redo log file

redo log实现的具体逻辑：

![redo log如何起作用](/blog/202204271023885.png "redo log如何起作用")

#### write pos 和 check point
write pos是redo log追加日志的索引，check point与write pos是剩余和写入日志的空间，当write pos = redo log时，write pos会向前推进，这样就形成了一个循环队列的数据结构，具体的形象图如下：

![write pos 和 check point](/blog/202204271028957.png "write pos 和 check point")

#### binlog和redo log的区别
1.redo log是InnoDB独有的，而binlog是server层的，所有的引擎都可以使用
2.在更新事务期间，redo log会循环不断记录，而binlog会在事务提交时一次性写入
3.binlog记录的是原始逻辑，也就是把SQL语句直接存入，redo log则是物理日志
4.redo log空间固定，binlog可追加写，写完一个，会继续写另一个，这就说明binlog可以用来恢复临时库，因为里面记录任意时刻的原始操作

#### binlog的工作逻辑
通过备份库里会备份近半个月的binlog，用于恢复临时库，当然如果想要数据库恢复更久之前的状态，也可以备份更长的甚至是一年的binlog
