---
title: 行锁功过：怎么减少行锁对性能的影响？
date: 2023-03-19 +/-TTTT
categories: [MySQL]
tags: []     # TAG names should always be lowercase
---

# 什么是两阶段锁
两阶段锁协议（Two-Phase Locking Protocol）是一种并发控制机制，旨在保证事务的隔离性和原子性。这样可以避免死锁的发生，提高数据库的性能和并发度。

该协议分为两个阶段：

1. 增长阶段（Growing Phase）：事务在执行过程中，需要获取需要的所有锁。在这个阶段中，事务可以获取锁，但是不能释放锁。
2. 缩减阶段（Shrinking Phase）：当事务执行完毕后，需要释放所有锁。在这个阶段中，事务可以释放锁，但是不能获取锁。

即**行锁在事务结束时才释放**。比如对于下面的事务 A 和事务 B：

![](https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202303192252222.png)

只有在事务 A 执行 commit 之后，事务 B 才能继续执行。

## 怎么利用好两阶段锁

假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：

1. 从顾客 A 账户余额中扣除电影票价；
2. 给影院 B 的账户余额增加这张电影票价；
3. 记录一条交易日志。

也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，那么该如何安排这三个语句在事务中的顺序呢？

假设另外一个顾客 C 也在影院 B 买票，那么事务冲突的部分就是语句 2。因为它们要更新同一个影院账户的余额，需要修改同一行数据。

这样如果我们把容易冲突的语句 2 放在最后，这就能最大程度地减少了事务之间的锁等待，提升了并发度。

但是有一天影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？

这里，就要说到死锁和死锁检测了。

# 死锁和死锁检测
当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。比如：

![](https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202303192258079.png)

这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。

## 如何处理死锁状态
1. 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

一般我们会选择策略 2，因为在第一种策略下，如果设置的时间过长，那么意味着其他事务也要等待较长的时间，对于一个在线服务来说这是难以接受的。而如果设置时常过短

在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。