---
title: 设计模式
date: 2022-03-18 +/-TTTT
categories: [设计模式, Java实现]
tags: []     # TAG names should always be lowercase
---

# 单例模式
1.设计单例的一般步骤：

- 私有化生产单例的手段，不允许外部访问
- 为内部生产的单例准备静态变量
- 向外暴露获取单例的唯一手段

2.单例的不同实现

- 饿汉模式（常用）

```java
/**
 * 单例模式-饿汉
 */
public class Sun {

  private static final Sun sun = new Sun();

  private Sun(){}

  public static Sun getInstance(){
    return sun;
  }
}
```

- 懒汉模式（复杂，性能不高）

```java
/**
 * 单例模式-懒汉
 */
public class Sun {

  private volatile static Sun sun;

  private Sun(){}

  public static Sun getInstance(){
    // 最外层判空逻辑提高加锁后的性能，加了它在sun被赋值后，之后的就不会执行里面的同步加锁操作，也就不会排队了
    if (sun == null){
      synchronized (Sun.class){
        if (sun == null){
          sun = new Sun();
        }
      }
    }
    return sun;
  }
}
```
# 工厂方法模式
1.为什么要使用工厂方法

- 为了解耦，具体来说：<br>
①传统上我们一般用new创建对象和对象初始化，但这样会将对象的产生代码硬编码在客户端代码中，造成客户端代码和实例化过程强耦合了，这样我们如果要生产不同的对象就必须改客户端代码<br>
②但最终客户端只是需要对象而已，生产对象客户端理应不需要管，应该把这份工作专门交给工厂来做，我们只管使用，工厂只管对象的生产和初始化<br>
③这样就实现了客户端代码与对象生产代码的强耦合，实际上我们把不同的工作分成了不同的模块，而模块与模块之间尽量保持独立<br>

2.如何设计工厂方法

- 工厂抽象解耦限制生产方法（定义工厂生产的规范）
- 针对不同的对象实现不同的工厂类（进行明确分工，例如：皮鞋厂就专门做鞋子，汽车厂就专门生产汽车；不要让一个工厂类封装不同的工厂方法，专业的事就该让专业的人去做）

# 原型模式
1.为什么要使用原型模式

- 原型模式是基于拷贝提出的
- 创建对象时对有复杂的初始化操作的对象，我们应该使用拷贝
- 而如果我们需要大量的这种对象，如果用new创建就会触发类加载，对象实例化，初始化等操作，效率远低于拷贝

2.使用原型模式，①对象应该实现Cloneable接口，②首先得有原型对象，才能实现拷贝