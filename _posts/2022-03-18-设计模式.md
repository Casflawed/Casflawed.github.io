---
title: 设计模式
date: 2022-03-18 +/-TTTT
categories: [设计模式, Java实现]
tags: []     # TAG names should always be lowercase
---

## 单例模式
1.设计单例的一般步骤：

- 私有化生产单例的手段，不允许外部访问
- 为内部生产的单例准备静态变量
- 向外暴露获取单例的唯一手段

2.单例的不同实现

- 饿汉模式（常用）

```java
/**
 * 单例模式-饿汉
 */
public class Sun {

  private static final Sun sun = new Sun();

  private Sun(){}

  public static Sun getInstance(){
    return sun;
  }
}
```

- 懒汉模式（复杂，性能不高）

```java
/**
 * 单例模式-懒汉
 */
public class Sun {

  private volatile static Sun sun;

  private Sun(){}

  public static Sun getInstance(){
    // 最外层判空逻辑提高加锁后的性能，加了它在sun被赋值后，之后的就不会执行里面的同步加锁操作，也就不会排队了
    if (sun == null){
      synchronized (Sun.class){
        if (sun == null){
          sun = new Sun();
        }
      }
    }
    return sun;
  }
}
```
## 工厂方法模式
1.为什么要使用工厂方法

- 为了解耦，具体来说：<br>
①传统上我们一般用new创建对象和对象初始化，但这样会将对象的产生代码硬编码在客户端代码中，造成客户端代码和实例化过程强耦合了，这样我们如果要生产不同的对象就必须改客户端代码<br>
②但最终客户端只是需要对象而已，生产对象客户端理应不需要管，应该把这份工作专门交给工厂来做，我们只管使用，工厂只管对象的生产和初始化<br>
③这样就实现了客户端代码与对象生产代码的强耦合，实际上我们把不同的工作分成了不同的模块，而模块与模块之间尽量保持独立<br>

2.如何设计工厂方法

- 工厂抽象解耦限制生产方法（定义工厂生产的规范）
- 针对不同的对象实现不同的工厂类（进行明确分工，例如：皮鞋厂就专门做鞋子，汽车厂就专门生产汽车；不要让一个工厂类封装不同的工厂方法，专业的事就该让专业的人去做）

## 原型模式
1.为什么要使用原型模式

- 原型模式是基于拷贝提出的
- 创建对象时对有复杂的初始化操作的对象，我们应该使用拷贝
- 而如果我们需要大量的这种对象，如果用new创建就会触发类加载，对象实例化，初始化等操作，效率远低于拷贝

2.使用原型模式，①对象应该实现Cloneable接口，②首先得有原型对象，才能实现拷贝

## 抽象工厂
抽象工厂结构图：<br>
![抽象工厂结构图](/blog/202203231916787.png "抽象工厂结构图")

## 建造者模式
1.建造者模式面对的对象（或者说构建的产品是怎么样的？）：通常这种对象的初始化过程很复杂，往往要经过好几步才能完成初始化，用一个例子形象的说明就是：但玩家在选择游戏角色时：需要位角色配置各项属性，而拥有了某项属性或者属性达到了某个值才能装备上某个装备，带上装备后才能学习某个技能，最后才完成一个角色的选择；显然这种对象的创建我们没有办法在一开始一次性的把所有初始化参数都给赋值了，要先赋值一部分，才能接着赋值下一部分

2.所以说建造者模式面对的对象的生产过程必然要遵循某种步骤，每种步骤之间还要由特定的顺序，不能本应该首先执行的步骤，结果拖到最后才执行

3.一般流程

![建造者模式一般设计流程](/blog/202204072139839.png "建造者模式一般设计流程")


## 代理模式
代理模式不仅能增强原业务功能，更重要的是还能对其进行业务管控。对用户来讲，隐藏于代理中的实际业务被透明化了，而暴露出来的是代理业务，以此避免客户端直接进行业务访问所带来的安全隐患，从而保证系统业务的可控性、安全性。