---
title: 编译原理
date: 2022-04-21 +/-TTTT
categories: [Spring,造轮子]
tags: [设计模式]     # TAG names should always be lowercase
---

## 编译与计算机程序设计语言的关系

编译：将高级语言翻译成机器语言或汇编语言的过程

编译器和解释器的区别：

1.编译器整个将源程序翻译成目标程序，而解释器以源程序作为输入，每输入一条语句就执行一条语句，不生产目标程序

2.相比解释器编译器经过一次编译就不需要再编译，直接以目标程序运行即可

## 编译器在语言处理系统中的位置

![编译器的位置](/blog/202204210911985.jpg "编译器的位置")

## 翻译过程

一条句子的翻译过程：

1.词法分析

划分词性，如名词、动词、形容词

2.语法分析

划分短语，依靠词法分析，如名词短语、动词短语、介词短语

3.语义分析

最后根据语法分析，总结各短语的关系，得到一条句子的语义（中间表示形式），如某人干了某事，即名词短语和动词短语的练习

## 语法制导翻译

即编译器过程的逻辑实现，在实际中可能是多个步骤在一起实现，比如语法分析、语义分析、中间代码生成就被放在一起实现，而这个技术也称为语法制导翻译

![语法制导翻译](/blog/202204210933035.png "语法制导翻译")

## 词法分析

1.这个过程概括来讲就是：高级语言的单词 --> 对应的机内表示（也被称为token），为了区别这些机内表示，token的结构如下：

token：(种别码，属性值)，这很容易理解，种别码表示哪类词性，比如名词或是动词，而属性值就是这具体指哪个名词或是动词，而高级语言具体存在那些token，如下图：

![词法分析](/blog/202204210938292.png "词法分析")

## 语法分析

文法：短语组合规则，即语法规则，毕竟短语是由各种单词构造的，所以文法指的就是各种token构造成语法的规则，或者说称它为生成语法的函数

语法分析：从词法分析器输出的token序列识别短语并构造语法分析树的过程，语法分析树描述了句子的语法结构

## 语义分析

高级语言大概分为声明语句和可执行语句，声明语句声明属性和对象，而属性和对象作为可执行语句的操作单元，重新赋值给新的属性或对象，而这些对象就属于token中的标识符，可见表示符是声明语句和可执行语句的重要组成部分

所以语义分析的第一任务是提取这些属性，并且记录它们的种属（比如简单变量、数组、函数或者叫过程）、类型、值、作用域、位置、长度

语义分析的第二任务是语义检查

## 中间表示形式

1.表现方式：三地址码和语法结构树

三地址码：由三地址指令序列组成，每条指令最多有三个操作数，所以被称为三地址码，三地址指令形如：

![三地址码](/blog/202204211059721.png "三地址码")

三地址指令的数据结构表示分为：四元式（类似汇编语句，前缀表达式）、三元式，间接三元式

四元式形如：

![四元式](/blog/202204211108360.png "四元式")

如此可见，中间表示形式已经非常像汇编代码，而目标代码生成器最终的任务就是为变量或对象选择合适的寄存器

2.代码优化，分为机器无关代码优化器和机器相关代码优化器，在语言处理系统中所处的位置如下：

![代码优化](/blog/202204211114296.png "代码优化")

## 词法语法分析基本概念

字母表：有穷字符集合，这个字符包括大小写字母，数字，标点符号等

字母表的基本运算：乘积、n次幂、正闭包、克林闭包

正闭包：长度为正数的串的集合，是无穷的，不断的进行递归的幂运算得到的集合

克林闭包与正闭包：克林闭包 equal （正闭包 并 空字母表）

串：克林闭包的每个元素，都被称为一个串

串的长度

串运算：连接，幂运算

## 文法定义

首先看下图：该图表示的是自然语言中句子的文法

![自然语言句子文法](/blog/202204211355527.png "自然语言句子文法")

我们可以看到文法是由一条条产生式构成，如果我们把产生式作为函数，那么产生式左端就是函数参数，右端就是函数输出

如果把函数也作为属性，那么它表示就是产生规则，我们丢入原料就会输出产物，而把函数作为参数传给函数，就会形成更大的规则，甚至的递归的

因而上图表示的是句子的产生规则

其中未用尖括号的部分称为语言的基本符号（函数的最终输出），有括号的称为语法成分（函数）

### 终结符和非终结符

非终结符：表示语法成分的变量

![非终结符](/blog/202204211359369.png "非终结符")

终结符：语言的基本符号，也叫token

以上两者统称文法符号

两者关系：

![两者的交并运算](/blog/202204211403123.png "两者的交并运算")

### 产生式

产生式左右端均是串，串是由终结符和非终结符组合而成

![产生式](/blog/202204211406921.png "产生式")

### 开始符号

文法最终的输出

![开始符号](/blog/202204211417690.png "开始符号")

### 符号约定

终结符：

![终结符](/blog/202204211431973.png "终结符")

非终结符：

![非终结符](/blog/202204211431217.png "非终结符")

文法符号（以上两者均可以表示）、终结符号串、文法符号串：

![文法符号](/blog/202204211434485.png "文法符号")

## 语言的定义

推导和规约

推导，按照产生式向右推导，最终得到只有终结符的式子，规约相反，向左推导，直至产生式左端是开始符号

通过这两个方法可以判断一个词串是否是该语言的句子

### 句型和句子

![句型和句子](/blog/202204211443205.png "句型和句子")

### 语言

![语言](/blog/202204211444557.png "语言")

文法解决了无穷语言的有穷表示，函数的递归表示不也可以实现这样的效果吗，这也是我为什么把文法比作函数的原因，也可以对应到MIT-Scheme流和表的定义，两者都有递归性质