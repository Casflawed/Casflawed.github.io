---
title: 多线程基础（一）
date: 2022-08-03 +/-TTTT
categories: [多线程]
tags: []     # TAG names should always be lowercase
---

# 进程是什么，线程是什么
进程是运行在内存中的程序，线程是进程中程序执行的基本单元

# 为什么有了进程，还要引入线程呢？
线程的上下文切换成本过高，为了降低并发导致的进程切换成本，提出了线程，线程几乎不占资源，因此线程切换的成本较少，后来就换用线程抢占cpu执行权

# 线程的创建方式
## 继承Thread类

```java
public class ThreadDemo1 extends Thread {
    public static void main(String[] args) {
        // ThreadDemo1继承了Thread类，并重写run()
        ThreadDemo1 t = new ThreadDemo1();
        // 开启线程：t线程得到CPU执行权后会执行run()中的代码
        t.start();
    }

    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}
```

该种方法继承Thread类，并重写run()方法

## 实现Runnable接口

```java
public class ThreadDemo2 implements Runnable{
    public static void main(String[] args) {
        // ThreadDemo2实现Runnable接口，并实现run()
        ThreadDemo2 target = new ThreadDemo2();
        // 调用Thread构造方法，传入TreadDemo2的实例对象，创建线程对象
        Thread t = new Thread(target);
        // 开启线程：t线程得到CPU执行权后会执行run()中的代码
        t.start();
    }

    public void run() {
        System.out.println("Thread is running");
    }
}
```

这种方法需要实现Runnable接口（Runnable接口只有一个run()方法）将实现类对象传递给Thread构造函数，有Thread对象调用Runnable实现类中的run方法

相较于直接继承Thread类覆盖run方法，我们常使用第二种方法

# 为什么实现Runnable接口是创建线程的常用方法
1. 限制Thread构造函数的参数类型，如果使用这种方法就必须向Thread构造函数传递Runnable实现类对象
2. 解耦，将被执行的run方法视作资源，Thread对象视作执行者，第二种方法就是为了将执行者和资源进行解耦，第一种方法资源依然在Thread类中，而第二种方法资源是在Runnable的实现类中，这样就方便其他线程共享该资源

# 总结
无论是继承Thread类还是实现Runnable接口，线程的入口都是Thread类（因为Thread类的run方法在线程启动时一定会执行），下面的Thread类run方法的源码：

![Thread类的run方法实现](/blog/202208041438522.png "Optional title")