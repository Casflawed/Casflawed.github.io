---
title: 单例模式
date: 2022-03-18 +/-TTTT
categories: [设计模式]
tags: []     # TAG names should always be lowercase
---

# 什么是单例模式

保证整个系统中一个类只有一个实例对象，实现这种功能的方式就叫做单例模式

# 为什么要使用单例模式

## 节省公共资源
经常用到的对象：工具类对象、频繁访问数据库或文件的对象（DruidDataSource、session 工厂）

## 解决在多线程下资源访问冲突的情况
以日志管理为例：

```java
public class Logger {
  private FileWriter writer;
  
  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public void log(String message) {
    writer.write(message);
  }
}

```

## 有些数据在内存中只需保存一份，如配置信息类
## 创建对象时耗时过多或耗费资源过多(重量级对象)，频繁进行创建和销毁非常耗费性能



## 如何实现一个单例

要实现一个合理的单例模式，需要考虑下面几点：

1. 构造函数需要是 private 访问权限的，这样才能避免外部通过new创建实例；
2. 考虑是否支持延迟加载；（懒汉 or 饿汉）
3. 考虑对象创建时的线程安全问题（单例是一种共享资源）
4. 考虑 getInstance() 性能是否高（是否加锁，双重检测）。

1.设计单例的一般步骤：

- 私有构造函数
- 内部用静态变量保存单例对象
- 给外界提供获取单例的途径


### 饿汉模式

```java
/**
 * 饿汉模式1
 * 1.确保构造函数私有化
 * 2.内部用公共静态变量保存实例对象
 * 3.声明时实例化单例对象
 */
public class SingletonDemo1 {
  public final static SingletonDemo1 INSTANCE = new SingletonDemo1();
  private SingletonDemo1(){

  }
}

/**
 * 饿汉模式2
 * 1.确保构造函数私有化
 * 2.内部用公共静态变量保存实例对象
 * 3.在静态代码块中实例单例对象
 */
public class SingletonDemo2 {
  public final static SingletonDemo2 INSTANCE;

  static {
    try {
      INSTANCE = new SingletonDemo2();
      Properties properties = new Properties();
      InputStream inputStream = SingletonDemo2.class.getClassLoader().getResourceAsStream("properties.properties");
      properties.load(inputStream);
      INSTANCE.msg = properties.getProperty("msg");

    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private SingletonDemo2(){

  }

  private String msg;

  public void setMsg(String msg) {
    this.msg = msg;
  }

  public String getMsg() {
    return msg;
  }

  @Override
  public String toString() {
    return "SingletonDemo2{" +
            "msg='" + msg + '\'' +
            '}';
  }
}

/**
 * 饿汉模式3
 * 最简单的方式，主要巧妙的利用了 ENUM 的特性
 * 枚举也是类，它的构造函数也是私有的，每个实例其实是一个该类型的final static 常量，底层其实和SingletonDemo1声明时创建差不多
 */
public enum SingletonDemo3 {
  INSTANCE;
}

```

### 懒汉模式

```java
/**
 * 懒汉模式1
 * 延迟单例的创建，当使用单例时才创建
 *
 * 线程不安全的
 */
public class SingletonDemo4 {
  private static SingletonDemo4 INSTANCE;
  private SingletonDemo4(){}

  public static SingletonDemo4 getINSTANCE() {
    if (INSTANCE == null) {
      INSTANCE = new SingletonDemo4();
    }
    return INSTANCE;
  }
}

/**
 * 懒汉模式2
 * 线程安全的（并发量低）
 */
public class SingletonDemo5 {
  private static SingletonDemo5 INSTANCE;
  private SingletonDemo5(){}

  public static SingletonDemo5 getINSTANCE() {
    if (INSTANCE == null){
      synchronized (SingletonDemo5.class){
        if (INSTANCE == null) {
          INSTANCE = new SingletonDemo5();
        }
      }
    }
    return INSTANCE;
  }
}


/**
 * 懒汉模式3
 * 虽然是内部类但也是独立的，只有在使用到时才会加载
 */
public class SingletonDemo6 {

  private SingletonDemo6(){}

  private static class Inner{
    private static SingletonDemo6 INSTANCE = new SingletonDemo6();
  }
  public static SingletonDemo6 getINSTANCE() {
    return Inner.INSTANCE;
  }
}
```

```java
/**
 * 懒汉模式4
 * 双重检测
 */
public class SingletonDemo6 {
  private static SingletonDemo6 INSTANCE;
  private SingletonDemo6(){}

  public static SingletonDemo6 getINSTANCE() {
    if(INSTANCE == null){
      synchronized(IdGenerator.class) {
        if(INSTANCE == null){
          INSTANCE = new SingletonDemo6();
        }
      }
    }
    return INSTANCE;
  }

}
```

## 单例模式存在的问题
1. 硬编码，不符合面向接口编程原则
2. 对继承和多态等 OOP 特性的支持不友好
3. 隐藏类之间的依赖关系
4. 对代码的扩展性不好
5. 对代码的可测试性不好（自身依赖较重）
6. 不支持有参构造器

### 单例模式的替代方案
1. 改用静态方法实现
2. 将单例生成的对象作为参数传递给函数
3. 工厂模式
4. IOC 容器保证


## 如何理解单例模式中的唯一性
**线程中唯一还是进程内唯一**

答：进程，即不同进程中，生成的单例对象也是不同的

## 如何实现线程唯一的单例
既然单例在进程中是唯一的，那么如何在线程中实现唯一的单例呢？

答：使用 HashMap 存储

```java
public class IdGenerator {
  private AtomicLong id = new AtomicLong(0);
  private static final ConcurrentHashMap<Long, IdGenerator> instances
          = new ConcurrentHashMap<>();
  private IdGenerator() {}
  public static IdGenerator getInstance() {
    Long currentThreadId = Thread.currentThread().getId();
    instances.putIfAbsent(currentThreadId, new IdGenerator());
    return instances.get(currentThreadId);
  }
  public long getId() {
    return id.incrementAndGet();
  }
}
```

## 如何实现集群环境下唯一的单例
集群下唯一 <=> 进程间唯一 && 进程内唯一

**如何实现**

1. 将单例对象序列化并存储到外部共享存储区（比如文件）
2. 某进程反序列化获取到对象之后，对其加锁，避免其他进程再将其获取。
3. 使用完后，需显式地将对象从内存中删除，并且释放对对象的加锁，然后再存储回外部共享存储区。

code：

略

## 如何实现一个多例模式
即可创建多个实例，但个数有限（枚举类型就是一种多例模式），也可使用 HashMap 按照编号获取对应的单例