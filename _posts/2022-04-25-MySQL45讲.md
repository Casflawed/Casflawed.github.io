---
title: MySQL45讲
date: 2022-04-25 +/-TTTT
categories: [中间件,MySQL]
tags: [极客时间]     # TAG names should always be lowercase
---

## 01 基础架构：一条SQL查询语句是如何执行的？
### 架构流程图

![架构流程图](/blog/202204261432962.png "架构流程图")
### 连接器
#### 长连接可能出现的问题
当连接器使用长连接管理MySQL客户端和服务端的连接时，容易因为内存过大，导致MySQL服务重启；原因是因为：MySQL执行过程中内存是被管理在了连接对象中，连接断开，内存才会释放，所以当我们全部使用长连接时，内存就会涨的特别快，甚至导致服务被系统强制杀死，从现象看就是MySQL服务异常重启。

如何解决：

1.定期断开连接
2.在MySQL5.7和更新版本，使用mysql_reset_connection命令重新初始化连接资源，该过程不需要重连或重新进行权限验证，但是会将连接重置为刚刚创建完成的状态

### 查询缓存
#### 为什么不建议使用查询缓存
弊大于利：

1.一旦执行更新操作，缓存会全部清除，意思是辛辛苦苦维护缓存，结果还没来得及用就被删除了，白白浪费了资源；所以如果要使用缓存，尽量是更新操作比较少的数据库
2.MySQL8.0之后完全割掉了查询缓存的功能

#### 按需使用查询缓存
件参数query_cache_type参数设置成demand，这样默认对于SQL语句不使用查询缓存，如果要针对特定语句使用查询缓存，操作如下：

```sql
mysql> select SQL_CACHE * from T where id=10;
```

## 02 日志系统：一条SQL更新语句是如何执行的？
### 预知
1.MySQL的数据以数据页为单位，按偏移量寻找记录的具体位置，所以每次IO操作都是一个个数据页加载到内存，但是我们需要查询或修改的数据也许就是一条记录，甚至对于更新操作，又会将数据页整个的刷新到磁盘，所以IO成本非常高，因而为了降低IO操作的成本，MySQL做了大量的努力

### 更新操作牵涉两个重要的日志：redo log和binlog
#### redo log怎么起作用的
redo log可以简单分为两个部分

- 内存层面的redo log buffer
- 持久化层面的redo log file

redo log实现的具体逻辑：

![redo log如何起作用](/blog/202204271023885.png "redo log如何起作用")

#### write pos 和 check point
write pos是redo log追加日志的索引，check point与write pos是剩余和写入日志的空间，当write pos = redo log时，write pos会向前推进，这样就形成了一个循环队列的数据结构，具体的形象图如下：

![write pos 和 check point](/blog/202204271028957.png "write pos 和 check point")

#### binlog和redo log的区别
1.redo log是InnoDB独有的，而binlog是server层的，所有的引擎都可以使用
2.在更新事务期间，redo log会循环不断记录，而binlog会在事务提交时一次性写入
3.binlog记录的是原始逻辑，也就是把SQL语句直接存入，redo log则是物理日志
4.redo log空间固定，binlog可追加写，写完一个，会继续写另一个，这就说明binlog可以用来恢复临时库，因为里面记录任意时刻的原始操作

#### binlog的工作逻辑
通过备份库里会备份近半个月的binlog，用于恢复临时库，当然如果想要数据库恢复更久之前的状态，也可以备份更长的甚至是一年的binlog

## 03 事务隔离：为什么你改了我还看不见？

### 事务隔离级别
1.读未提交（read uncommitted）
    事务未提交，它做的变更就可被其他事务看见
2.读已提交（read committed）
    事务提交后，它做的变更才可见
3.可重复读（repeatable read）
    事务在执行过程中看到的数据，与事务开启时看到的数据是一致的
4.串行化（serializable）
    顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 事务隔离级别的实现机理
#### 事务上的视图
事实上，当一个事务访问一条记录时，**数据库服务器会为这个这条记录生成一个视图**，而事务访问时都会以这个视图的逻辑结果为准；

1.读未提交没有视图的概念，它总是读取一条记录的最新值
2.读已提交，视图是在每个SQL执行的时候生成的，因此如果是同一条SQL，每次执行的视图可能会不一样（也就是如果当前记录被已提交事务修改）
3.可重复读，视图是在事务开启的时候生成的，因而事务的整个存在期间（未提交前）都是以这个视图为准的
4.串行化，直接用加锁的方式避免事务的并行访问

查看当前事务的隔离级别：

```sql
show variables like 'transaction_isolation';
```

#### 事务上的回滚日志
我们知道事务的原子性通过回滚日志实现，而对于一条记录的回滚日志，如下图：

![一条记录的回滚日志](/blog/202204280831840.png "一条记录的回滚日志")

其中read-view是视图，我们发现当查询这条记录的时候，不同时刻启动的事务会用不同的视图，使得同一条记录在不同的事务居然会有呈现不同的值，这就是数据库的多版本并发控制(MVCC)，知道系统中事务使用的视图都比回滚日志中靠后，那么该回滚日志就会被删除了；

回滚日志应该不会只存一条记录，所以如果是长事务，他就可能占用一个很古老的视图，这样会导致回滚日志越来越长，事务提交前这些回滚日志都会保留下来，这样就会消耗大量的存储空间，因此我们应该将事务的提交控制在自己的手里；

手动操作事务：

```sql
set autocommit=0 #关闭事务的自动提交
begin 或者 start transaction #开启事务
commit #提交事务
rollback #回滚事务
commit work and chain #提交事务并自动开启下一个事务
#查找持续时间超过60s的事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
```

## 04 深入浅出索引（上）
### 索引的实现模型
#### 哈希表
模型结构如下：

![哈希表](/blog/202204280948306.png "哈希表")

本哈希表以数组和链表为数据结构，哈希表通过哈希函数计算出索引可能的下标，并将值存在数组当中，如果不同的索引值命中相同的下标，那么会作为节点链接在数组元素后面；

以Java的hashMap为例，数据以key-value键值对存在底层哈希表中，正如hashMap不会维护key值有序性，当我们针对一个区别查找数据的时候就会很麻烦，比如我的hashMap结构是一个Integer，User的键值对，存的是**身份证id《---》居民信息**由于数据存入时并没有保证有序性，当我们查找（101，201）这个区间的用户时，就要遍历所有的记录，直至查出所有的在这个区间的用户，所以说：**哈希表这种结构适用于只有等值查询的场景，不适用范围查询**，示意图如下：

![身份证id，居民信息哈希表示意图](/blog/202204281003151.png "身份证id，居民信息哈希表示意图")

#### 有序数组
如果是有序数组，那么既可以保证身份证id的有序性，又能通过索引等值查询到需要的数据，这样看来有序数组完美适应等值查询和范围查询，但是**如果向数组插入数据，就必须将后面的数据向后移动一段距离，时间复杂度可想而知**，因此它适合静态数据的存储，如每年城市人口的数据

#### 二叉搜索树
先来看看如果以身份证，用户信息作为案例：

![Alt text](/path/to/img.jpg "二叉搜索树存储用户信息")

二叉树每个节点会分配一个权值，整好可以作为索引，为了保证二叉搜索树插入和查询的时间复杂度都是O(logn)，应该保证它是平衡二叉树（AVL树），二分查找树其实很像数组的二分查找，因而二叉树是一个查询效率很高的数据结构，不过它作为索引的底层数据结构却并不待见，**原因是数据高度过高，如果每一层作为一个数据块存在磁盘中那么，一次查找可能触发很多次IO操作**，效率可想而知

因而出现了多叉树，即尽量让一个数据块存更多的数据，这样就能有效降低树的高度，减少IO操作的次数，**N叉树目前已经广泛应用于数据库引擎**；

二叉树其实是特殊的N叉树，N叉树的基本结构和代码表示：

![N叉树的基本结构](/blog/202204281227116.png "N叉树的基本结构")

由于N叉树的根节点子数不确定，所以应该使用动态数组存储，在Java中我们就用ArrayLst（当然实际上用的是接口List，毕竟LinkedList也不是不可以）

```java
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
```

### InnoDB的索引模型
InnoDB底层使用B+树作为索引的数据结构，B+树是更加复杂的多叉树，一个索引将会对应一棵B+树，索引---N叉树，1对1的关系；


索引类型分为主键索引（聚簇索引）和非主键索引，主键索引叶子节点存的是一行的数据，而非主键索引存的是主键的值，因此，非主键索引也称为二级索引；**显然使用非主键索引会多查一次树，因此主键索引的查询效率更高**

### 索引维护
#### 页分裂现象
下图是之前的身份证id-user的索引结构，以身份证Id作为索引：
![身份证id索引结构](https://cdn.jsdelivr.net/gh/Casflawed/img-host@master/blog/202204281257373.png "身份证id索引结构")

所谓的页分裂，比如在R5之前插入数据，结果需要把R5的一部分数据往后挪，结果R5的数据分布在两个数据页，导致数据页使用率下降，此时前一个数据页存了R4和R5，后一个数据页只存了R5这就是页分裂（*这个例子有点牵强*）

#### 采用自增主键
在页分裂中我们看到，如果需要插入数据，B+树和有序数组一样，需要将后面的数据往后挪以腾出空间，但是如果是自增主键，每次只要追加就好了，**因此推荐使用自增主键**

#### 自增主键和业务逻辑做主键
首先，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以用自增主键是不错的选择；而业务逻辑主键不容易保存有序插入（比较可能比较复杂吧），这样写入操作可能耗时较多

什么时候适合用业务主键呢，K-V形式的场景，即：

1.整张表只有一个索引
2.索引必须是唯一索引

由于没有其他索引，就不用考虑主键占用空间较大的问题，对于插入问题，如果是整型还好，不是也没办法，毕竟有一个索引，相对而言使用索引查询和添加速率都会较快


