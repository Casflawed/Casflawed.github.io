---
title: MySQL45讲
date: 2022-04-25 +/-TTTT
categories: [中间件,MySQL]
tags: [极客时间]     # TAG names should always be lowercase
---

## 01 基础架构：一条SQL查询语句是如何执行的？
### 架构流程图

![架构流程图](/blog/202204261432962.png "架构流程图")
### 连接器
#### 长连接可能出现的问题
当连接器使用长连接管理MySQL客户端和服务端的连接时，容易因为内存过大，导致MySQL服务重启；原因是因为：MySQL执行过程中内存是被管理在了连接对象中，连接断开，内存才会释放，所以当我们全部使用长连接时，内存就会涨的特别快，甚至导致服务被系统强制杀死，从现象看就是MySQL服务异常重启。

如何解决：

1.定期断开连接
2.在MySQL5.7和更新版本，使用mysql_reset_connection命令重新初始化连接资源，该过程不需要重连或重新进行权限验证，但是会将连接重置为刚刚创建完成的状态

### 查询缓存
#### 为什么不建议使用查询缓存
弊大于利：

1.一旦执行更新操作，缓存会全部清除，意思是辛辛苦苦维护缓存，结果还没来得及用就被删除了，白白浪费了资源；所以如果要使用缓存，尽量是更新操作比较少的数据库
2.MySQL8.0之后完全割掉了查询缓存的功能

#### 按需使用查询缓存
件参数query_cache_type参数设置成demand，这样默认对于SQL语句不使用查询缓存，如果要针对特定语句使用查询缓存，操作如下：

```sql
mysql> select SQL_CACHE * from T where id=10;
```

## 02 日志系统：一条SQL更新语句是如何执行的？
### 预知
1.MySQL的数据以数据页为单位，按偏移量寻找记录的具体位置，所以每次IO操作都是一个个数据页加载到内存，但是我们需要查询或修改的数据也许就是一条记录，甚至对于更新操作，又会将数据页整个的刷新到磁盘，所以IO成本非常高，因而为了降低IO操作的成本，MySQL做了大量的努力

### 更新操作牵涉两个重要的日志：redo log和binlog
#### redo log怎么起作用的
redo log可以简单分为两个部分

- 内存层面的redo log buffer
- 持久化层面的redo log file

redo log实现的具体逻辑：

![redo log如何起作用](/blog/202204271023885.png "redo log如何起作用")

#### write pos 和 check point
write pos是redo log追加日志的索引，check point与write pos是剩余和写入日志的空间，当write pos = redo log时，write pos会向前推进，这样就形成了一个循环队列的数据结构，具体的形象图如下：

![write pos 和 check point](/blog/202204271028957.png "write pos 和 check point")

#### binlog和redo log的区别
1.redo log是InnoDB独有的，而binlog是server层的，所有的引擎都可以使用
2.在更新事务期间，redo log会循环不断记录，而binlog会在事务提交时一次性写入
3.binlog记录的是原始逻辑，也就是把SQL语句直接存入，redo log则是物理日志
4.redo log空间固定，binlog可追加写，写完一个，会继续写另一个，这就说明binlog可以用来恢复临时库，因为里面记录任意时刻的原始操作

#### binlog的工作逻辑
通过备份库里会备份近半个月的binlog，用于恢复临时库，当然如果想要数据库恢复更久之前的状态，也可以备份更长的甚至是一年的binlog

## 03 事务隔离：为什么你改了我还看不见？

### 事务隔离级别
1.读未提交（read uncommitted）
    事务未提交，它做的变更就可被其他事务看见
2.读已提交（read committed）
    事务提交后，它做的变更才可见
3.可重复读（repeatable read）
    事务在执行过程中看到的数据，与事务开启时看到的数据是一致的
4.串行化（serializable）
    顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 事务隔离级别的实现机理
#### 事务上的视图
事实上，当一个事务访问一条记录时，**数据库服务器会为这个这条记录生成一个视图**，而事务访问时都会以这个视图的逻辑结果为准；

1.读未提交没有视图的概念，它总是读取一条记录的最新值
2.读已提交，视图是在每个SQL执行的时候生成的，因此如果是同一条SQL，每次执行的视图可能会不一样（也就是如果当前记录被已提交事务修改）
3.可重复读，视图是在事务开启的时候生成的，因而事务的整个存在期间（未提交前）都是以这个视图为准的
4.串行化，直接用加锁的方式避免事务的并行访问

查看当前事务的隔离级别：

```sql
show variables like 'transaction_isolation';
```

#### 事务上的回滚日志
我们知道事务的原子性通过回滚日志实现，而对于一条记录的回滚日志，如下图：

![一条记录的回滚日志](/blog/202204280831840.png "一条记录的回滚日志")

其中read-view是视图，我们发现当查询这条记录的时候，不同时刻启动的事务会用不同的视图，使得同一条记录在不同的事务居然会有呈现不同的值，这就是数据库的多版本并发控制(MVCC)，知道系统中事务使用的视图都比回滚日志中靠后，那么该回滚日志就会被删除了；

回滚日志应该不会只存一条记录，所以如果是长事务，他就可能占用一个很古老的视图，这样会导致回滚日志越来越长，事务提交前这些回滚日志都会保留下来，这样就会消耗大量的存储空间，因此我们应该将事务的提交控制在自己的手里；

手动操作事务：

```sql
set autocommit=0 #关闭事务的自动提交
begin 或者 start transaction #开启事务
commit #提交事务
rollback #回滚事务
commit work and chain #提交事务并自动开启下一个事务
#查找持续时间超过60s的事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
```

## 04 深入浅出索引（上）


