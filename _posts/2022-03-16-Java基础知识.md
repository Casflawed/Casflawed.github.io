---
title: Java基础
date: 2022-03-16 +/-TTTT
categories: [编程语言, Java]
tags: []     # TAG names should always be lowercase
---

# 方法
1.静态方法为什么不能调用非静态成员

- 静态方法在类初始化时分配内存，此时对象还没初始化，也就是说还不存在this，而非静态成员需要this进行调用
- 静态方法和静态变量是可以被子类继承的，但是会被隐藏，因为它们本身是属于类的，也就是说你调用静态成员时可以直接通过类名，既然如此你还有必要用子类来调用静态成员吗？

2.子类可以重写父类的静态方法吗：不能

- 根据实验，向上转型的子类，调用静态方法不能体现多态，说明子类并不能重写父类的静态方法

3.重写与重载的区别

- 方法是否冲突，跟方法名和参数类型以及参数顺序有关，与返回值、方法修饰符无关
- 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。其中返回值、修饰符、参数个数和顺序都可以不同但方法名必须相同
- 调用哪个重载的方法是在编译期就决定了的
- 重写就是对父类方法的改造，当子类方法中根据相同的参数需要返回不同的处理结果，就需要对方法进行重写
- 调用重写方法是在运行起决定的
- 重写方法的参数类型、个数和顺序必须与父类方法相同；返回值的类型如果是void或基本数据类型，则不能修改，如果是引用数据类型可以是该类型的子类；抛出的异常类型范围小于等于父类，访问修饰符的范围大于等于父类
- 重载方法的参数列表必须修改，重写方法的参数列表不能修改

4.equals()和==的区别

- 对于基本数据类型，==比较的是两者的值；对于引用数据类型，==比较的是对象的内存地址
- equals()是Object类中的实例方法，效果与==比较对象是一样的
- 在其他类型基本重写了equals()方法，例如String类重写equals()方法后的效果是：①比较两个对象变量指向的内存变量是否相同；②判断对象是否同类型或者是父子类关系；③判断对象属性是否相同

5.为什么重写equals，需要同时重写hashCode方法

- 有如下Java规范：obj1.equals(obj2) == true ---> obj1.hashCode()==obj2.hashCode()，反之，如果obj1.hashCode()==obj2.hashCode()，obj1.equals(obj2)不一定等于true，但为了提高hash表的效率，应该使其相等
- hashCode方法存在的意义就是为了提高hash表的查询效率，这样就可以减少equals的次数，比如HashSet和HashMap，其中HashSet底层就是利用的HashMap的key特性保证了元素的唯一性
- 对于HashMap的put方法，对于put(key,value)，首先会比较key.hashCode的值在HashMap中是否有与之相等的，如果不等直接存入，如果相等会再比较equals，判断是否为同一对象，如果确实为同一对象，那么就会覆盖原来的value，如果不为同一对象，就是存在拉链后面，该拉链的底层数据结构是链表

6.this()和super()调用的先后顺序

- 有显式this()调用的构造器就会抑制掉该构造器里隐式的super()调用；没有显式this()调用的构造器则会得到隐式的super()调用。
- this()调用会借助别的重载版本的构造器来做部分初始化，而一连串this()最后来到的构造器必然是没有显式this()调用的，这里就会有显式或隐式的super()调用。
- 并不是构造子类对象的同时会构造父类对象，而是一个子类对象的实例会包含其所有基类所声明的字段，外加自己新声明的字段。那些父类声明的字段并不构成一个完整的父类的实例。super()是让父类封装对自己所声明的字段做初始化的手段。

# 运算符
1.右移运算符>>和无符号右移运算符>>>

- ex1>>ex2，其中ex2表示移动的位数，ex1移动时，向右移出的位被丢弃，左边用符号位填充（是正数就用0，负数就用1）
- ex1>>>ex2，无论ex1为负数还是正数，左边统一用0填充

2.异或运算符^

# 类和对象
1.怎么理解Java对象：把现实中不同的数据绑定在一起形成的单一整体，称它为对象；简单来说对象就是用来存储一些关联数据的有机结合体，或者说对象可以看成是一个容器，一个集合，这个里面存放的逻辑相关的数据

2.null是所有引用类型的默认值，可以赋值给任何引用类型变量，但是不能赋值给基本类型变量；null可以转换成任何引用类型；

3.Java里float、double、long，需要在赋值直接量后面分别添加f或F、d或D、l或L尾缀来说明。不添加容易引发编译错误，丢失精度等问题

4.包装类底层的常量池技术

- 什么是常量池，就是说事先准备了一个范围的数据放在池子(在底层叫缓存数组)里，那么基本数据类型进行自动装箱时，如果在这个范围内就会用常量池中的数据赋值，因此只要实在这个范围的基本数据类型，被装箱后指向的都是同一个对象；（注意如果是new创建的包装类对象那么就是不同的对象，所以建议在比较包装类对象时使用equals()方法）
- 除了浮点类型float、double其他基本数据类型的包装类都实现了常量池技术
- 常量池技术本身是用来提高性能的，试想每次包装时都需要new出对象效率是不是很低，如果在池子里事先准备好，赋值时直接指向就好了，这样就大大提高了性能，当然由于性能和占用空间资源的权衡，底层池子里数据的范围不会很大，不应该造成数组的长度过长，过度占用空间的情况
- 自动装箱和拆箱：装箱其实就是调用了包装类的valueOf()方法，拆箱其实就是调用了xxxValue()方法。

# 抽象类和接口
1.抽象类主要用于代码复用，而接口用于限制行为，比如实现了某种接口就拥有了某个行为

# Java反射机制：程序利用运行时信息动态获取该对象和类的真实信息，这就是反射

1.反射的主要用法

- 创建实例
- 反射调用方法

2.反射的应用场景

- 松耦合，通过工厂模式+配置模式的方式替换new生成对象的方法

3.Method对象：现有一个问题：子类继承父类，并重写了父类中的方法A，那么此时在子类的Class对象中，Method数组对于A()是只有一个子类重写了的A()，还是说，父类的A()和子类的A()都在？

- 经过源码分析：isAssignableFrom()该方法在searchMethod()方法用于判断方法返回类型是否属于父子类关系，如果returnType更小，则getMethod()会获得更小类型的那个方法，也就是说就算子类方法返回值类型与父类不同，最终调用的方法也还是子类的方法，另外，如果方法返回值相同，那么Method数组内部就只有一个子类重写的方法

4.（Class<?>）clazz.newInstance()底层默认调用的依然是无参构造器，因而我们在声明了有参构造器的同时一定要显式声明无参构造器，因为Java底层很多都是利用无参构造器生成的对象；当然我们也可以手动调用有参构造器对象的newInstance()生成对象；

# 注解
1.注解是什么？

- 注解和类、接口、枚举是同一级别的
- 注解是写给程序看的，往往出现在类、方法、成员变量、形参位置
- 它主要为当前读取该注解的程序提供判断依据及少量附加信息；如程序读到加了@Test的方法就知道这个方法是待测试方法；又比如@Before，程序读到它就知道该方法要放在@Test方法之前执行；还有@RequestMapping("/user/info")提供了Controller某个接口的URL；
- 总的来说，注解作为给程序读取的标注信息，往往利用完就会被抛弃，而这就涉及到保留策略了

2.自定义注解的三步骤

- 定义注解
- 在程序中（类上、方法上、域上）使用注解
- 在其他程序读取注解信息，并执行

3.注解的保留策略

- 注解通过保留策略，控制自己可以保留到哪个阶段。
- 保留策略也是通过注解实现，它属于元注解，也叫元数据。具体来说是通过元数据@Retention实现的
- 保留策略的实现有三种：SOURCE、ClASS、RUNTIME；分别对应着.java文件，.class文件，jvm的Class对象；
- 如果在自定义注解时不加@Retention，注解的保留策略默认是CLASS
- 使用各保留策略的注解例子：①@Override对应SOURCE，编译成.class文件就会消失
- 通常情况我们只会使用jdk注解、第三方框架注解，，三步骤中的定义注解、读取执行两个步骤用不着我们来做，都被jdk和框架封装隐藏了，这其实也导致了大部分人对注解的陌生


# 高内聚低耦合
1.松耦合的目的

- 某一模块更改下，不会影响到其他模块；模块之家更加独立，这样在维护代码时就不会产生该一处代码，带动其他模块大量的代码改动